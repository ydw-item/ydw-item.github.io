<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>内部FLASH</title>
      <link href="/2025/05/13/FLASH/"/>
      <url>/2025/05/13/FLASH/</url>
      
        <content type="html"><![CDATA[<p><strong>参考资料</strong>：</p><p><a href="https://blog.csdn.net/ST_Liam/article/details/108922753">1.STM32系列芯片命名规则——简明_stm32命名规则-CSDN博客</a></p><h1 id="一、存储单位介绍"><a href="#一、存储单位介绍" class="headerlink" title="一、存储单位介绍"></a>一、存储单位介绍</h1><h1 id="1-1-内存单位换算"><a href="#1-1-内存单位换算" class="headerlink" title="1.1 内存单位换算"></a>1.1 内存单位换算</h1><table><thead><tr><th align="center">单位</th><th align="center">缩写</th><th align="center">大小关系</th></tr></thead><tbody><tr><td align="center">位</td><td align="center">Bit</td><td align="center">基本单位</td></tr><tr><td align="center">字节</td><td align="center">Byte</td><td align="center">1Byte &#x3D; 1024 Bit</td></tr><tr><td align="center">千字节</td><td align="center">KB</td><td align="center">1 KB &#x3D; 1024 Byte</td></tr><tr><td align="center">兆字节</td><td align="center">MB</td><td align="center">1 MB &#x3D; 1024 KB &#x3D; 1024 × 1024 B</td></tr><tr><td align="center">吉字节</td><td align="center">GB</td><td align="center">1 GB &#x3D; 1024 MB &#x3D; 1024 × 1024 × 1024 B</td></tr><tr><td align="center">太字节</td><td align="center">TB</td><td align="center">1 TB &#x3D; 1024 GB &#x3D; 1024 × 1024 × 1024 × 1024 B</td></tr><tr><td align="center">拍字节</td><td align="center">PB</td><td align="center">1 PB &#x3D; 1024 TB</td></tr></tbody></table><table><thead><tr><th align="center">单位</th><th align="center">缩写</th><th align="center">大小关系</th></tr></thead><tbody><tr><td align="center">字节</td><td align="center">Byte</td><td align="center">基本单位</td></tr><tr><td align="center">半字</td><td align="center">B</td><td align="center">2字节</td></tr><tr><td align="center">字</td><td align="center">KB</td><td align="center">4字节</td></tr></tbody></table><h1 id="1-2-内存布局"><a href="#1-2-内存布局" class="headerlink" title="1.2 内存布局"></a>1.2 内存布局</h1><p><img src="/2025/05/13/FLASH/image-20250513153603543-1747132152193-1.png" alt="image-20250513153603543"></p><h1 id="二、内部FALSH介绍"><a href="#二、内部FALSH介绍" class="headerlink" title="二、内部FALSH介绍"></a>二、内部FALSH介绍</h1><h2 id="2-1-STM32内存分布"><a href="#2-1-STM32内存分布" class="headerlink" title="2.1 STM32内存分布"></a>2.1 STM32内存分布</h2><p><img src="/2025/05/13/FLASH/image-20250513170648680-1747132152193-2.png" alt="image-20250513170648680"></p><h2 id="2-2-FALSH分布"><a href="#2-2-FALSH分布" class="headerlink" title="2.2 FALSH分布"></a>2.2 FALSH分布</h2><p><img src="/2025/05/13/FLASH/image-20250513161524133-1747132152193-3.png" alt="image-20250513161524133"></p><h1 id="三、-函数调用"><a href="#三、-函数调用" class="headerlink" title="三、 函数调用"></a>三、 函数调用</h1><h2 id="2-1-写数据"><a href="#2-1-写数据" class="headerlink" title="2.1 写数据"></a>2.1 写数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASH_Program</span><span class="params">(<span class="type">uint32_t</span> TypeProgram, <span class="type">uint32_t</span> Address, <span class="type">uint64_t</span> Data)</span>;</span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASH_Program_IT</span><span class="params">(<span class="type">uint32_t</span> TypeProgram, <span class="type">uint32_t</span> Address, <span class="type">uint64_t</span> Data)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>TypeProgram</strong>：指定编程模式（即写入的位宽）</p><ul><li><code>FLASH_TYPEPROGRAM_BYTE</code>：8 位写入</li><li><code>FLASH_TYPEPROGRAM_HALFWORD</code>:16 位写入</li><li><code>FLASH_TYPEPROGRAM_WORD</code>:32 位写入</li><li><code>FLASH_TYPEPROGRAM_DOUBLEWORD</code>:64 位写入</li></ul></li><li><p><strong>TypeProgram</strong>：要写入的 Flash 地址</p></li><li><p><strong>Data</strong>：要写入的数据</p></li></ul><h2 id="2-2-擦除数据"><a href="#2-2-擦除数据" class="headerlink" title="2.2 擦除数据"></a>2.2 擦除数据</h2><h3 id="2-2-1-擦除单个扇区"><a href="#2-2-1-擦除单个扇区" class="headerlink" title="2.2.1 擦除单个扇区"></a>2.2.1 擦除单个扇区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Erase_Sector</span><span class="params">(<span class="type">uint32_t</span> Sector, <span class="type">uint8_t</span> VoltageRange)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>Sector</strong>：要擦除的扇区编号</li><li><strong>VoltageRange</strong>：根据供电电压选择擦除时序<ul><li><code>FLASH_VOLTAGE_RANGE_3</code>：2.7V~3.6V</li><li><code>FLASH_VOLTAGE_RANGE_2</code>：2.1V~2.7V</li></ul></li></ul><h3 id="2-2-3-擦除多个扇区"><a href="#2-2-3-擦除多个扇区" class="headerlink" title="2.2.3 擦除多个扇区"></a>2.2.3 擦除多个扇区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASHEx_Erase</span><span class="params">(FLASH_EraseInitTypeDef *pEraseInit, <span class="type">uint32_t</span> *SectorError)</span>;</span><br><span class="line"></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASHEx_Erase_IT</span><span class="params">(FLASH_EraseInitTypeDef *pEraseInit)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>pEraseInit</strong>：<code>FLASH_EraseInitTypeDef</code>结构体的指针<ul><li>FLASH_EraseInitTypeDef<ul><li><code>TypeErase</code>：擦除类型（扇区擦除或块擦除）<ul><li><code>FLASH_TYPEERASE_SECTORS</code>：擦除扇区</li><li><code>FLASH_TYPEERASE_MASSERASE</code>：全片擦除</li></ul></li><li><code>Banks</code>：在双 Bank 架构的芯片（如 STM32F7&#x2F;H7）中选择操作的 Bank，单 Bank 芯片（如 F1&#x2F;F4）可忽略此参数<ul><li><code>FLASH_BANK_1</code>：操作 Bank 1</li><li><code>FLASH_BANK_2</code>：操作 Bank 2</li><li><code>FLASH_BANK_BOTH</code>：操作 Bank 12</li></ul></li><li><code>Sector</code>：指定擦除的起始扇区编号</li><li><code>NbSectors</code>：指定连续擦除的扇区数量，值必须 ≥ 1</li><li><code>VoltageRange</code>：电压范围（影响擦除时间）<ul><li><code>FLASH_VOLTAGE_RANGE_1</code>：1.8V 以下</li><li><code>FLASH_VOLTAGE_RANGE_2</code>：1.8V~2.1V</li><li><code>FLASH_VOLTAGE_RANGE_3</code>：2.1V~2.7V</li><li><code>FLASH_VOLTAGE_RANGE_4</code>：2.7V~3.6V</li></ul></li></ul></li></ul></li><li><strong>SectorError</strong>：记录擦除失败的扇区号</li></ul><h2 id="2-3-FALSH开关锁"><a href="#2-3-FALSH开关锁" class="headerlink" title="2.3 FALSH开关锁"></a>2.3 FALSH开关锁</h2><p><strong>擦写数据之前要进行开关锁操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASH_Unlock</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//开锁，可以擦写</span></span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASH_Lock</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//关锁，不可以擦写</span></span><br></pre></td></tr></table></figure><h2 id="2-4-回调函数"><a href="#2-4-回调函数" class="headerlink" title="2.4 回调函数"></a>2.4 回调函数</h2><h3 id="2-4-1-擦写成功回调函数"><a href="#2-4-1-擦写成功回调函数" class="headerlink" title="2.4.1 擦写成功回调函数"></a>2.4.1 擦写成功回调函数</h3><p><strong>Flash 编程或擦除操作成功完成时</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_FLASH_EndOfOperationCallback</span><span class="params">(<span class="type">uint32_t</span> ReturnValue)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>0xFFFFFFFF</code>：表示操作成功</li><li><code>其它值</code>：失败时的错误地址</li></ul><h3 id="2-4-2-擦写失败回调函数"><a href="#2-4-2-擦写失败回调函数" class="headerlink" title="2.4.2 擦写失败回调函数"></a>2.4.2 擦写失败回调函数</h3><p><strong>Flash 操作（擦除或编程）发生硬件错误时</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_FLASH_OperationErrorCallback</span><span class="params">(<span class="type">uint32_t</span> ReturnValue)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>ReturnValue</code>：出错时的 Flash 地址或错误标志</li><li><code>具体地址</code>：说明该地址的操作失败</li><li><code>0xFFFFFFFF</code>：表示错误与特定地址无关（如全局错误）</li></ul><h2 id="2-5-选项字节开关锁"><a href="#2-5-选项字节开关锁" class="headerlink" title="2.5 选项字节开关锁"></a>2.5 选项字节开关锁</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASH_OB_Unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASH_OB_Lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="2-6-编程（修改）选项字节"><a href="#2-6-编程（修改）选项字节" class="headerlink" title="2.6 编程（修改）选项字节"></a>2.6 编程（修改）选项字节</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASHEx_OBProgram</span><span class="params">(FLASH_OBProgramInitTypeDef *pOBInit)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>OptionType</strong>：指定要修改的选项类型（可组合）</p><ul><li><code>OPTIONBYTE_WRP</code>：写保护</li><li><code>OPTIONBYTE_RDP</code>：保护</li><li><code>OPTIONBYTE_USER</code>：用户配置</li><li><code>OPTIONBYTE_BOR</code>：电压跌落复位</li></ul></li><li><p><strong>WRPState</strong>：写保护状态</p><ul><li><code>OB_WRPSTATE_DISABLE</code>：禁用保护</li><li><code>OB_WRPSTATE_ENABLE</code>：启用保护</li></ul></li><li><p><strong>WRPSector</strong>：写保护扇区</p></li><li><p><strong>Banks</strong>：在双 Bank 架构的芯片（如 STM32F7&#x2F;H7）中选择操作的 Bank，单 Bank 芯片（如 F1&#x2F;F4）可忽略此参数</p><ul><li><code>FLASH_BANK_1</code>：操作 Bank 1</li><li><code>FLASH_BANK_2</code>：操作 Bank 2</li><li><code>FLASH_BANK_BOTH</code>：操作 Bank 12</li></ul></li><li><p><strong>RDPLevel</strong>：读保护级别</p><ul><li><code>OB_RDP_LEVEL_0</code>：无保护</li><li><code>OB_RDP_LEVEL_1</code>：启用保护</li><li><code>OB_RDP_LEVEL_2</code>：永久保护（不可逆！）</li></ul></li><li><p><strong>BORLevel</strong>：电压跌落复位阈值</p></li><li><p><strong>USERConfig</strong>：用户配置</p></li></ul><h2 id="2-7-应用已修改的选项字节"><a href="#2-7-应用已修改的选项字节" class="headerlink" title="2.7 应用已修改的选项字节"></a>2.7 应用已修改的选项字节</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_FLASH_OB_Launch</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-8-获取当前的选项字节配置"><a href="#2-8-获取当前的选项字节配置" class="headerlink" title="2.8 获取当前的选项字节配置"></a>2.8 获取当前的选项字节配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit);</span><br></pre></td></tr></table></figure><h2 id="2-9-等待一个-Flash-操作"><a href="#2-9-等待一个-Flash-操作" class="headerlink" title="2.9 等待一个 Flash 操作"></a>2.9 等待一个 Flash 操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">FLASH_WaitForLastOperation</span><span class="params">(<span class="type">uint32_t</span> Timeout)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 外设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPI通信协议</title>
      <link href="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/"/>
      <url>/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/</url>
      
        <content type="html"><![CDATA[<p><strong>参考资料</strong>：</p><h1 id="一、SPI简介"><a href="#一、SPI简介" class="headerlink" title="一、SPI简介"></a>一、SPI简介</h1><p><strong>SPI</strong>英文全称Serial Peripheral Interface，即串行外围设备接口，是一种高速、<strong>全双工</strong>、<strong>同步</strong>的<strong>串行</strong>通信总线。</p><h1 id="二、-信号线"><a href="#二、-信号线" class="headerlink" title="二、 信号线"></a>二、 信号线</h1><ul><li><strong>SCK</strong>（Serial Clock）：串行<strong>时钟线</strong>，由主设备产生，用于同步数据传输。</li><li><strong>MOSI</strong>（Master Output Slave Input）：<strong>主机输出</strong>从机输入线，主设备通过这条线发送数据给从设备。</li><li><strong>MISO</strong>（Master Input Slave Output）：<strong>主机输入</strong>从机输出线，主设备通过这条线接收从设备发送的数据。</li><li><strong>CS</strong>（Slave Select）(NSS或SS)：<strong>从机选择线</strong>（每个从机一根选择线），用于选择与主设备进行通信的从设备。通常情况下，SS线为<strong>低电平有效</strong>，即当<strong>SS</strong>线为<strong>低电平</strong>时，<strong>选中对应的从设备进行通信</strong>。</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/5.png" alt="image-20250511102329794"></p><h1 id="三、-开始与结束"><a href="#三、-开始与结束" class="headerlink" title="三、 开始与结束"></a>三、 开始与结束</h1><p>当SS从高电平拉低到<strong>低电平</strong>，这个算是<strong>起始</strong>的一个时序。而SS从低电平拉高到<strong>高电平</strong>，就算是结束的时序。</p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/1.png" alt="img"></p><h2 id="1-4-发送和接收字节"><a href="#1-4-发送和接收字节" class="headerlink" title="1.4 发送和接收字节"></a>1.4 发送和接收字节</h2><p>发送接收字节看似是两个时序，但是在SPI中却是<strong>同一个时序</strong>，因为SPI的机制是&#x3D;&#x3D;我们发送一个字节，并且接收一个字节&#x3D;&#x3D;（<strong>哪怕我们并不需要接收数据</strong>）。反过来看也可以是我们接收一个字节，并且发送一个字节（<strong>哪怕这个字节是无用的数据</strong>）。</p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/6.png" alt="image-20250511102607470"></p><ul><li>来一个时钟<strong>上升沿</strong>信号，主机和从机分别把自己<strong>高位</strong>的值左移出来(<strong>一般高位先行</strong>)</li><li>来一个时钟<strong>下降沿</strong>信号，主机和从机分别<strong>读入</strong>数据，存储到移位寄存器的低位</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/2.png" alt="img"></p><h2 id="交换bit"><a href="#交换bit" class="headerlink" title="交换bit"></a>交换bit</h2><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/3.png" alt="img"></p><p><strong>在SCK上升沿的时候，移出MOSI的数据，在SCK下降沿的时候读取MISO的数据。</strong></p><p><strong>需要在SCK上升沿之前把需要发送的数据位放置在MOSI线上</strong></p><p><strong>SCK下降沿的时候马上读取MISO线上的数据位</strong></p><p><strong>（实际上下降沿和读取应该是同时的，但是我们软件模拟没法同时，但是效果是一样的）</strong></p><h2 id="1-6-不同模式下的通信"><a href="#1-6-不同模式下的通信" class="headerlink" title="1.6 不同模式下的通信"></a>1.6 不同模式下的通信</h2><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/9.png" alt="image-20250305141745720"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/10.png" alt="image-20250305141814533"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/8.png" alt="image-20250305141718015"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/7.png" alt="image-20250305141639698"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/11.png" alt="image-20250305141859718"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/12.png" alt="image-20250305142011451"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/13.png" alt="image-20250305142031698"></p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="时钟的极性和相位"><a href="#时钟的极性和相位" class="headerlink" title="时钟的极性和相位"></a>时钟的极性和相位</h2><h3 id="1-时钟的极性-CPOL"><a href="#1-时钟的极性-CPOL" class="headerlink" title="1.时钟的极性(CPOL)"></a>1.时钟的极性(CPOL)</h3><p>什么时候读数据(数据采集)和设置的<strong>时钟和相位</strong>有关</p><p>通信的整个过程分为空闲时刻和通信时刻</p><ul><li>空闲状态SCLK是低电平，CPOL&#x3D;0</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511103646951.png" alt="image-20250511103646951"></p><ul><li>空闲状态SCLK是高电平，CPOL&#x3D;1</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511103726353.png" alt="image-20250511103726353"></p><h3 id="2-时钟的相位-CPHA"><a href="#2-时钟的相位-CPHA" class="headerlink" title="2.时钟的相位(CPHA)"></a>2.时钟的相位(CPHA)</h3><p>直接决定SPI总线从那个跳变沿开始采样数据</p><ul><li>CPHA&#x3D;0：表示从第一个跳变沿开始采样</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104059236.png" alt="image-20250511104059236"></p><ul><li>CPHA&#x3D;1：表示从第二个跳变沿开始采样</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104044786.png" alt="image-20250511104044786"></p><h3 id="3-SPI的4种模式"><a href="#3-SPI的4种模式" class="headerlink" title="3.SPI的4种模式"></a>3.SPI的4种模式</h3><p>时钟的两种极性和2种相位的不同组合，得到了SPI的4种工作模式</p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104312629.png" alt="image-20250511104312629"></p><h4 id="3-1-模式0和模式2"><a href="#3-1-模式0和模式2" class="headerlink" title="3.1 模式0和模式2"></a>3.1 模式0和模式2</h4><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104947143.png" alt="image-20250511104947143"></p><h4 id="3-2-模式1和模式3"><a href="#3-2-模式1和模式3" class="headerlink" title="3.2 模式1和模式3"></a>3.2 模式1和模式3</h4><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104902672.png" alt="image-20250511104902672"></p><h1 id="三、硬件SPI"><a href="#三、硬件SPI" class="headerlink" title="三、硬件SPI"></a>三、硬件SPI</h1><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250512125536962.png" alt="image-20250512125536962"></p><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><h3 id="3-1-1-SPI-HandleTypeDef"><a href="#3-1-1-SPI-HandleTypeDef" class="headerlink" title="3.1.1 SPI_HandleTypeDef"></a>3.1.1 SPI_HandleTypeDef</h3><h4 id="SPI-InitTypeDef"><a href="#SPI-InitTypeDef" class="headerlink" title="SPI_InitTypeDef"></a>SPI_InitTypeDef</h4><ul><li><p><strong>Mode</strong>：指定 SPI 工作模式</p><ul><li><code>SPI_MODE_SLAVE</code>：从模式</li><li><code>SPI_MODE_MASTER</code>：主模式</li></ul></li><li><p><strong>Direction</strong>：指定 SPI 双向模式状态</p><ul><li><code>SPI_DIRECTION_2LINES</code>：同时支持数据的发送和接收</li><li><code>SPI_DIRECTION_2LINES_RXONLY</code>：SPI只接收数据</li><li><code>SPI_DIRECTION_1LINE</code>：SPI只使用一条数据线进行双向数据传输</li></ul></li><li><p><strong>DataSize</strong>：指定 SPI 数据大小</p><ul><li><code>SPI_DATASIZE_8BIT</code>：8位</li><li><code>SPI_DATASIZE_16BIT</code>：16位</li></ul></li><li><p><strong>CLKPolarity</strong>：指定时钟极性（空闲状态时时钟的电平）</p><ul><li><code>SPI_POLARITY_LOW</code>：空闲时低电平</li><li><code>SPI_POLARITY_HIGH</code>：空闲时高电平</li></ul></li><li><p><strong>CLKPhase</strong>：指定时钟相位（数据采样的边沿）</p><ul><li><code>SPI_PHASE_1EDGE</code>：第一个时钟边沿采样</li><li><code>SPI_PHASE_2EDGE</code>：第二个时钟边沿采样</li></ul></li><li><p><strong>NSS</strong>：指定片选信号(NSS)的管理方式</p><ul><li><code>SPI_NSS_SOFT</code>：软件管理模式</li><li><code>SPI_NSS_HARD_INPUT</code>：硬件输入模式</li><li><code>SPI_NSS_HARD_OUTPUT</code>：硬件输出模式</li></ul></li><li><p><strong>BaudRatePrescaler</strong>：指定波特率预分频值</p><ul><li><code>SPI_BAUDRATEPRESCALER_2</code>：</li><li><code>SPI_BAUDRATEPRESCALER_4</code>：</li><li><code>SPI_BAUDRATEPRESCALER_8</code>：</li><li><code>SPI_BAUDRATEPRESCALER_16</code>：</li><li><code>SPI_BAUDRATEPRESCALER_32</code>：</li><li><code>SPI_BAUDRATEPRESCALER_64</code>：</li><li><code>SPI_BAUDRATEPRESCALER_128</code>：</li><li><code>SPI_BAUDRATEPRESCALER_256</code>：</li></ul></li><li><p><strong>FirstBit</strong>：指定数据传输时的字节顺序</p><ul><li><code>SPI_FIRSTBIT_MSB</code>：最先发送高位</li><li><code>SPI_FIRSTBIT_LSB</code>：最先发送低位</li></ul></li><li><p><strong>TIMode</strong>：用于控制SPI的三态模式(是否能进入高阻态)</p><ul><li><code>SPI_TIMODE_DISABLE</code>：禁用三态模式</li><li><code>SPI_TIMODE_ENABLE</code>：启用三态模式</li></ul></li><li><p><strong>CRCCalculation</strong>：控制是否启用CRC</p><ul><li><code>SPI_CRCCALCULATION_DISABLE</code>：禁用CRC计算</li><li><code>SPI_CRCCALCULATION_ENABLE</code>：启用CRC计算</li></ul></li><li><p><strong>CRCPolynomial</strong>：an odd number between Min_Data &#x3D; 1 and Max_Data &#x3D; 65535</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出"><a href="#1-硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出" class="headerlink" title="1. 硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出?"></a>1. 硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出?</h2><p>​当一个<a href="https://so.csdn.net/so/search?q=GPIO&spm=1001.2101.3001.7020">GPIO</a>端口配置为GPIO_Mode_AF_PP时，片上外设的复用功能输出信号会连接到输出控制电路，然后在端口上产生输出信号。但是在芯片内部，MISO是SPI模块的输入引脚，而不是输出引脚，也就是说“复用功能输出信号”根本不存在，所以”输出控制电路”就不能对外部产生输出信号，然而即使在复用推挽输出模式下，复用功能输入信号却与外部引脚之间相互连接，既MISO得到了外部信号的电平，实现了输入的功能。</p>]]></content>
      
      
      <categories>
          
          <category> SPI </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通讯协议 </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/"/>
      <url>/2025/05/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/%E6%99%BA%E8%83%BD%E9%97%A8%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="一、器件"><a href="#一、器件" class="headerlink" title="一、器件"></a>一、器件</h1><h1 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TF卡</title>
      <link href="/2025/04/30/TF%E5%8D%A1/"/>
      <url>/2025/04/30/TF%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>参考资料</strong>：</p><p><a href="https://www.bilibili.com/video/BV1XW4y1W7Dp/?spm_id_from=333.337.search-card.all.click&vd_source=daf1db3c953df56f74e76077dfa61ab4">1.【单片机】STM32驱动SD卡详解，SD卡硬件接口协议讲解_哔哩哔哩_bilibili</a></p><h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1><p><img src="/2025/04/30/TF%E5%8D%A1/image-20250501123038696.png" alt="image-20250501123038696"></p><p>其中DATA3可以作为SD卡检测线CD，即在SD卡插入时产生一个信号让主机知道SD卡插入了</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p><img src="/2025/04/30/TF%E5%8D%A1/image-20250501120939389.png" alt="image-20250501120939389"></p>]]></content>
      
      
      <categories>
          
          <category> 外设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USART通信</title>
      <link href="/2025/04/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/USART/"/>
      <url>/2025/04/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/USART/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Usart-Init"><a href="#一、Usart-Init" class="headerlink" title="一、Usart_Init"></a>一、Usart_Init</h1><h2 id="1-1-UART-HandleTypeDef"><a href="#1-1-UART-HandleTypeDef" class="headerlink" title="1.1 UART_HandleTypeDef"></a>1.1 UART_HandleTypeDef</h2><ul><li><strong>Instance</strong>： UART 外设的寄存器基地址</li><li><strong>Init</strong>：UART 配置参数</li><li><strong>pTxBuffPtr</strong>：指向 UART 发送缓冲区的指针</li><li><strong>TxXferSize</strong>：UART 发送缓冲区的大小</li><li><strong>TxXferCount</strong>：UART 发送传输计数器</li><li><strong>pRxBuffPtr</strong>：指向 UART 接收缓冲区的指针</li><li><strong>RxXferSize</strong>：UART 接收缓冲区的大小</li><li><strong>RxXferCount</strong>：UART 接收传输计数器</li><li><strong>ReceptionType</strong>：正在进行的接收类型</li><li><strong>RxEventType</strong>：接收事件类型</li><li><strong>hdmatx</strong>：UART 发送 DMA 句柄</li><li><strong>hdmarx</strong>：UART 接收 DMA 句柄</li><li><strong>Lock</strong>：锁对象，用于管理 UART 的并发访问</li><li><strong>gState</strong>：UART 全局句柄的当前状态</li><li><strong>RxState</strong>：与接收操作相关的 UART 状态信息</li><li><strong>ErrorCode</strong>：UART 错误代码</li></ul><h2 id="1-2-UART-InitTypeDef"><a href="#1-2-UART-InitTypeDef" class="headerlink" title="1.2 UART_InitTypeDef"></a>1.2 UART_InitTypeDef</h2><ul><li><strong>Init.BaudRate</strong>：UART 通信的波特率</li></ul><p>​<code>9600</code></p><p>​<code>115200</code></p><p>​<code>921600</code></p><ul><li><p><strong>Init.WordLength</strong>：指定数据帧中传输或接收的数据位数</p><p>  <code>UART_WORDLENGTH_8B</code> </p><p>  <code>UART_WORDLENGTH_9B</code></p></li><li><p><strong>Init.StopBits</strong>：指定传输的停止位数量</p></li></ul><p>​<code>UART_STOPBITS_1</code></p><p>​<code>UART_STOPBITS_2</code></p><ul><li><strong>Init.Parity</strong>：指定校验模式</li></ul><p>​<code>UART_PARITY_NONE</code>:无校验</p><p>​<code>UART_PARITY_EVEN</code>:偶校验</p><p>​<code>UART_PARITY_ODD</code>:奇校验</p><ul><li><strong>Init.Mode</strong>：是否启用接收或发送模式</li></ul><p>​<code>UART_MODE_RX</code></p><p>​<code>UART_MODE_TX</code></p><p>​<code>UART_MODE_TX_RX</code></p><ul><li><strong>Init.HwFlowCtl</strong>：是否启用硬件流控制模式</li></ul><p>​<code>UART_STATE_DISABLE</code></p><p>​<code>UART_STATE_ENABLE</code></p><ul><li><strong>Init.OverSampling</strong>：启用几倍过采样</li></ul><p>​<code>UART_OVERSAMPLING_16</code>:8次采样来获取</p><p>​<code>UART_OVERSAMPLING_8</code>:8次采样来获取</p><h2 id="1-3-HAL-UART-Init-UART-HandleTypeDef-huart"><a href="#1-3-HAL-UART-Init-UART-HandleTypeDef-huart" class="headerlink" title="1.3 HAL_UART_Init(UART_HandleTypeDef *huart)"></a>1.3 HAL_UART_Init(UART_HandleTypeDef *huart)</h2><p>将1.1和1.2中的配置进行初始化，此函数会调用AL_UART_MspInit(UART_HandleTypeDef* uartHandle)</p><p>进行串口的硬件初始化</p><h1 id="二、HAL-UART-MspInit"><a href="#二、HAL-UART-MspInit" class="headerlink" title="二、HAL_UART_MspInit"></a>二、HAL_UART_MspInit</h1><h2 id="2-1-GPIO-InitTypeDef"><a href="#2-1-GPIO-InitTypeDef" class="headerlink" title="2.1 GPIO_InitTypeDef"></a>2.1 GPIO_InitTypeDef</h2><ul><li><strong>Pin</strong>：指定要配置的 GPIO 引脚</li></ul><p>​<code>GPIO_PIN_x</code></p><ul><li><strong>Mode</strong>:指定引脚的工作模式</li></ul><p>​<code>GPIO_MODE_INPUT</code>：输入模式</p><p>​<code>GPIO_MODE_OUTPUT_PP</code>：推挽输出模式</p><p>​<code>GPIO_MODE_OUTPUT_OD</code>：开漏输出模式</p><p>​<code>GPIO_MODE_AF_PP</code>：复用功能推挽输出模式</p><p>​<code>GPIO_MODE_AF_OD</code>：复用功能开漏输出模式</p><p>​<code>GPIO_MODE_ANALOG</code>：模拟模式</p><p>​<code>GPIO_MODE_IT_RISING</code>：外部中断模式，触发上升沿</p><p>​<code>GPIO_MODE_IT_FALLING</code>：外部中断模式，触发下降沿</p><p>​<code>GPIO_MODE_IT_RISING_FALLING</code>：外部中断模式，触发上升沿或下降沿</p><p>​<code>GPIO_MODE_EVT_RISING</code>：外部事件模式，触发上升沿</p><p>​<code>GPIO_MODE_EVT_FALLING</code>：外部事件模式，触发下降沿</p><p>​<code>GPIO_MODE_EVT_RISING_FALLING</code>：外部事件模式，触发上升沿或下降沿</p><ul><li><strong>Pull</strong>:指定引脚的上拉或下拉电阻</li></ul><p>​<code>GPIO_NOPULL</code>：无上下拉</p><p>​<code>GPIO_PULLUP</code>：上拉</p><p>​<code>GPIO_PULLDOWN</code>：下拉</p><ul><li><strong>Speed</strong>:指定引脚的输出速度</li></ul><p>​<code>GPIO_SPEED_FREQ_LOW</code>:低速</p><p>​<code>GPIO_SPEED_FREQ_MEDIUM</code>:中速</p><p>​<code>GPIO_SPEED_FREQ_HIGH</code>:高速</p><ul><li><strong>Alternate</strong>:引脚的复用功能</li></ul><h2 id="2-2-HAL-GPIO-Init-GPIO-TypeDef-GPIOx-GPIO-InitTypeDef-GPIO-Init"><a href="#2-2-HAL-GPIO-Init-GPIO-TypeDef-GPIOx-GPIO-InitTypeDef-GPIO-Init" class="headerlink" title="2.2 HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)"></a>2.2 HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)</h2><p>将2.1的结构体传入HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)进行初始化</p><h2 id="2-3-DMA-HandleTypeDef"><a href="#2-3-DMA-HandleTypeDef" class="headerlink" title="2.3 DMA_HandleTypeDef"></a>2.3 DMA_HandleTypeDef</h2><ul><li><strong>Instance</strong>：指向DMA 流寄存器基地址</li><li><strong>Init</strong>：DMA 通信参数的结构体</li><li><strong>Lock</strong>：DMA 锁对象</li><li><strong>State</strong>：DMA 传输的当前状态</li><li><strong>Parent</strong>：指向与 DMA 操作相关联的父对象</li><li><strong>XferCpltCallback</strong>：传输完成时调用的回调</li><li><strong>XferHalfCpltCallback</strong>：半传输完成时调用的回调</li><li><strong>XferM1CpltCallback</strong>：内存 1 的传输完成时调用的回调</li><li><strong>XferM1HalfCpltCallback</strong>：内存 1 的半传输完成时调用的回调</li><li><strong>XferErrorCallback</strong>：DMA 传输出错时调用的回调</li><li><strong>XferAbortCallback</strong>：DMA 传输被中止时调用的回调</li><li><strong>ErrorCode</strong>：DMA 传输过程中出现错误代码</li><li><strong>StreamBaseAddress</strong>：DMA 流的基地址</li><li><strong>StreamIndex</strong>：DMA 流的索引</li></ul><h2 id="2-4-DMA-InitTypeDef"><a href="#2-4-DMA-InitTypeDef" class="headerlink" title="2.4 DMA_InitTypeDef"></a>2.4 DMA_InitTypeDef</h2><ul><li><strong>Channel</strong>：指定 DMA 流使用的通道</li></ul><p>​<code>DMA_CHANNEL_x</code></p><ul><li><strong>Direction</strong>：指定数据传输的方向</li></ul><p>​<code>DMA_MEMORY_TO_MEMORY</code>:内存到内存</p><p>​<code>DMA_MEMORY_TO_PERIPH</code>:内存到外设</p><p>​<code>DMA_PERIPH_TO_MEMORY</code>:外设到内存</p><ul><li><strong>PeriphInc</strong>：外设地址寄存器是否需要递增</li></ul><p>​<code>DMA_PINC_ENABLE</code>:启用</p><p>​<code>DMA_PINC_DISABLE</code>:禁用</p><ul><li><p><strong>MemInc</strong>：内存地址寄存器是否需要递增</p><p>  <code>DMA_MINC_ENABLE</code>::启用</p><p>  <code>DMA_MINC_DISABLE</code>:禁用</p></li><li><p><strong>PeriphDataAlignment</strong>：外设数据宽度</p></li></ul><p>​<code>DMA_PDATAALIGN_BYTE</code>:字节对齐 (1 字节)</p><p>​<code>DMA_PDATAALIGN_HALFWORD</code>: 半字对齐 (2字节)</p><p>​<code>DMA_PDATAALIGN_WORD</code>:字对齐 (4字节)</p><ul><li><strong>MemDataAlignment</strong>：内存数据宽度</li></ul><p>​<code>DMA_MDATAALIGN_BYTE</code>:字节对齐 (1 字节)</p><p>​<code>DMA_MDATAALIGN_HALFWORD</code>:半字对齐 (2字节)</p><p>​<code>DMA_MDATAALIGN_WORD</code>:字对齐 (4字节)</p><ul><li><strong>Mode</strong>：DMA 流的操作模式</li></ul><p>​<code>DMA_NORMAL</code>:正常模式(DMA 执行一次数据传输后会停止)</p><p>​<code>DMA_CIRCULAR</code>:循环模式(DMA 会在数据传输完成后自动重新启动)</p><p>​<code>DMA_PFCTRL</code>:优先控制模式(外设优先级控制)</p><ul><li><strong>Priority</strong>：DMA 流的优先级</li></ul><p>​<code>DMA_PRIORITY_LOW</code>:低优先级</p><p>​<code>DMA_PRIORITY_MEDIUM</code>:中优先级</p><p>​<code>DMA_PRIORITY_HIGH</code>:高优先级</p><p>​<code>DMA_PRIORITY_VERY_HIGH</code>:非常高优先级</p><ul><li><strong>FIFOMode</strong>：是否使用 FIFO 模式或者直接模式</li></ul><p>​<code>DMA_FIFOMODE_DISABLE</code>:直接模式(数据会直接从内存传输到外设，或者反向操作)</p><p>​<code>DMA_FIFOMODE_ENABLE</code>:DMA 流会使用 FIFO 队列来缓存数据，直到数据达到一定数量时才会传输</p><ul><li><strong>FIFOThreshold</strong>：FIFO 阈值等级</li></ul><p>​<code>DMA_FIFO_THRESHOLD_1QUARTERFULL</code>:四分之一满DMA 会开始数据传输</p><p>​<code>DMA_FIFO_THRESHOLD_HALFFULL</code>:一半满DMA 会开始数据传输</p><p>​<code>DMA_FIFO_THRESHOLD_3QUARTERSFULL</code>:三分之一满DMA 会开始数据传输</p><p>​<code>DMA_FIFO_THRESHOLD_FULL</code>:完全满DMA 会开始数据传输</p><ul><li><strong>MemBurst</strong>：内存传输的突发模式配置</li></ul><p>​<code>DMA_MBURST_SINGLE</code>:单次传输模式</p><p>​<code>DMA_MBURST_INC4</code>:递增 4 字节传输模式</p><p>​<code>DMA_MBURST_INC8</code>:递增 8 字节传输模式</p><p>​<code>DMA_MBURST_INC16</code>:递增 16 字节传输模式</p><ul><li><strong>PeriphBurst</strong>：外设传输的突发模式配置</li></ul><p>​<code>DMA_PBURST_SINGLE</code>:单次传输模式</p><p>​<code>DMA_PBURST_INC4</code>:递增 4 字节传输模式</p><p>​<code>DMA_PBURST_INC8</code>:递增 8 字节传输模式</p><p>​<code>DMA_PBURST_INC16</code>:递增 16 字节传输模式</p><h2 id="2-5-HAL-StatusTypeDef-HAL-DMA-Init-DMA-HandleTypeDef-hdma"><a href="#2-5-HAL-StatusTypeDef-HAL-DMA-Init-DMA-HandleTypeDef-hdma" class="headerlink" title="2.5 HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)"></a>2.5 HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)</h2><p>调用此函数初始化2.3结构体的配置</p><h1 id="三、-HAL-LINKDMA"><a href="#三、-HAL-LINKDMA" class="headerlink" title="三、__HAL_LINKDMA"></a>三、__HAL_LINKDMA</h1><p>____HAL_LINKDMA(<strong>HANDLE</strong>, <strong>PERIPH</strong>, <strong>DMA_HANDLE</strong>)</p><p>将一个 DMA 句柄（<code>DMA_HandleTypeDef</code>）与外设（如 UART、SPI、I2C 等）的相关操作关联起来</p><ul><li><p><strong>HANDLE</strong>:外设句柄</p></li><li><p><strong>PERIPH</strong>:外设的 DMA 相关字段</p></li><li><p><strong>DMA_HANDLE__</strong>:实际的 DMA 句柄</p></li></ul><h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><h2 id="4-1-HAL-NVIC-SetPriority"><a href="#4-1-HAL-NVIC-SetPriority" class="headerlink" title="4.1 HAL_NVIC_SetPriority"></a>4.1 HAL_NVIC_SetPriority</h2><p>HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)</p><p><strong>设置中断的优先级</strong></p><ul><li><strong>IRQn</strong>：中断请求号</li><li><strong>PreemptPriority</strong>：抢占优先级(值越小，优先级越高)</li><li><strong>SubPriority</strong>：响应优先级(值越小，优先级越高)</li></ul><h2 id="4-2-HAL-NVIC-EnableIRQ"><a href="#4-2-HAL-NVIC-EnableIRQ" class="headerlink" title="4.2 HAL_NVIC_EnableIRQ"></a>4.2 HAL_NVIC_EnableIRQ</h2><p>HAL_NVIC_EnableIRQ(IRQn_Type IRQn)</p><p><strong>启用指定中断</strong></p><ul><li><strong>IRQn</strong>:中断请求号</li></ul><h1 id="五、中断响应"><a href="#五、中断响应" class="headerlink" title="五、中断响应"></a>五、中断响应</h1><p><img src="/2025/04/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/USART/image-20250503175203247.png" alt="image-20250503175203247"></p><h2 id="5-1-DMA2-Stream2-IRQHandler"><a href="#5-1-DMA2-Stream2-IRQHandler" class="headerlink" title="5.1 DMA2_Stream2_IRQHandler()"></a>5.1 DMA2_Stream2_IRQHandler()</h2><p>当 DMA2 的 Stream 2 发生中断时，调用 <code>HAL_DMA_IRQHandler</code> 来处理相关的中断事件</p><h2 id="5-2-HAL-DMA-IRQHandler"><a href="#5-2-HAL-DMA-IRQHandler" class="headerlink" title="5.2 HAL_DMA_IRQHandler"></a>5.2 HAL_DMA_IRQHandler</h2><p>用于处理 DMA 相关的中断事件</p><ul><li><strong>传输完成中断</strong>:当 DMA 完成数据的传输时</li></ul><p><code>HAL_DMA_TxCpltCallback()</code>:DMA 发送完成时触发的回调</p><p><code>HAL_DMA_RxCpltCallback()</code>:DMA 接收完成时触发的回调</p><ul><li><strong>半传输完成中断</strong>:当 DMA 在传输数据时到达数据缓冲区的一半时</li></ul><p><code>HAL_DMA_HalfTxCpltCallback()</code>:DMA 发送半传输完成时触发的回调</p><p><code>HAL_DMA_HalfRxCpltCallback()</code>:DMA 接收半传输完成时触发的回调</p><ul><li><strong>传输错误中断</strong>:当 DMA 在传输过程中发生错误时</li></ul><p><code>HAL_DMA_ErrorCallback()</code>:当发生 DMA 错误时触发的回调</p><ul><li><strong>直接存储器访问总线错误</strong>:当 DMA 控制器遇到总线错误时</li><li><strong>DMA Stream&#x2F;Channel 中的中断源</strong>:</li></ul><h1 id="5-3-HAL-UART-IRQHandler"><a href="#5-3-HAL-UART-IRQHandler" class="headerlink" title="5.3 HAL_UART_IRQHandler"></a>5.3 HAL_UART_IRQHandler</h1><ul><li><strong>数据接收完成中断</strong>:</li></ul><p><code>HAL_UART_RxCpltCallback</code>:当 UART 数据接收完成时</p><p><code>HAL_UART_RxHalfCpltCallback()</code>:当 UART 半接收完成时</p><ul><li><strong>数据发送完成中断</strong>:</li></ul><p><code>HAL_UART_TxCpltCallback()</code>:当 UART 数据发送完成时</p><p><code>HAL_UART_TxHalfCpltCallback()</code>:当 UART 半发送完成时</p><ul><li><strong>错误中断</strong>:</li></ul><p><code>HAL_UART_ErrorCallback()</code>:当 UART 发生错误时</p><ul><li><strong>其他中断（如行结束中断等）</strong>:</li></ul><p><code>HAL_UART_AbortCpltCallback()</code>:当 UART 中的传输被取消时</p><h1 id="三、发送重定向"><a href="#三、发送重定向" class="headerlink" title="三、发送重定向"></a>三、发送重定向</h1><h2 id="1-my-usart-h"><a href="#1-my-usart-h" class="headerlink" title="1.my_usart.h"></a>1.my_usart.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> U1_TxBuff_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_usart1</span><span class="params">(<span class="type">char</span> *format,...)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-my-usart-c"><a href="#2-my-usart-c" class="headerlink" title="2.my_usart.c"></a>2.my_usart.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_usart1</span><span class="params">(<span class="type">char</span> *format,...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list listdata;</span><br><span class="line">    va_start(listdata,format);</span><br><span class="line">    <span class="built_in">vsprintf</span>((<span class="type">char</span> *)U1_TxBuff,format,listdata);</span><br><span class="line">    va_end(listdata);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(<span class="type">const</span> <span class="type">uint8_t</span> *)U1_TxBuff,<span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span>*)U1_TxBuff),<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-HAL-UART-GET-FLAG-huart1-UART-FLAG-TXE"><a href="#1-HAL-UART-GET-FLAG-huart1-UART-FLAG-TXE" class="headerlink" title="1. __HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_TXE)"></a>1. __HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_TXE)</h2><p><strong>检查 USART状态寄存器中特定标志位的宏</strong></p><table><thead><tr><th align="center">宏定义</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">UART_FLAG_CTS</td><td align="center">清除发送</td></tr><tr><td align="center">UART_FLAG_LBD</td><td align="center">线路中断</td></tr><tr><td align="center">UART_FLAG_TXE</td><td align="center">传输数据寄存器空</td></tr><tr><td align="center">UART_FLAG_TC</td><td align="center">传输完成</td></tr><tr><td align="center">UART_FLAG_RXNE</td><td align="center">接收数据寄存器非空</td></tr><tr><td align="center">UART_FLAG_IDLE</td><td align="center">空闲线</td></tr><tr><td align="center">UART_FLAG_ORE</td><td align="center">接收溢出错误</td></tr><tr><td align="center">UART_FLAG_NE</td><td align="center">接收噪声错误</td></tr><tr><td align="center">UART_FLAG_FE</td><td align="center">接收帧错误</td></tr><tr><td align="center">UART_FLAG_PE</td><td align="center">接收奇偶校验错误</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通讯协议 </tag>
            
            <tag> USART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boorloader</title>
      <link href="/2025/04/22/BootLoader/"/>
      <url>/2025/04/22/BootLoader/</url>
      
        <content type="html"><![CDATA[<p><strong>参考资料</strong>：</p><p><a href="https://www.bilibili.com/video/BV1SatHeBEVG?spm_id_from=333.788.videopod.episodes&vd_source=daf1db3c953df56f74e76077dfa61ab4&p=2">超子说物联网：手把手教程 4G通信物联网 OTA远程升级 BootLoader程序设计</a></p><h1 id="一、Bootloader的作用"><a href="#一、Bootloader的作用" class="headerlink" title="一、Bootloader的作用"></a>一、Bootloader的作用</h1><h2 id="1-1-Boot的目的："><a href="#1-1-Boot的目的：" class="headerlink" title="1.1 Boot的目的："></a>1.1 Boot的目的：</h2><p>最终目的：跳到C语言中；为了C语言运行程序会进行一系列的初始化，系统一上电后如何通过一系列的设置让软件程序员进入C语言&#x2F;更高级语言环境的开发，这个过程就是boot的主要目的。</p><h2 id="1-2-Loader的目的："><a href="#1-2-Loader的目的：" class="headerlink" title="1.2 Loader的目的："></a>1.2 Loader的目的：</h2><p>主要目的是开始执行应用逻辑，比如点灯：需要灯的接口开发；串口输入输出：需要串口编程；加载linux的内核：flash的编程、网卡的编程、内核启动前的初始化部分。根据不同的应用会有不同的变化。</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1>]]></content>
      
      
      <categories>
          
          <category> 外设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL物理按键代替触摸</title>
      <link href="/2025/04/08/LVGL/LVGL-%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE%E4%BB%A3%E6%9B%BF%E8%A7%A6%E6%91%B8/"/>
      <url>/2025/04/08/LVGL/LVGL-%E7%89%A9%E7%90%86%E6%8C%89%E9%94%AE%E4%BB%A3%E6%9B%BF%E8%A7%A6%E6%91%B8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL页面图层</title>
      <link href="/2025/04/06/LVGL/LVGL-%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/04/06/LVGL/LVGL-%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、菜单页面，背景色不动"><a href="#一、菜单页面，背景色不动" class="headerlink" title="一、菜单页面，背景色不动"></a>一、菜单页面，背景色不动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ui_MenuPage_bottom = lv_obj_create(<span class="literal">NULL</span>);</span><br><span class="line">lv_obj_set_width(ui_MenuPage_bottom, <span class="number">240</span>);</span><br><span class="line">lv_obj_set_height(ui_MenuPage_bottom,<span class="number">280</span>);</span><br><span class="line"></span><br><span class="line">bg_image = lv_img_create(ui_MenuPage_bottom);</span><br><span class="line">lv_img_set_src(bg_image,&amp;bg_2);</span><br><span class="line">lv_obj_set_style_bg_opa(bg_image, LV_OPA_70, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">ui_MenuPage_top = lv_obj_create(ui_MenuPage_bottom);</span><br><span class="line">lv_obj_set_align(ui_MenuPage_top, LV_ALIGN_TOP_MID);  </span><br><span class="line">lv_obj_add_flag(ui_MenuPage_top, LV_OBJ_FLAG_SCROLLABLE);  <span class="comment">// 设置为可滚动的对象</span></span><br><span class="line">lv_obj_set_scroll_dir(ui_MenuPage_top, LV_DIR_VER);</span><br><span class="line">lv_obj_set_style_bg_opa(ui_MenuPage_top, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">lv_obj_set_width(ui_MenuPage_top, <span class="number">240</span>);</span><br><span class="line">lv_obj_set_height(ui_MenuPage_top, <span class="number">280</span>);</span><br></pre></td></tr></table></figure><img src="/2025/04/06/LVGL/LVGL-%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/1.gif" width="240" height="280"><h1 id="二、右滑切换界面"><a href="#二、右滑切换界面" class="headerlink" title="二、右滑切换界面"></a>二、右滑切换界面</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ui_event_AboutPage</span><span class="params">(<span class="type">lv_event_t</span> * e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_event_code_t</span> event_code = lv_event_get_code(e);</span><br><span class="line">    <span class="type">lv_obj_t</span> * target = lv_event_get_target(e);<span class="comment">//获取触发该事件的目标对象（即哪个控件触发了事件）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(event_code == LV_EVENT_GESTURE)  <span class="comment">//检测手势</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lv_indev_get_gesture_dir(lv_indev_get_act()) == LV_DIR_RIGHT)<span class="comment">//右滑</span></span><br><span class="line">        &#123;</span><br><span class="line">    user_Stack_Pop(&amp;ScrRenewStack); <span class="comment">//出栈</span></span><br><span class="line">            ui_MenuPage_screen_init();      <span class="comment">//初始化目标页面       </span></span><br><span class="line">            lv_scr_load_anim(ui_MenuPage_bottom,LV_SCR_LOAD_ANIM_MOVE_RIGHT,<span class="number">100</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">            user_Stack_Push(&amp;ScrRenewStack,(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;ui_MenuPage_bottom);<span class="comment">//将目标页面压栈</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL移植</title>
      <link href="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/"/>
      <url>/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="一、LVGL文件裁剪"><a href="#一、LVGL文件裁剪" class="headerlink" title="一、LVGL文件裁剪"></a>一、LVGL文件裁剪</h1><h2 id="1-删除根目录下选中的文件"><a href="#1-删除根目录下选中的文件" class="headerlink" title="1. 删除根目录下选中的文件"></a>1. <strong>删除根目录下选中的文件</strong></h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/9.png" alt="1"></p><p><strong>删除后</strong></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/10.png" alt="2"></p><h2 id="2-裁剪examples文件夹"><a href="#2-裁剪examples文件夹" class="headerlink" title="2. 裁剪examples文件夹"></a>2. 裁剪examples文件夹</h2><ul><li>删除<code>porting</code>中输入输出相关的接口文件，其它全部删除</li></ul><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/11.png" alt="QQ_1742610639413"></p><h2 id="3-修改lvgl配置文件文件名"><a href="#3-修改lvgl配置文件文件名" class="headerlink" title="3. 修改lvgl配置文件文件名"></a>3. 修改lvgl配置文件文件名</h2><p>将根目录下的<code>lv_conf_template.h</code>文件名修改为<code>lv_conf.h</code></p><h2 id="4-最终文件"><a href="#4-最终文件" class="headerlink" title="4. 最终文件"></a>4. 最终文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/12.png" alt="image-20250322104307792"></p><ul><li><code>demos</code>文件夹中保存的是官方历程，可以删除</li></ul><h2 id="5-修改lv-conf-h"><a href="#5-修改lv-conf-h" class="headerlink" title="5. 修改lv_conf.h"></a>5. 修改lv_conf.h</h2><ul><li>将<code>#if 0</code>修改为<code>#if 1</code></li></ul><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/14.png" alt="image-20250322110212708"></p><h1 id="二、工程目录"><a href="#二、工程目录" class="headerlink" title="二、工程目录"></a>二、工程目录</h1><h2 id="1-移植裁剪后的lvgl"><a href="#1-移植裁剪后的lvgl" class="headerlink" title="1. 移植裁剪后的lvgl"></a>1. 移植裁剪后的lvgl</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/13.png" alt="image-20250322110141115"></p><p><strong>不按次结构，有些头文件的引用可能会报错</strong></p><h2 id="2-添加文件进工程"><a href="#2-添加文件进工程" class="headerlink" title="2.添加文件进工程"></a>2.添加文件进工程</h2><h3 id="1-添加分组"><a href="#1-添加分组" class="headerlink" title="(1) 添加分组"></a>(1) 添加分组</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/15.png" alt="image-20250322114144151"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Middlewares/lvgl/example/porting</span><br><span class="line">Middlewares/lvgl/src/core</span><br><span class="line">Middlewares/lvgl/src/core    </span><br><span class="line">Middlewares/lvgl/src/extra</span><br><span class="line">Middlewares/lvgl/src/font</span><br><span class="line">Middlewares/lvgl/src/gpu</span><br><span class="line">Middlewares/lvgl/src/hal</span><br><span class="line">Middlewares/lvgl/src/widgets</span><br></pre></td></tr></table></figure><h3 id="2-为什么要这样分组"><a href="#2-为什么要这样分组" class="headerlink" title="(2) 为什么要这样分组"></a>(2) 为什么要这样分组</h3><p>因为这样分组和LVGL的结构是相同的</p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/16.png" alt="image-20250322114311900"></p><h3 id="3-为分组添加文件"><a href="#3-为分组添加文件" class="headerlink" title="(3) 为分组添加文件"></a>(3) 为分组添加文件</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/17.png" alt="image-20250322111729503"></p><h3 id="4-添加头文件路径"><a href="#4-添加头文件路径" class="headerlink" title="(4) 添加头文件路径"></a>(4) 添加头文件路径</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/19.png" alt="QQ_1742618216223"></p><h3 id="5-开启C99模式"><a href="#5-开启C99模式" class="headerlink" title="(5) 开启C99模式"></a>(5) 开启C99模式</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/18.png" alt="QQ_1742615627487"></p><h1 id="三、配置输出"><a href="#三、配置输出" class="headerlink" title="三、配置输出"></a>三、配置输出</h1><h2 id="1-修改头文件"><a href="#1-修改头文件" class="headerlink" title="1. 修改头文件"></a>1. 修改头文件</h2><p><code>lvgl\examples\porting</code>路径下的<code>lv_port_disp_template.c/h</code>是官方提供的显示接口函数</p><p>使用前需要将<code>#if 0</code> 改为<code>#if 1</code></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/20.png" alt="image-20250322125754825"></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/21.png" alt="image-20250322125858697"></p><h2 id="2-包含输出设备驱动头文件"><a href="#2-包含输出设备驱动头文件" class="headerlink" title="2. 包含输出设备驱动头文件"></a>2. 包含输出设备驱动头文件</h2><h2 id="3-在disp-init-中调用LCD初始化代码"><a href="#3-在disp-init-中调用LCD初始化代码" class="headerlink" title="3. 在disp_init()中调用LCD初始化代码"></a>3. 在disp_init()中调用LCD初始化代码</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/2.png" alt="image-20250322131803479"></p><h2 id="4-配置图形数据缓冲模式"><a href="#4-配置图形数据缓冲模式" class="headerlink" title="4. 配置图形数据缓冲模式"></a>4. 配置图形数据缓冲模式</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/23.png" alt="image-20250322132844255"></p><h2 id="5-设置屏幕尺寸"><a href="#5-设置屏幕尺寸" class="headerlink" title="5. 设置屏幕尺寸"></a>5. 设置屏幕尺寸</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/24.png" alt="image-20250322133003409"></p><h2 id="6-在disp-flush中使用自己的打点函数"><a href="#6-在disp-flush中使用自己的打点函数" class="headerlink" title="6. 在disp_flush中使用自己的打点函数"></a>6. 在disp_flush中使用自己的打点函数</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/1.png" alt="image-20250318133644412"></p><h1 id="四、配置输入"><a href="#四、配置输入" class="headerlink" title="四、配置输入"></a>四、配置输入</h1><h2 id="1-修改输入设备接口文件"><a href="#1-修改输入设备接口文件" class="headerlink" title="1. 修改输入设备接口文件"></a>1. 修改输入设备接口文件</h2><p><code>lvgl\examples\porting</code>路径下的<code>lv_port_indev_template.c/h</code>是官方提供的显示接口函数</p><p>使用前需要将<code>#if 0</code> 改为<code>#if 1</code></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/38.png" alt="image-20250323144615574"></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/39.png" alt="image-20250323144639488"></p><h2 id="2-按需裁剪输入设备"><a href="#2-按需裁剪输入设备" class="headerlink" title="2. 按需裁剪输入设备"></a>2. 按需裁剪输入设备</h2><p><strong>删除<code>lv_port_indev_template.c/h</code>中未使用的部分，只保留使用到的部分</strong></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/4.png" alt="image-20250323145225160"></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/40.png" alt="image-20250323145323205"></p><h2 id="3-在接口文件中包含触摸头文件"><a href="#3-在接口文件中包含触摸头文件" class="headerlink" title="3. 在接口文件中包含触摸头文件"></a>3. 在接口文件中包含触摸头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/41.png" alt="QQ_1742714448348"></p><h2 id="4-在touchpad-init-中调用触摸初始化代码"><a href="#4-在touchpad-init-中调用触摸初始化代码" class="headerlink" title="4. 在touchpad_init()中调用触摸初始化代码"></a>4. 在touchpad_init()中调用触摸初始化代码</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/3.png" alt="image-20250323151034944"></p><h2 id="5-触摸检测函数配置"><a href="#5-触摸检测函数配置" class="headerlink" title="5. 触摸检测函数配置"></a>5. 触摸检测函数配置</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/5.png" alt="image-20250318135936403"></p><h2 id="6-配置坐标获取函数"><a href="#6-配置坐标获取函数" class="headerlink" title="6. 配置坐标获取函数"></a>6. 配置坐标获取函数</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/6.png" alt="image-20250318140033233"></p><h1 id="五、为LVGL提供时基"><a href="#五、为LVGL提供时基" class="headerlink" title="五、为LVGL提供时基"></a>五、为LVGL提供时基</h1><h2 id="1-stm32f4xx-it-c文件中添加头文件"><a href="#1-stm32f4xx-it-c文件中添加头文件" class="headerlink" title="1. stm32f4xx_it.c文件中添加头文件"></a>1. <code>stm32f4xx_it.c</code>文件中添加头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/25.png" alt="image-20250322142414771"></p><h2 id="2-调用lv-tick-inc-函数"><a href="#2-调用lv-tick-inc-函数" class="headerlink" title="2. 调用lv_tick_inc()函数"></a>2. 调用<code>lv_tick_inc()</code>函数</h2><p><code>x参数</code>为进入函数的时间，<strong>例如1ms发生一次中断，则x改为1</strong></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/26.png" alt="QQ_1742624811806"></p><h1 id="六、main-函数部分移植"><a href="#六、main-函数部分移植" class="headerlink" title="六、main()函数部分移植"></a>六、main()函数部分移植</h1><h2 id="1-包含头文件"><a href="#1-包含头文件" class="headerlink" title="1. 包含头文件"></a>1. 包含头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/28.png" alt="QQ_1742625782915"></p><h2 id="2-初始化LVGL库、输入输出设备"><a href="#2-初始化LVGL库、输入输出设备" class="headerlink" title="2. 初始化LVGL库、输入输出设备"></a>2. 初始化LVGL库、输入输出设备</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/27.png" alt="image-20250322144233357"></p><h2 id="3-每5ms调用一次lv-timer-hander"><a href="#3-每5ms调用一次lv-timer-hander" class="headerlink" title="3. 每5ms调用一次lv_timer_hander()"></a>3. 每5ms调用一次<code>lv_timer_hander()</code></h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/35.png" alt="image-20250322165012000"></p><h2 id="4-调用测试代码"><a href="#4-调用测试代码" class="headerlink" title="4. 调用测试代码"></a>4. 调用测试代码</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/37.png" alt="image-20250322165048497"></p><h1 id="七、测试官方历程"><a href="#七、测试官方历程" class="headerlink" title="七、测试官方历程"></a>七、测试官方历程</h1><h2 id="1-将demos文件夹放入GUI-APP中"><a href="#1-将demos文件夹放入GUI-APP中" class="headerlink" title="1. 将demos文件夹放入GUI_APP中"></a>1. 将<code>demos</code>文件夹放入<code>GUI_AP</code>P中</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/34.png" alt="image-20250322164939645"></p><h2 id="2-添加头文件路径"><a href="#2-添加头文件路径" class="headerlink" title="2. 添加头文件路径"></a>2. 添加头文件路径</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/29.png" alt="QQ_1742632798292"></p><h2 id="3-将lv-conf-h文件，更改宏定义"><a href="#3-将lv-conf-h文件，更改宏定义" class="headerlink" title="3. 将lv_conf_h文件，更改宏定义"></a>3. 将lv_conf_h文件，更改宏定义</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/31.png" alt="image-20250322164639124"></p><h2 id="4-新建工程组"><a href="#4-新建工程组" class="headerlink" title="4. 新建工程组"></a>4. 新建工程组</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/30.png" alt="QQ_1742632928236"></p><h2 id="5-在main中添加头文件"><a href="#5-在main中添加头文件" class="headerlink" title="5. 在main中添加头文件"></a>5. 在main中添加头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/32.png" alt="image-20250322164705613"></p><h2 id="6-调用测试函数"><a href="#6-调用测试函数" class="headerlink" title="6. 调用测试函数"></a>6. 调用测试函数</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/33.png" alt="image-20250322164737470"></p><h2 id="7-现象"><a href="#7-现象" class="headerlink" title="7. 现象"></a>7. 现象</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/36.JPG" alt="IMG_5519"></p>]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT</title>
      <link href="/2025/03/21/GIT/"/>
      <url>/2025/03/21/GIT/</url>
      
        <content type="html"><![CDATA[<p><a href="https://download.100ask.net/tools/Software/git/how_to_use_git.html">🛠Git简明教程 — 百问网资料下载中心 3.0 文档</a></p><h1 id="GIT下载代码"><a href="#GIT下载代码" class="headerlink" title="GIT下载代码"></a>GIT下载代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/No-Chicken/FryPi.git</span></span><br></pre></td></tr></table></figure><h1 id="一、下载GIT"><a href="#一、下载GIT" class="headerlink" title="一、下载GIT"></a>一、下载GIT</h1><h2 id="1-设置用户名和邮箱"><a href="#1-设置用户名和邮箱" class="headerlink" title="1. 设置用户名和邮箱"></a>1. 设置用户名和邮箱</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>用户名和邮箱地址的作用 ？</p><p>用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。</p><p>每次<a href="https://so.csdn.net/so/search?q=commit&spm=1001.2101.3001.7020">commit</a>都会用用户名和邮箱纪录。</p><p><a href="https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020">github</a>的contributions统计就是按邮箱来统计的。</p><h2 id="2-查看个人信息"><a href="#2-查看个人信息" class="headerlink" title="2. 查看个人信息"></a>2. 查看个人信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><h2 id="3-生成公钥和私钥"><a href="#3-生成公钥和私钥" class="headerlink" title="3. 生成公钥和私钥"></a>3. 生成公钥和私钥</h2><p><img src="/2025/03/21/GIT/1.png" alt="QQ_1742805478515"></p><h1 id="二、Sourcetree本地仓库设置"><a href="#二、Sourcetree本地仓库设置" class="headerlink" title="二、Sourcetree本地仓库设置"></a>二、Sourcetree本地仓库设置</h1><p><img src="/2025/03/21/GIT/2.png" alt="QQ_1742896224882"></p><h2 id="2-1-初始化仓库-第一次需要"><a href="#2-1-初始化仓库-第一次需要" class="headerlink" title="2.1 初始化仓库(第一次需要)"></a>2.1 初始化仓库(第一次需要)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init #把当前目录变成git可以管理的仓库</span><br></pre></td></tr></table></figure><p><img src="/2025/03/21/GIT/4.png" alt="image-20250325183008060"></p><h2 id="2-2-添加文件到暂存区-每次都要"><a href="#2-2-添加文件到暂存区-每次都要" class="headerlink" title="2.2 添加文件到暂存区(每次都要)"></a>2.2 添加文件到暂存区(每次都要)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt #添加一个文件，也可以添加文件夹</span><br><span class="line">git add . #添加全部文件</span><br></pre></td></tr></table></figure><h2 id="2-3-提交到本地仓库-每次都要"><a href="#2-3-提交到本地仓库-每次都要" class="headerlink" title="2.3 提交到本地仓库(每次都要)"></a>2.3 提交到本地仓库(每次都要)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;提交说明&quot;</span>    #提交修改</span><br></pre></td></tr></table></figure><h2 id="2-4-创建远程仓库-第一次需要"><a href="#2-4-创建远程仓库-第一次需要" class="headerlink" title="2.4 创建远程仓库(第一次需要)"></a>2.4 创建远程仓库(第一次需要)</h2><p><img src="/2025/03/21/GIT/3.png" alt="QQ_1742896961943"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git@gitee.com:yaodaowen/sss.git</span><br></pre></td></tr></table></figure><h2 id="2-5-绑定远程仓库-第一次需要"><a href="#2-5-绑定远程仓库-第一次需要" class="headerlink" title="2.5 绑定远程仓库(第一次需要)"></a>2.5 绑定远程仓库(第一次需要)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:yaodaowen/sss.git(地址)</span><br><span class="line">#远程仓库的提交（第一次链接）</span><br></pre></td></tr></table></figure><h2 id="2-6-推送代码到远程仓库-每次都要"><a href="#2-6-推送代码到远程仓库-每次都要" class="headerlink" title="2.6 推送代码到远程仓库(每次都要)"></a>2.6 推送代码到远程仓库(每次都要)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin <span class="string">&quot;master&quot;</span>#第一次</span><br><span class="line">git push#第一次之后</span><br></pre></td></tr></table></figure><p><img src="/2025/03/21/GIT/6.png" alt="image-20250325185422461"></p><h2 id="2-7-推送失败解决方案"><a href="#2-7-推送失败解决方案" class="headerlink" title="2.7 推送失败解决方案"></a>2.7 推送失败解决方案</h2><p><img src="/2025/03/21/GIT/5.png" alt="image-20250325184408593"></p><p>远程仓库的 <code>master</code> 分支上有一些你本地没有的更新，需要先拉取远程仓库的更新</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h1 id="三、其它"><a href="#三、其它" class="headerlink" title="三、其它"></a>三、其它</h1><h2 id="3-1-查看GIT个人信息"><a href="#3-1-查看GIT个人信息" class="headerlink" title="3.1 查看GIT个人信息"></a>3.1 查看GIT个人信息</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><h2 id="3-2-查看仓库状态"><a href="#3-2-查看仓库状态" class="headerlink" title="3.2 查看仓库状态"></a>3.2 查看仓库状态</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status </span><br></pre></td></tr></table></figure><h2 id="3-3-查看仓库日记"><a href="#3-3-查看仓库日记" class="headerlink" title="3.3 查看仓库日记"></a>3.3 查看仓库日记</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> </span><br></pre></td></tr></table></figure><h2 id="3-4-查看当前配置有哪些远程仓库"><a href="#3-4-查看当前配置有哪些远程仓库" class="headerlink" title="3.4 查看当前配置有哪些远程仓库"></a>3.4 查看当前配置有哪些远程仓库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git init #把当前目录变成git可以管理的仓库</span><br><span class="line">git clone git地址 #克隆项目</span><br><span class="line">git add readme.txt #添加一个文件，也可以添加文件夹</span><br><span class="line">git add -A #添加全部文件</span><br><span class="line">git rm test.txt #删除一个文件，也可以删除文件夹</span><br><span class="line">git commit –m ‘提交说明’      #提交修改</span><br><span class="line">git status #查看是否还有未提交</span><br><span class="line">git <span class="built_in">log</span> #查看最近日志</span><br><span class="line">git reset --hard HEAD^ #版本回退一个版本</span><br><span class="line">git reset --hard HEAD^^ #版本回退两个版本</span><br><span class="line">git reset --hard HEAD~<span class="number">100</span> #版本回退多个版本</span><br><span class="line">git remote add origin +地址 #远程仓库的提交（第一次链接）</span><br><span class="line">git push -u origin master#仓库关联</span><br><span class="line">git push #远程仓库的提交（第二次及之后）</span><br><span class="line">git fetch #从远程获取代码库</span><br><span class="line">git tag xxx #打tag</span><br><span class="line">git tag #显示所有tag</span><br><span class="line">git push --tag #提交tag</span><br><span class="line">git branch -a #显示所有分支</span><br><span class="line">git checkout 分支名 #切换分支</span><br><span class="line">git merge git分支 #合并分支</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-12-LCD</title>
      <link href="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/"/>
      <url>/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SPI"><a href="#一、SPI" class="headerlink" title="一、SPI"></a>一、SPI</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p><strong>SPI</strong>英文全称Serial Peripheral Interface，即串行外围设备接口，是一种高速、<strong>全双工</strong>、<strong>同步</strong>的<strong>串行</strong>通信总线。</p><h2 id="1-2-信号线"><a href="#1-2-信号线" class="headerlink" title="1.2 信号线"></a>1.2 信号线</h2><ul><li><strong>SCK</strong>（Serial Clock）：串行<strong>时钟线</strong>，由主设备产生，用于同步数据传输。</li><li><strong>MOSI</strong>（Master Output Slave Input）：<strong>主机输出</strong>从机输入线，主设备通过这条线发送数据给从设备。</li><li><strong>MISO</strong>（Master Input Slave Output）：<strong>主机输入</strong>从机输出线，主设备通过这条线接收从设备发送的数据。</li><li><strong>SS</strong>（Slave Select）：<strong>从机选择线</strong>（每个从机一根选择线），用于选择与主设备进行通信的从设备。通常情况下，SS线为低电平有效，即当SS线为低电平时，选中对应的从设备进行通信。</li></ul><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/5.png" alt="image-20250305140335105"></p><h2 id="1-3-开始与结束"><a href="#1-3-开始与结束" class="headerlink" title="1.3 开始与结束"></a>1.3 开始与结束</h2><p>当SS从高电平拉低到<strong>低电平</strong>，这个算是<strong>起始</strong>的一个时序。而SS从低电平拉高到<strong>高电平</strong>，就算是结束的时序。</p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/1.png" alt="img"></p><h2 id="1-4-发送和接收字节"><a href="#1-4-发送和接收字节" class="headerlink" title="1.4 发送和接收字节"></a>1.4 发送和接收字节</h2><p>发送接收字节看似是两个时序，但是在SPI中却是<strong>同一个时序</strong>，因为SPI的机制是&#x3D;&#x3D;我们发送一个字节，并且接收一个字节&#x3D;&#x3D;（<strong>哪怕我们并不需要接收数据</strong>）。反过来看也可以是我们接收一个字节，并且发送一个字节（<strong>哪怕这个字节是无用的数据</strong>）。</p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/6.png" alt="image-20250305140438435"></p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/2.png" alt="img"></p><h2 id="交换bit"><a href="#交换bit" class="headerlink" title="交换bit"></a>交换bit</h2><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/3.png" alt="img"></p><p><strong>在SCK上升沿的时候，移出MOSI的数据，在SCK下降沿的时候读取MISO的数据。</strong></p><p><strong>需要在SCK上升沿之前把需要发送的数据位放置在MOSI线上</strong></p><p><strong>SCK下降沿的时候马上读取MISO线上的数据位</strong></p><p><strong>（实际上下降沿和读取应该是同时的，但是我们软件模拟没法同时，但是效果是一样的）</strong></p><h2 id="1-6-不同模式下的通信"><a href="#1-6-不同模式下的通信" class="headerlink" title="1.6 不同模式下的通信"></a>1.6 不同模式下的通信</h2><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/9.png" alt="image-20250305141745720"></p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/10.png" alt="image-20250305141814533"></p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/8.png" alt="image-20250305141718015"></p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/7.png" alt="image-20250305141639698"></p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/11.png" alt="image-20250305141859718"></p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/12.png" alt="image-20250305142011451"></p><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/13.png" alt="image-20250305142031698"></p><h1 id="二、TFT-LCD"><a href="#二、TFT-LCD" class="headerlink" title="二、TFT-LCD"></a>二、TFT-LCD</h1><p><img src="/2025/03/12/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/12.OV-Watch_LCD/image-20250305142759302.png" alt="image-20250305142759302"></p><table><thead><tr><th>引脚</th><th>功能</th></tr></thead><tbody><tr><td>GND</td><td>接地</td></tr><tr><td>VCC</td><td>供电（3.3V-5V）</td></tr><tr><td>TP_INT</td><td>接3v3上拉，</td></tr><tr><td>TP_SDA</td><td>TP触摸芯片数据引脚</td></tr><tr><td>TP_SCL</td><td>TP触摸芯片时钟引脚</td></tr><tr><td>LCD_RST</td><td>低电平TFT复位</td></tr><tr><td>LCD_MOSI</td><td>数据输入引脚</td></tr><tr><td>LCD_CLK</td><td>LCD时钟引脚</td></tr><tr><td>LCD_CS</td><td>片选信号，低电平使能</td></tr><tr><td>LCD_DC</td><td>区分接受的是数据还是命令（低电平命令，高电平数据）</td></tr><tr><td>LCD_BLK</td><td>背光（可常接3.3V）</td></tr></tbody></table><h2 id="HAL-SPI-Transmit"><a href="#HAL-SPI-Transmit" class="headerlink" title="HAL_SPI_Transmit()"></a>HAL_SPI_Transmit()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_SPI_Transmit</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span><br></pre></td></tr></table></figure><p>**<code>SPI_HandleTypeDef \*hspi</code>**：</p><ul><li>指向 <strong>SPI 句柄</strong> 的指针。这个句柄包含了关于 SPI 外设的配置信息，必须在使用之前通过 <code>HAL_SPI_Init()</code> 初始化。</li></ul><p>**<code>uint8_t \*pData</code>**：</p><ul><li>指向要发送的数据的指针。<code>pData</code> 是一个数据缓冲区，包含要通过 SPI 发送的数据。数据以字节的形式存储。</li></ul><p>**<code>uint16_t Size</code>**：</p><ul><li>发送数据的大小，以字节为单位。<code>Size</code> 表示要发送的字节数。</li></ul><p>**<code>uint32_t Timeout</code>**：</p><ul><li>传输操作的超时时间，以毫秒为单位。如果在指定的时间内传输未完成，函数将返回超时错误。</li></ul><h2 id="LCD-GPIO-Init"><a href="#LCD-GPIO-Init" class="headerlink" title="LCD_GPIO_Init()"></a>LCD_GPIO_Init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDef  GPIO_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line"> __HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOD_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = BLK_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOA</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOA, BLK_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = RES_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOB</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOB, RES_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = DC_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOC</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOC, DC_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = CS_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOD, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOD</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOD, CS_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个字节数据-LCD-Writ-Bus"><a href="#写一个字节数据-LCD-Writ-Bus" class="headerlink" title="写一个字节数据 LCD_Writ_Bus()"></a>写一个字节数据 LCD_Writ_Bus()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Writ_Bus</span><span class="params">(u8 dat)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//hard SPI</span></span><br><span class="line">HAL_SPI_Transmit(&amp;hspi1,&amp;dat,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//soft SPI</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">u8 i;</span></span><br><span class="line"><span class="comment">for(i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">&#123;  </span></span><br><span class="line"><span class="comment">LCD_SCLK_Clr();</span></span><br><span class="line"><span class="comment">if(dat&amp;0x80)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">   LCD_MOSI_Set();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">   LCD_MOSI_Clr();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">LCD_SCLK_Set();</span></span><br><span class="line"><span class="comment">dat&lt;&lt;=1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写两个字节数据-LCD-WR-DATA"><a href="#写两个字节数据-LCD-WR-DATA" class="headerlink" title="写两个字节数据 LCD_WR_DATA()"></a>写两个字节数据 LCD_WR_DATA()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA</span><span class="params">(u16 dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//LCD_Writ_Bus(dat&gt;&gt;8);</span></span><br><span class="line"><span class="comment">//LCD_Writ_Bus(dat);</span></span><br><span class="line"><span class="type">uint8_t</span> temp[<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">0</span>]=(dat&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">temp[<span class="number">1</span>]=dat&amp;<span class="number">0xff</span>;</span><br><span class="line">HAL_SPI_Transmit(&amp;hspi1,temp,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写命令-LCD-WR-REG"><a href="#写命令-LCD-WR-REG" class="headerlink" title="写命令 LCD_WR_REG()"></a>写命令 LCD_WR_REG()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_REG</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_DC_Clr();<span class="comment">//写命令</span></span><br><span class="line">LCD_Writ_Bus(dat);</span><br><span class="line">LCD_DC_Set();<span class="comment">//写数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置起始和初始地址-LCD-Address-Set"><a href="#设置起始和初始地址-LCD-Address-Set" class="headerlink" title="设置起始和初始地址 LCD_Address_Set()"></a>设置起始和初始地址 LCD_Address_Set()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Address_Set</span><span class="params">(u16 x1,u16 y1,u16 x2,u16 y2)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WR_REG(<span class="number">0x2a</span>);<span class="comment">//列地址设置</span></span><br><span class="line">LCD_WR_DATA(x1);</span><br><span class="line">LCD_WR_DATA(x2);</span><br><span class="line">LCD_WR_REG(<span class="number">0x2b</span>);<span class="comment">//行地址设置</span></span><br><span class="line">LCD_WR_DATA(y1);</span><br><span class="line">LCD_WR_DATA(y2);</span><br><span class="line">LCD_WR_REG(<span class="number">0x2c</span>);<span class="comment">//储存器写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置显示区域</strong>：该函数通过设置列地址和行地址，定义了一个矩形区域 <code>(x1, y1)</code> 到 <code>(x2, y2)</code>，然后准备向该区域写入图像数据或颜色。</p><p><strong>显示区域绘制</strong>：在调用 <code>LCD_Address_Set()</code> 后，LCD 屏幕的指定区域就被设置好了，之后可以通过其他函数（例如 <code>LCD_WriteColor()</code> 或类似的函数）向该区域写入具体的颜色或图像数据，从而实现绘制操作。</p><h1 id="LCD常用函数"><a href="#LCD常用函数" class="headerlink" title="LCD常用函数"></a>LCD常用函数</h1><h2 id="1-LCD-Fill-区域颜色填充"><a href="#1-LCD-Fill-区域颜色填充" class="headerlink" title="1.LCD_Fill()区域颜色填充"></a>1.LCD_Fill()区域颜色填充</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Fill</span><span class="params">(u16 xsta,u16 ysta,u16 xend,u16 yend,u16 color)</span></span><br><span class="line">&#123;          </span><br><span class="line">u16 i,j; </span><br><span class="line">LCD_Address_Set(xsta+OFFSET_X,ysta+OFFSET_Y,xend+OFFSET_X<span class="number">-1</span>,yend<span class="number">-1</span>+OFFSET_Y);<span class="comment">//设置显示范围</span></span><br><span class="line"><span class="keyword">for</span>(i=ysta;i&lt;yend;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=xsta;j&lt;xend;j++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WR_DATA(color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-指定位置画点LCD-DrawPoint"><a href="#2-指定位置画点LCD-DrawPoint" class="headerlink" title="2.指定位置画点LCD_DrawPoint()"></a>2.指定位置画点LCD_DrawPoint()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawPoint</span><span class="params">(u16 x,u16 y,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Address_Set(x,y,x,y);<span class="comment">//设置光标位置 </span></span><br><span class="line">LCD_WR_DATA(color);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="3-画线LCD-DrawLine"><a href="#3-画线LCD-DrawLine" class="headerlink" title="3.画线LCD_DrawLine()"></a>3.画线LCD_DrawLine()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawLine</span><span class="params">(u16 x1,u16 y1,u16 x2,u16 y2,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line">u16 t; </span><br><span class="line"><span class="type">int</span> xerr=<span class="number">0</span>,yerr=<span class="number">0</span>,delta_x,delta_y,distance;</span><br><span class="line"><span class="type">int</span> incx,incy,uRow,uCol;</span><br><span class="line">delta_x=x2-x1; <span class="comment">//计算坐标增量 </span></span><br><span class="line">delta_y=y2-y1;</span><br><span class="line">uRow=x1;<span class="comment">//画线起点坐标</span></span><br><span class="line">uCol=y1;</span><br><span class="line"><span class="keyword">if</span>(delta_x&gt;<span class="number">0</span>)incx=<span class="number">1</span>; <span class="comment">//设置单步方向 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_x==<span class="number">0</span>)incx=<span class="number">0</span>;<span class="comment">//垂直线 </span></span><br><span class="line"><span class="keyword">else</span> &#123;incx=<span class="number">-1</span>;delta_x=-delta_x;&#125;</span><br><span class="line"><span class="keyword">if</span>(delta_y&gt;<span class="number">0</span>)incy=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_y==<span class="number">0</span>)incy=<span class="number">0</span>;<span class="comment">//水平线 </span></span><br><span class="line"><span class="keyword">else</span> &#123;incy=<span class="number">-1</span>;delta_y=-delta_y;&#125;</span><br><span class="line"><span class="keyword">if</span>(delta_x&gt;delta_y)distance=delta_x; <span class="comment">//选取基本增量坐标轴 </span></span><br><span class="line"><span class="keyword">else</span> distance=delta_y;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;distance+<span class="number">1</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_DrawPoint(uRow,uCol,color);<span class="comment">//画点</span></span><br><span class="line">xerr+=delta_x;</span><br><span class="line">yerr+=delta_y;</span><br><span class="line"><span class="keyword">if</span>(xerr&gt;distance)</span><br><span class="line">&#123;</span><br><span class="line">xerr-=distance;</span><br><span class="line">uRow+=incx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(yerr&gt;distance)</span><br><span class="line">&#123;</span><br><span class="line">yerr-=distance;</span><br><span class="line">uCol+=incy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-画矩形LCD-DrawRectangle"><a href="#4-画矩形LCD-DrawRectangle" class="headerlink" title="4.画矩形LCD_DrawRectangle()"></a>4.画矩形LCD_DrawRectangle()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawRectangle</span><span class="params">(u16 x1, u16 y1, u16 x2, u16 y2,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_DrawLine(x1,y1,x2,y1,color);</span><br><span class="line">LCD_DrawLine(x1,y1,x1,y2,color);</span><br><span class="line">LCD_DrawLine(x1,y2,x2,y2,color);</span><br><span class="line">LCD_DrawLine(x2,y1,x2,y2,color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-画圆Draw-Circle"><a href="#5-画圆Draw-Circle" class="headerlink" title="5.画圆Draw_Circle()"></a>5.画圆Draw_Circle()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Draw_Circle</span><span class="params">(u16 x0,u16 y0,u8 r,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a=<span class="number">0</span>;b=r;  </span><br><span class="line"><span class="keyword">while</span>(a&lt;=b)</span><br><span class="line">&#123;</span><br><span class="line">LCD_DrawPoint(x0-b,y0-a,color);             <span class="comment">//3           </span></span><br><span class="line">LCD_DrawPoint(x0+b,y0-a,color);             <span class="comment">//0           </span></span><br><span class="line">LCD_DrawPoint(x0-a,y0+b,color);             <span class="comment">//1                </span></span><br><span class="line">LCD_DrawPoint(x0-a,y0-b,color);             <span class="comment">//2             </span></span><br><span class="line">LCD_DrawPoint(x0+b,y0+a,color);             <span class="comment">//4               </span></span><br><span class="line">LCD_DrawPoint(x0+a,y0-b,color);             <span class="comment">//5</span></span><br><span class="line">LCD_DrawPoint(x0+a,y0+b,color);             <span class="comment">//6 </span></span><br><span class="line">LCD_DrawPoint(x0-b,y0+a,color);             <span class="comment">//7</span></span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">if</span>((a*a+b*b)&gt;(r*r))<span class="comment">//判断要画的点是否过远</span></span><br><span class="line">&#123;</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-写汉字LCD-ShowChinese"><a href="#6-写汉字LCD-ShowChinese" class="headerlink" title="6.写汉字LCD_ShowChinese()"></a>6.写汉字LCD_ShowChinese()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChinese</span><span class="params">(u16 x,u16 y,u8 *s,u16 fc,u16 bc,u8 sizey,u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*s!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sizey==<span class="number">12</span>) LCD_ShowChinese12x12(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">16</span>) LCD_ShowChinese16x16(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">24</span>) LCD_ShowChinese24x24(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">32</span>) LCD_ShowChinese32x32(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">s+=<span class="number">2</span>;</span><br><span class="line">x+=sizey;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   入口数据：x,y显示坐标</p><p>​        *s 要显示的汉字串</p><p>​        fc 字的颜色</p><p>​        bc 字的背景色</p><p>​        sizey 字号 可选 16 24 32</p><p>​        mode:  0非叠加模式  1叠加模式</p><h2 id="7-显示单个字符LCD-ShowChar"><a href="#7-显示单个字符LCD-ShowChar" class="headerlink" title="7.显示单个字符LCD_ShowChar()"></a>7.显示单个字符LCD_ShowChar()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(u16 x,u16 y,u8 num,u16 fc,u16 bc,u8 sizey,u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 temp,sizex,t,m=<span class="number">0</span>;</span><br><span class="line">u16 i,TypefaceNum;<span class="comment">//一个字符所占字节大小</span></span><br><span class="line">u16 x0=x;</span><br><span class="line">sizex=sizey/<span class="number">2</span>;</span><br><span class="line">TypefaceNum=(sizex/<span class="number">8</span>+((sizex%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*sizey;</span><br><span class="line">num=num-<span class="string">&#x27; &#x27;</span>;    <span class="comment">//得到偏移后的值</span></span><br><span class="line">LCD_Address_Set(x,y,x+sizex<span class="number">-1</span>,y+sizey<span class="number">-1</span>);  <span class="comment">//设置光标位置 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TypefaceNum;i++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(sizey==<span class="number">12</span>)temp=ascii_1206[num][i];       <span class="comment">//调用6x12字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">16</span>)temp=ascii_1608[num][i]; <span class="comment">//调用8x16字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">24</span>)temp=ascii_2412[num][i]; <span class="comment">//调用12x24字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">32</span>)temp=ascii_3216[num][i]; <span class="comment">//调用16x32字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!mode)<span class="comment">//非叠加模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;(<span class="number">0x01</span>&lt;&lt;t))LCD_WR_DATA(fc);</span><br><span class="line"><span class="keyword">else</span> LCD_WR_DATA(bc);</span><br><span class="line">m++;</span><br><span class="line"><span class="keyword">if</span>(m%sizex==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//叠加模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;(<span class="number">0x01</span>&lt;&lt;t))LCD_DrawPoint(x,y,fc);<span class="comment">//画一个点</span></span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span>((x-x0)==sizex)</span><br><span class="line">&#123;</span><br><span class="line">x=x0;</span><br><span class="line">y++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-显示字符串LCD-ShowString"><a href="#8-显示字符串LCD-ShowString" class="headerlink" title="8.显示字符串LCD_ShowString()"></a>8.显示字符串LCD_ShowString()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(u16 x,u16 y,<span class="type">const</span> u8 *p,u16 fc,u16 bc,u8 sizey,u8 mode)</span></span><br><span class="line">&#123;         </span><br><span class="line"><span class="keyword">while</span>(*p!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;       </span><br><span class="line">LCD_ShowChar(x,y,*p,fc,bc,sizey,mode);</span><br><span class="line">x+=sizey/<span class="number">2</span>;</span><br><span class="line">p++;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-显示数字mypow"><a href="#9-显示数字mypow" class="headerlink" title="9.显示数字mypow()"></a>9.显示数字mypow()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u32 <span class="title function_">mypow</span><span class="params">(u8 m,u8 n)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 result=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span>(n--)result*=m;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-显示整数变量LCD-ShowIntNum"><a href="#10-显示整数变量LCD-ShowIntNum" class="headerlink" title="10.显示整数变量LCD_ShowIntNum()"></a>10.显示整数变量LCD_ShowIntNum()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowIntNum</span><span class="params">(u16 x,u16 y,u16 num,u8 len,u16 fc,u16 bc,u8 sizey)</span></span><br><span class="line">&#123;         </span><br><span class="line">u8 t,temp;</span><br><span class="line">u8 enshow=<span class="number">0</span>;</span><br><span class="line">u8 sizex=sizey/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num/mypow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowChar(x+t*sizex,y,<span class="string">&#x27; &#x27;</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> enshow=<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"> LCD_ShowChar(x+t*sizex,y,temp+<span class="number">48</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="11-显示两位小数变量LCD-ShowFloatNum1"><a href="#11-显示两位小数变量LCD-ShowFloatNum1" class="headerlink" title="11.显示两位小数变量LCD_ShowFloatNum1()"></a>11.显示两位小数变量LCD_ShowFloatNum1()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowFloatNum1</span><span class="params">(u16 x,u16 y,<span class="type">float</span> num,u8 len,u16 fc,u16 bc,u8 sizey)</span></span><br><span class="line">&#123;         </span><br><span class="line">u8 t,temp,sizex;</span><br><span class="line">u16 num1;</span><br><span class="line">sizex=sizey/<span class="number">2</span>;</span><br><span class="line">num1=num*<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num1/mypow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(t==(len<span class="number">-2</span>))</span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowChar(x+(len<span class="number">-2</span>)*sizex,y,<span class="string">&#x27;.&#x27;</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line">t++;</span><br><span class="line">len+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> LCD_ShowChar(x+t*sizex,y,temp+<span class="number">48</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-显示图片LCD-ShowPicture"><a href="#12-显示图片LCD-ShowPicture" class="headerlink" title="12.显示图片LCD_ShowPicture()"></a>12.显示图片LCD_ShowPicture()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowPicture</span><span class="params">(u16 x,u16 y,u16 length,u16 width,<span class="type">const</span> u8 pic[])</span></span><br><span class="line">&#123;</span><br><span class="line">u16 i,j;</span><br><span class="line">u32 k=<span class="number">0</span>;</span><br><span class="line">LCD_Address_Set(x,y,x+length<span class="number">-1</span>,y+width<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;width;j++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WR_DATA8(pic[k*<span class="number">2</span>]);</span><br><span class="line">LCD_WR_DATA8(pic[k*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-11-CST816</title>
      <link href="/2025/03/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/11.OV-Watch_CST816/"/>
      <url>/2025/03/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/11.OV-Watch_CST816/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/m0_60313295/article/details/144648171?ops_request_misc=&request_id=&biz_id=102&utm_term=CST816&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-144648171.142%5Ev101%5Epc_search_result_base5&spm=1018.2226.3001.4187">【模块系列】STM32&amp;1.69TFT屏幕_cst816t-CSDN博客</a></p><p><img src="/2025/03/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/11.OV-Watch_CST816/1.png" alt="image-20250302143612984"></p><p><img src="/2025/03/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/11.OV-Watch_CST816/1.png" alt="image-20250302143612984"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-10-SPL06</title>
      <link href="/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/"/>
      <url>/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/hdhfkfnbru/article/details/134553635?ops_request_misc=%7B%22request_id%22:%226840e66b8131dce8d44a0e2b5d8926ca%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=6840e66b8131dce8d44a0e2b5d8926ca&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-134553635-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=spl06-001&spm=1018.2226.3001.4187">【传感器】SPL06-001（歌尔声学）-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40598185/article/details/119347845?ops_request_misc=%7B%22request_id%22:%22b1b74e98a2848eda046f0182781c7856%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=b1b74e98a2848eda046f0182781c7856&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119347845-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=spl06&spm=1018.2226.3001.4187">SPL06电容式压力传感器数据读取与处理(基于STM32)-CSDN博客</a></p><p><img src="/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/1.png" alt="image-20250302142603950"></p><p><img src="/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/2.png" alt="image-20250302142619225"></p><p><img src="/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/3.png" alt="image-20250302142709827"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-9-POWER</title>
      <link href="/2025/03/09/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/9.OV-Watch_POWER/"/>
      <url>/2025/03/09/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/9.OV-Watch_POWER/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/weixin_45829708/article/details/124892787">【电源芯片】TPS63020升降压芯片-电池放电-CSDN博客</a></p><p><img src="/2025/03/09/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/9.OV-Watch_POWER/1.png" alt="//"></p><table><thead><tr><th align="center">NAME</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">EN</td><td align="center">启用输入(1启用0输出)</td></tr><tr><td align="center">POWER_EN</td><td align="center">PA3</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="二、TP4056"><a href="#二、TP4056" class="headerlink" title="二、TP4056"></a>二、TP4056</h1><p><img src="/2025/03/09/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/9.OV-Watch_POWER/image-20250415202041915.png" alt="image-20250415202041915"></p><h2 id="2-1-引脚定义"><a href="#2-1-引脚定义" class="headerlink" title="2.1 引脚定义"></a>2.1 引脚定义</h2><table><thead><tr><th align="center">NAME</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">TEMP</td><td align="center">电池温度检测输入</td></tr><tr><td align="center">PROG</td><td align="center">可编程恒流充电电流设置端</td></tr><tr><td align="center">GND</td><td align="center">地端</td></tr><tr><td align="center">VCC</td><td align="center">电源端</td></tr><tr><td align="center">BAT</td><td align="center">电池端</td></tr><tr><td align="center">STDBY</td><td align="center">电池充电完成指示端</td></tr><tr><td align="center">CHARG</td><td align="center">电池充电指示端</td></tr><tr><td align="center">CE</td><td align="center">芯片使能输入端</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-8-OWDG</title>
      <link href="/2025/03/08/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/8.OV-Watch_OWDG/"/>
      <url>/2025/03/08/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/8.OV-Watch_OWDG/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/zhuoqingjoking97298/article/details/121437976?ops_request_misc=%7B%22request_id%22:%229a230254f870292e2dfc70e4cb11001b%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=9a230254f870292e2dfc70e4cb11001b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-121437976-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=BL1551B&spm=1018.2226.3001.4187">BL1551模拟开关，封装SC70-6_bl1551中文资料-CSDN博客</a></p><p><a href="https://blog.csdn.net/gutie_bartholomew/article/details/88878248?ops_request_misc=%7B%22request_id%22:%22d68738496a6e2d51c751a092b86908fa%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=d68738496a6e2d51c751a092b86908fa&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88878248-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=TPS3823&spm=1018.2226.3001.4187">看门狗定时器实测-CSDN博客</a></p><p><img src="/2025/03/08/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/8.OV-Watch_OWDG/1.png" alt="image-20250302141027190"></p><h2 id="1-1-BL1551B"><a href="#1-1-BL1551B" class="headerlink" title="1.1 BL1551B"></a>1.1 BL1551B</h2><p>为<strong>NRES</strong>引脚输入<strong>低电平</strong>使单片机<strong>复位</strong></p><ul><li>当ENB为<strong>高</strong>电平时，<strong>B</strong>连接到<strong>A1</strong></li><li>当ENB为<strong>低</strong>电平时，<strong>B</strong>连接到<strong>A2</strong></li></ul><h2 id="1-2-TPS3823"><a href="#1-2-TPS3823" class="headerlink" title="1.2 TPS3823"></a>1.2 TPS3823</h2><p><a href="https://www.ti.com/cn/lit/ds/symlink/tps3823.pdf">带看门狗计时器的 TPS382x 电压监视器 datasheet (Rev. N)</a></p><ul><li><p><strong>引脚1（RESET#）</strong>：低电平复位输出</p></li><li><p><strong>引脚4（WDI）</strong>：看门狗计时器输入。如果 WDI 保持高电平或低电平的时间<strong>超过超时周期</strong>， 则会触发复位。当复位生效或 WDI 出现上升沿或下降沿时，计时器将清 零。如果未使用，WDI 连接必须为高阻抗，以防其引起复位事件</p><p>  <img src="/2025/03/08/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/8.OV-Watch_OWDG/2.png" alt="image-20250304200017544"></p></li></ul><h1 id="二、软件设计"><a href="#二、软件设计" class="headerlink" title="二、软件设计"></a>二、软件设计</h1><h2 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h2><p>通过控制单片机与<strong>BL1551B</strong>连接的引脚的<strong>高低电平</strong>来控制看门狗的启停</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WDOG_Port_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GPIO Ports Clock Enable */</span></span><br><span class="line">  __HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  GPIO_InitStructure.Pin = WDOG_EN_PIN;</span><br><span class="line">  GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStructure.Pull = GPIO_PULLUP;</span><br><span class="line">  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(WDOG_EN_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">  GPIO_InitStructure.Pin = WDI_PIN;</span><br><span class="line">  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">  HAL_GPIO_Init(WDI_PORT, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WDOG_Enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_GPIO_WritePin(WDOG_EN_PORT,WDOG_EN_PIN,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WDOG_Disnable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_GPIO_WritePin(WDOG_EN_PORT,WDOG_EN_PIN,GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WDOG_Feed</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_GPIO_TogglePin(WDI_PORT,WDI_PIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-喂狗任务"><a href="#2-1-喂狗任务" class="headerlink" title="2.1 喂狗任务"></a>2.1 喂狗任务</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WDOGFeedTask</span><span class="params">(<span class="type">void</span> *argument)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//owdg</span></span><br><span class="line">WDOG_Port_Init(); <span class="comment">//YDW 看门狗相关引脚初始化</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">WDOG_Feed();  <span class="comment">// 喂看门狗    翻转引脚电平</span></span><br><span class="line">WDOG_Enable();<span class="comment">// 启用看门狗  拉低引脚电平</span></span><br><span class="line">    osDelay(<span class="number">100</span>);<span class="comment">// 100ms喂一次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL(一)基础对象</title>
      <link href="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/"/>
      <url>/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18H4y1g7CF?spm_id_from=333.788.videopod.sections&vd_source=daf1db3c953df56f74e76077dfa61ab4">2-3-1_LVGL入门教程之基础对象(lv_obj)_哔哩哔哩_bilibili</a></p><p><a href="https://lvgl.100ask.net/master/details/widgets/index.html">Widgets（控件） — LVGL 文档</a></p><h1 id="一、目录说明"><a href="#一、目录说明" class="headerlink" title="一、目录说明"></a>一、目录说明</h1><ul><li>demos：存放的是LVGL一些综合的内置示例，部分示例可以在官网体验</li><li>docs：存放LVGL的开发文档，阅读时一般不在这里直接阅读，而是在LVGL站点阅读</li><li>env_support:一些环境或者平台的支持，不如我们所使用的RT-Thread就在其中</li><li>scripts：存放一些处理脚本，我们在使用LVGL时基本不会用到</li><li>src：存放LVGL实际的源码，我们使用LVGL进行开发时，都是使用这里面的代码文件</li><li>tests：存放一些CI测试文件，我们在使用LVGL时不会用到</li></ul><h1 id="二、LVGL的启动流程初探"><a href="#二、LVGL的启动流程初探" class="headerlink" title="二、LVGL的启动流程初探"></a>二、LVGL的启动流程初探</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化LVGL库 */</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化LVGL的硬件抽象层（显示、触摸）  */</span></span><br><span class="line">    <span class="type">lv_display_t</span> * display = lv_windows_create_display(title, <span class="number">1024</span>, <span class="number">600</span>, <span class="number">100</span>, FALSE, FALSE);</span><br><span class="line">    lv_windows_acquire_pointer_indev(display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将提示信息输出到控制台，也可以使用printf函数 */</span></span><br><span class="line">    LV_LOG_USER(<span class="string">&quot;LVGL initialization completed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行demo */</span></span><br><span class="line">    <span class="comment">// 下面这三行是运行一个demo，第一行和后面两行的效果是一样的，只能同时去掉第一行或者后面两行，两者之一的注释</span></span><br><span class="line">    <span class="comment">// 后续学习的时候要确保下面这三行都被注释掉</span></span><br><span class="line">    lv_demo_widgets();</span><br><span class="line">    <span class="comment">//char * demo_str[] = &#123;&quot;widgets&quot;&#125;;</span></span><br><span class="line">    <span class="comment">//lv_demos_create(demo_str, strlen((char * )demo_str));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 课程示例代码，一般同时只运行一个</span></span><br><span class="line"><span class="comment">       运行前，请将上面的三行代码都注释掉 */</span></span><br><span class="line">    <span class="comment">//lesson_2_3_1();         // 基础对象(lv_obj)，&quot;Hello, LVGL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 定期调用lv_task处理（定时器）程序它也可以在定时器或操作系统任务中完成 */</span></span><br><span class="line">        lv_task_handler();</span><br><span class="line">        usleep(<span class="number">5000</span>);       <span class="comment">/* 不一直占用系统资源 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LVGL的定时器处理程序是一个内置的任务系统，允许开发者注册函数，使其可以定期被调用，它帮助管理时间敏感的操作（毫秒级别）和周期性的活动</p><h1 id="三、LVGL裁剪"><a href="#三、LVGL裁剪" class="headerlink" title="三、LVGL裁剪"></a>三、LVGL裁剪</h1><p>LVGL的裁剪在<code>lv_conf.h</code>文件中进行</p><p>我们可以尝试关闭<code>lv_conf.h</code>文件中的WIDGETS和THEMES的部分功能来验证</p><h1 id="四、SquareLine-Stdio使用"><a href="#四、SquareLine-Stdio使用" class="headerlink" title="四、SquareLine_Stdio使用"></a>四、SquareLine_Stdio使用</h1><ul><li><p>Project name (项目名称)：<code>lvgl_1</code>：这是该项目的名称。项目名通常用于标识和区分不同的应用或设计。</p></li><li><p>路径 (路径)：<code>G:\ydw_item\LVGL\my_lvgl_work\my_lvgl_1\</code>：显示了该项目的存储路径。此路径用于保存项目文件。</p></li><li><p>Resolution (分辨率)：<code>240 x 280</code>：设置显示屏的分辨率为 240 像素宽，280 像素高。这意味着你的显示设备具有240像素的宽度和280像素的高度。</p></li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/8.png" alt="image-20250316153602188"></p><ul><li>Rotation (旋转)<code>：0 degree</code>：显示方向设置为 0 度，也就是没有旋转，显示方向与硬件显示方向一致。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/1.png" alt="image-20250316151839395"></p><ul><li><p>Offset (偏移)：<code>0, 0</code>：设置显示区域的偏移量，通常用来对显示内容进行微调，确保图像和内容显示正确。在这里，偏移量设置为 <code>(0, 0)</code>，表示没有偏移。</p><p>  <img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/5.png" alt="image-20250316152820450"></p></li><li><p>Shape (形状)：<code>Rectangle</code>：设置显示区域的形状为矩形，这适用于大多数显示屏，尤其是液晶或OLED显示器。</p></li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/4.png" alt="image-20250316152240395"></p><ul><li>Color depth (颜色深度)：设置颜色深度为 16 位，这意味着每个像素使用 16 位来表示颜色，通常为 RGB 565 格式（5 位红色，6 位绿色，5 位蓝色）。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/2.png" alt="image-20250316151915238"></p><ul><li>LVGL version (LVGL 版本)：该项目使用的 LVGL 版本是 8.3.6，这是 Lightweight Graphics Library 的版本。LVGL 是一个开源的图形库，通常用于嵌入式系统中的图形用户界面（GUI）。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/6.png" alt="image-20250316152850607"></p><ul><li>Theme (主题)：Light：主题设置为浅色主题，意味着界面背景会较亮，适用于在明亮环境中使用。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/7.png" alt="image-20250316152924653"></p><ul><li>Multilanguage (多语言)：Disable：多语言支持被禁用，意味着该界面不会有语言切换功能，可能只支持单一语言</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/3.png" alt="image-20250316152119619"></p><h1 id="五、自定义字体"><a href="#五、自定义字体" class="headerlink" title="五、自定义字体"></a>五、自定义字体</h1><h2 id="5-1-生成自定义字库"><a href="#5-1-生成自定义字库" class="headerlink" title="5.1 生成自定义字库"></a>5.1 生成自定义字库</h2><p><a href="https://lvgl.io/tools/fontconverter">LVGL在线自定义字体转换器</a></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/9.png" alt="QQ_1742203731682"></p><h2 id="5-2-声明自定义字库"><a href="#5-2-声明自定义字库" class="headerlink" title="5.2 声明自定义字库"></a>5.2 声明自定义字库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV_FONT_DECLARE(alimamashuheiti_48);</span><br></pre></td></tr></table></figure><h2 id="5-3-使用字体"><a href="#5-3-使用字体" class="headerlink" title="5.3 使用字体"></a>5.3 使用字体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_font(ui_TimeMinuteLabel, &amp;alimamashuheiti_48, LV_PART_MAIN | LV_STATE_DEFAULT);</span><br></pre></td></tr></table></figure><h2 id="5-4-设置字体颜色"><a href="#5-4-设置字体颜色" class="headerlink" title="5.4 设置字体颜色"></a>5.4 设置字体颜色</h2><p><a href="https://www.jyshare.com/front-end/55/">RGB 转 16 进制工具 | 菜鸟工具</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_color(ui_TimeMinuteLabel, lv_color_hex(<span class="number">0xCDCDB4</span>), LV_PART_MAIN | LV_STATE_DEFAULT);</span><br></pre></td></tr></table></figure><h1 id="六、图像"><a href="#六、图像" class="headerlink" title="六、图像"></a>六、图像</h1><h2 id="6-1-生成代码"><a href="#6-1-生成代码" class="headerlink" title="6.1 生成代码"></a>6.1 生成代码</h2><p><a href="https://lvgl.io/tools/imageconverter">LVGL在线图像生成器</a></p><p><strong>在使用生成器前使用PS软件将图片修改致对应大小</strong> </p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/10.png" alt="QQ_1742209430572"></p><h2 id="6-2-声明图像"><a href="#6-2-声明图像" class="headerlink" title="6.2 声明图像"></a>6.2 声明图像</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV_IMG_DECLARE(image1);</span><br></pre></td></tr></table></figure><h2 id="6-3-设置图像"><a href="#6-3-设置图像" class="headerlink" title="6.3 设置图像"></a>6.3 设置图像</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> * bg_image = lv_img_create(screem);</span><br><span class="line">lv_img_set_src(bg_image,&amp;image1);</span><br></pre></td></tr></table></figure><h1 id="七、GIF图像"><a href="#七、GIF图像" class="headerlink" title="七、GIF图像"></a>七、GIF图像</h1><h1 id="七、自定义图标"><a href="#七、自定义图标" class="headerlink" title="七、自定义图标"></a>七、自定义图标</h1><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p><a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php"><code>Unicode编码</code>转换<code>UTF-8编码</code></a></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/11.png" alt="image-20250323194551201"></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/image-20250323194617525.png" alt="image-20250323194617525"></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/image-20250323194640838.png" alt="image-20250323194640838"></p>]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-7-MPU6050</title>
      <link href="/2025/03/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/7.OV-Watch_MPU6050/"/>
      <url>/2025/03/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/7.OV-Watch_MPU6050/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/weixin_44788542/article/details/129328712?ops_request_misc=%7B%22request_id%22:%225dc026da3d39d8006490552a9c75352b%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=5dc026da3d39d8006490552a9c75352b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129328712-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=MPU6050&spm=1018.2226.3001.4187">六轴传感器基础知识学习：MPU6050特性，四元数，姿态解算，卡尔曼滤波_mpu6050卡尔曼滤波姿态解算-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_45217381/article/details/134302880?ops_request_misc=%7B%22request_id%22:%225dc026da3d39d8006490552a9c75352b%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=5dc026da3d39d8006490552a9c75352b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-134302880-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=MPU6050&spm=1018.2226.3001.4187">STM32外设系列—MPU6050角度传感器-CSDN博客</a></p><p><img src="/2025/03/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/7.OV-Watch_MPU6050/1.png" alt="image-20250302140809926"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-6-LSM303DLH</title>
      <link href="/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/"/>
      <url>/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/xiaolong1126626497/article/details/134456723">基于单片机设计的电子指南针(LSM303DLH模块(三轴磁场 + 三轴加速度)_lsm303dlh电子指南针-CSDN博客</a></p><p><img src="/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/1.png" alt="image-20250302134955498"></p><p><code>LSM_DRDY</code>,<code>LSM_INT2</code>,<code>LSM_INT1</code>没有连接引脚</p><p><img src="/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/2.png" alt="image-20250302135027564"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-5-EM7028</title>
      <link href="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/"/>
      <url>/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/Graceful_scenery/article/details/144164078">STM2F411智能手环设计-CSDN博客</a></p><p><a href="https://wenku.csdn.net/column/1qfak96893">【心率信号处理】：EM7028数据采集、采样与滤波技术 - CSDN文库</a></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/1.png" alt="image-20250302125516606"></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/2.png" alt="image-20250302125540196"></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/3.png" alt="image-20250302125553257"></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/image-20250302125623426.png" alt="image-20250302125623426"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-4-BL24C02</title>
      <link href="/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/"/>
      <url>/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/kiss_youi/article/details/115468415">BL24Cxx系列EEPROM测试总结-CSDN博客</a></p><p><a href="https://blog.csdn.net/2401_85236922/article/details/141247699">BL24C02P芯片的使用说明&#x2F;i2c数据存储芯片-CSDN博客</a></p><p><img src="/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/1.png" alt="image-20250302124825002"></p><p><img src="/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/2.png" alt="image-20250302124752744"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-3-AHT21</title>
      <link href="/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/"/>
      <url>/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/weixin_45189628/article/details/111110465">关于基于I2C使用AHT21B模块及stm32核心板进行温湿度采集-CSDN博客</a></p><p><img src="/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/1.png" alt="image-20250302123509556"></p><p><img src="/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/2.png" alt="image-20250302123647037"></p><p><img src="/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/3.png" alt="image-20250302123741051"></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-1-Blue</title>
      <link href="/2025/02/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/1.OV-Watch_blue/"/>
      <url>/2025/02/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/1.OV-Watch_blue/</url>
      
        <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><img src="/2025/02/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/1.OV-Watch_blue/1.png" alt="image-20250228163058430"></p><table><thead><tr><th align="center">原理图引脚</th><th align="center">MCU引脚</th></tr></thead><tbody><tr><td align="center">BLE_TX</td><td align="center">PA9</td></tr><tr><td align="center">BLE_RX</td><td align="center">PA10</td></tr><tr><td align="center">BLE_EN</td><td align="center">PA8</td></tr></tbody></table><h2 id="1-BL1551B"><a href="#1-BL1551B" class="headerlink" title="1.BL1551B"></a>1.BL1551B</h2><p><a href="https://blog.csdn.net/zhuoqingjoking97298/article/details/121437976">BL1551模拟开关，封装SC70-6_bl1551中文资料-CSDN博客</a></p><h2 id="2-KT6328A1"><a href="#2-KT6328A1" class="headerlink" title="2.KT6328A1"></a>2.KT6328A1</h2><p><a href="https://blog.csdn.net/qyvhome/article/details/121592868">KT6368A国产蓝牙BLE芯片驱动程序&amp;硬件注意事项-CSDN博客</a></p><h1 id="二、软件"><a href="#二、软件" class="headerlink" title="二、软件"></a>二、软件</h1><h2 id="2-1-KT6328-h"><a href="#2-1-KT6328-h" class="headerlink" title="2.1 KT6328.h"></a>2.1 KT6328.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLE_EN_PORT GPIOA<span class="comment">//宏定义引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLE_EN_GPIO GPIO_PIN_8</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Disable</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-KT6328-c"><a href="#2-2-KT6328-c" class="headerlink" title="2.2 KT6328.c"></a>2.2 KT6328.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">KT6328_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET); <span class="comment">//确保引脚在初始化过程中保持已知且稳定的状态</span></span><br><span class="line"></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_8;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(BLE_EN_PORT, BLE_EN_GPIO, GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(BLE_EN_PORT, BLE_EN_GPIO, GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-usart-c"><a href="#2-3-usart-c" class="headerlink" title="2.3 usart.c"></a>2.3 usart.c</h2><p><a href="https://blog.csdn.net/weixin_44386927/article/details/112862801?sharetype=blogdetail&shareId=112862801&sharerefer=APP&sharesource=2303_77755415&sharefrom=link">一.在HAL库中使用串口（dma）模式接收发送测试_串口 dma 接收 hal库-CSDN博客</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_USART1_UART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_Init 1 */</span></span><br><span class="line">  huart1.Instance = USART1;</span><br><span class="line">  huart1.Init.BaudRate = <span class="number">115200</span>;</span><br><span class="line">  huart1.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">  huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">  huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">  huart1.Init.Mode = UART_MODE_TX_RX;</span><br><span class="line">  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;</span><br><span class="line">  huart1.Init.OverSampling = UART_OVERSAMPLING_16;</span><br><span class="line">  <span class="keyword">if</span> (HAL_UART_Init(&amp;huart1) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_Init 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_Init 2 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_MspInit</span><span class="params">(UART_HandleTypeDef* uartHandle)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(uartHandle-&gt;Instance==USART1)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_MspInit 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_MspInit 0 */</span></span><br><span class="line">    <span class="comment">/* USART1 clock enable */</span></span><br><span class="line">    __HAL_RCC_USART1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    <span class="comment">/**USART1 GPIO Configuration</span></span><br><span class="line"><span class="comment">    PA9     ------&gt; USART1_TX</span></span><br><span class="line"><span class="comment">    PA10     ------&gt; USART1_RX</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;</span><br><span class="line">    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USART1 DMA Init */</span></span><br><span class="line">    <span class="comment">/* USART1_RX Init */</span></span><br><span class="line">    hdma_usart1_rx.Instance = DMA2_Stream5;</span><br><span class="line">    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;</span><br><span class="line">    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_rx.Init.Mode = DMA_NORMAL;</span><br><span class="line">    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;</span><br><span class="line">    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;</span><br><span class="line">    <span class="keyword">if</span> (HAL_DMA_Init(&amp;hdma_usart1_rx) != HAL_OK)<span class="comment">//HAL_UART_Init()中调用了HAL_UART_MspInit()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USART1_TX Init */</span></span><br><span class="line">    hdma_usart1_tx.Instance = DMA2_Stream7;</span><br><span class="line">    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;</span><br><span class="line">    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;</span><br><span class="line">    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_tx.Init.Mode = DMA_NORMAL;</span><br><span class="line">    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;</span><br><span class="line">    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;</span><br><span class="line">    <span class="keyword">if</span> (HAL_DMA_Init(&amp;hdma_usart1_tx) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USART1 interrupt Init */</span></span><br><span class="line">    HAL_NVIC_SetPriority(USART1_IRQn, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    HAL_NVIC_EnableIRQ(USART1_IRQn);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_MspInit 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_MspInit 1 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HAL_UART_Init()<strong>中调用了</strong>HAL_UART_MspInit()</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OV-Watch-2-系统滴答定时器</title>
      <link href="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
      <url>/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、系统滴答定时器介绍"><a href="#一、系统滴答定时器介绍" class="headerlink" title="一、系统滴答定时器介绍"></a>一、系统滴答定时器介绍</h1><p><a href="https://www.bilibili.com/video/BV1YD4y1t7NN/?spm_id_from=333.337.search-card.all.click&vd_source=daf1db3c953df56f74e76077dfa61ab4">【信盈达】- 关于STM32如何使用系统滴答定时器实现精准延时_哔哩哔哩_bilibili</a></p><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/6.png" alt="458b52f3-fa96-459d-a128-c80c1793eeb5"></p><p><strong>SysTick</strong> 是 <strong>ARM Cortex-M</strong> 处理器内建的一个定时器，通常用于生成定时中断，用于实现操作系统的时间片轮转调度、延时功能或定期的定时任务。SysTick 定时器是一个 <strong>24 位递减计数器</strong>，通常用来生成周期性的中断，以便进行周期性任务的调度。</p><h2 id="SysTick-定时器的工作原理："><a href="#SysTick-定时器的工作原理：" class="headerlink" title="SysTick 定时器的工作原理："></a><strong>SysTick 定时器的工作原理：</strong></h2><ol><li><strong>24 位计数器</strong>：<ul><li>SysTick 定时器的核心是一个 <strong>24</strong> (16,777,216)位的<strong>递减计数器</strong>。计数器从一个预定值递减到 0。当计数器到达 0 时，会触发一个中断。</li><li>计数器可以通过设置其初始值来指定时间间隔。</li></ul></li><li><strong>中断控制</strong>：<ul><li>SysTick 定时器生成的中断可以用来进行定时任务的执行，例如在 RTOS 中，SysTick 用来生成时间片，以进行任务调度。</li><li>也可以用于延时函数（如延时 1 毫秒、10 毫秒等），控制时间的流逝。</li></ul></li><li><strong>计时精度</strong>：<ul><li>SysTick 的精度通常取决于系统时钟频率。常见的情况下，系统时钟频率为 72 MHz 或 48 MHz，因此 SysTick 的中断周期可以非常精确。</li></ul></li></ol><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/2.png" alt="image-20250302151454173"></p><h2 id="SysTick-Type结构体"><a href="#SysTick-Type结构体" class="headerlink" title="SysTick_Type结构体"></a>SysTick_Type结构体</h2><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image-20250226144449751"></p><ol><li><p><strong><code>CTRL</code>（SysTick 控制与状态寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x000</code></li><li><strong>类型</strong>: <code>__IOM uint32_t</code>（读写寄存器）</li><li><strong>描述</strong>: 该寄存器用于控制和查看 SysTick 定时器的状态。通过设置不同的控制位，能够启动、停止定时器，配置中断等。</li></ul><p> <strong>常见控制位：</strong></p><ul><li><strong>ENABLE (位 0)</strong>: 启动或停止 SysTick 定时器。</li><li><strong>TICKINT (位 1)</strong>: 启用或禁用 SysTick 溢出中断。</li><li><strong>CLKSOURCE (位 2)</strong>: 选择 SysTick 定时器的时钟源（HCLK 或外部时钟）。</li><li><strong>COUNTFLAG (位 16)</strong>: 当计数器溢出时，设置为 1。</li></ul><p> <img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/4.png" alt="image-20250302151934500"></p></li><li><p><strong><code>LOAD</code>（SysTick 重载值寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x004</code></li><li><strong>类型</strong>: <code>__IOM uint32_t</code>（读写寄存器）</li><li><strong>描述</strong>: 该寄存器用于设置定时器的重载值。SysTick 定时器每当计数器减至零时，会根据 <code>LOAD</code> 寄存器的值重新加载并开始新的计数。</li></ul><p> <strong>用途</strong>: 通过设置该寄存器的值来控制定时器的溢出周期。例如，如果你想让定时器每 1 毫秒溢出一次，你可以设置该寄存器的值为 <code>SystemCoreClock / 1000</code>。</p></li></ol><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/5.png" alt="image-20250302151952720"></p><ol><li><p><strong><code>VAL</code>（SysTick 当前值寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x008</code></li><li><strong>类型</strong>: <code>__IOM uint32_t</code>（读写寄存器）</li><li><strong>描述</strong>: 该寄存器保存当前 SysTick 定时器的计数值。每当计数器从 <code>LOAD</code> 的值开始计数，直到它到达零时，<code>VAL</code> 会自动重载为 <code>LOAD</code> 的值，并且会触发中断（如果启用了中断）。</li></ul><p> <strong>用途</strong>: 读取此寄存器可以获取当前定时器的剩余计数值。它可用于计算经过的时间或检查定时器的状态。</p></li><li><p><strong><code>CALIB</code>（SysTick 校准寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x00C</code></li><li><strong>类型</strong>: <code>__IM uint32_t</code>（只读寄存器）</li><li><strong>描述</strong>: 该寄存器提供关于系统时钟的校准信息，包括 SysTick 定时器的校准值。它通常用于获取定时器的精度和所使用的时钟的频率。</li></ul><p> <strong>用途</strong>: 这个寄存器通常用于调试和校准目的，帮助开发者了解系统时钟的频率和定时器的精度。</p></li></ol><h1 id="二、系统滴答定时器用于延时函数"><a href="#二、系统滴答定时器用于延时函数" class="headerlink" title="二、系统滴答定时器用于延时函数"></a>二、系统滴答定时器用于延时函数</h1><h2 id="1-1delay-init"><a href="#1-1delay-init" class="headerlink" title="1.1delay_init()"></a>1.1delay_init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);<span class="comment">//设置 SysTick 时钟源为 HCLK，即系统时钟。</span></span><br><span class="line">    HAL_SYSTICK_Config(SystemCoreClock / (<span class="number">1000U</span> / uwTickFreq));<span class="comment">//配置 SysTick 定时器的重载值，使其每 1 毫秒触发一次中断。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-delay-us"><a href="#1-2-delay-us" class="headerlink" title="1.2 delay_us()"></a>1.2 delay_us()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_CLK 100 <span class="comment">// 100次计数/us  100MHZ</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_SUPPORT 0       <span class="comment">// 是否可以使用操作系统相关的功能</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_SUPPORT                    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ticks;</span><br><span class="line">    <span class="type">uint32_t</span> told,tnow,tcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> reload=SysTick-&gt;LOAD;<span class="comment">// 当前定时器的重载值寄存器的值    </span></span><br><span class="line">    ticks=nus*SYS_CLK; <span class="comment">// 计算设定的延时需要计数多少次 </span></span><br><span class="line">    delay_osschedlock();<span class="comment">// 锁定调度</span></span><br><span class="line">    told=SysTick-&gt;VAL;        <span class="comment">// 开始延时时的计数值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnow=SysTick-&gt;VAL;</span><br><span class="line">        <span class="keyword">if</span>(tnow!=told)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">if</span>(tnow&lt;told) tcnt+=told-tnow;  <span class="comment">// 将两差值累加进tcnt(计数器没溢出)</span></span><br><span class="line">            <span class="keyword">else</span> tcnt+=reload-tnow+told;    <span class="comment">// 将两差值累加进tcnt(计数器溢出)</span></span><br><span class="line">            told=tnow;                      <span class="comment">// 更新told</span></span><br><span class="line">            <span class="keyword">if</span>(tcnt&gt;=ticks) <span class="keyword">break</span>;          <span class="comment">// 达到预定的时钟周期数时退出</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    delay_osschedunlock();<span class="comment">// 释放调度锁    </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint32_t</span> nus)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ticks;    </span><br><span class="line">    <span class="type">uint32_t</span> told,tnow,tcnt=<span class="number">0</span>;        </span><br><span class="line">    <span class="type">uint32_t</span> reload=SysTick-&gt;LOAD; <span class="comment">// 当前定时器的重载值寄存器的值</span></span><br><span class="line">    tcnt = <span class="number">0</span>;</span><br><span class="line">    ticks=nus*SYS_CLK;      <span class="comment">// 计算设定的延时需要计数多少次</span></span><br><span class="line">    told=SysTick-&gt;VAL;         <span class="comment">// 开始延时时的计数值100 000 000/s  100 000/ms 100/us</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)   </span><br><span class="line">    &#123;                                   </span><br><span class="line">        tnow=SysTick-&gt;VAL;      </span><br><span class="line">        <span class="keyword">if</span>(tnow!=told)      </span><br><span class="line">        &#123;           </span><br><span class="line">            <span class="keyword">if</span>(tnow&lt;told) tcnt+=told-tnow;   <span class="comment">// 将两差值累加进tcnt(计数器没溢出)</span></span><br><span class="line">            <span class="keyword">else</span> tcnt+=reload-tnow+told;     <span class="comment">// 将两差值累加进tcnt(计数器溢出) </span></span><br><span class="line">            told=tnow; <span class="comment">// 更新told</span></span><br><span class="line">            <span class="keyword">if</span>(tcnt&gt;=ticks) <span class="keyword">break</span>;   <span class="comment">// 达到预定的时钟周期数时退出  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3-delay-ms"><a href="#1-3-delay-ms" class="headerlink" title="1.3 delay_ms()"></a>1.3 delay_ms()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> OS_SUPPORT        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 nms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(delay_osrunning&amp;&amp;delay_osintnesting==<span class="number">0</span>)    </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(nms&gt;=fac_ms)</span><br><span class="line">&#123; </span><br><span class="line">   delay_ostimedly(nms/fac_ms);</span><br><span class="line">&#125;</span><br><span class="line">nms%=fac_ms; </span><br><span class="line">&#125;</span><br><span class="line">delay_us((u32)(nms*<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint32_t</span> nms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(nms--)</span><br><span class="line">        delay_us(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="三、HAL-Delay"><a href="#三、HAL-Delay" class="headerlink" title="三、HAL_Delay()"></a>三、HAL_Delay()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="type">void</span> <span class="title function_">HAL_Delay</span><span class="params">(<span class="type">uint32_t</span> Delay)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> tickstart = HAL_GetTick();</span><br><span class="line">  <span class="type">uint32_t</span> wait = Delay;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add a freq to guarantee minimum wait */</span></span><br><span class="line">  <span class="keyword">if</span> (wait &lt; HAL_MAX_DELAY)</span><br><span class="line">  &#123;</span><br><span class="line">    wait += (<span class="type">uint32_t</span>)(uwTickFreq);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((HAL_GetTick() - tickstart) &lt; wait)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：第9行默认将延时增加了1ms，weak函数可以根据自己的需求更改</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人项目 </category>
          
          <category> OV-Watch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人项目 </tag>
            
            <tag> OV-Watch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-9-二叉树</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的创建与遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>             //定义二叉树结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createTree</span><span class="params">(TreeNode** T, <span class="type">char</span>* data, <span class="type">int</span>* index)</span>   <span class="comment">//初始化树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = data[*index];                                   </span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时为空节点</span></span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时不为空</span></span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T) -&gt; data = ch;</span><br><span class="line">        <span class="comment">// 创建左子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;lchild), data, index);</span><br><span class="line">        <span class="comment">// 创建右子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;rchild), data, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        preOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        preOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        inOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 中办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        inOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode* T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        postOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        postOrder(T-&gt;rchild);</span><br><span class="line">        <span class="comment">// 后办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* T;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    createTree(&amp;T, argv[<span class="number">1</span>], &amp;index);</span><br><span class="line">    preOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    inOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    postOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-8-暴力匹配</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span>       //定义字符串结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125; String;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String* <span class="title function_">initString</span><span class="params">()</span>                                <span class="comment">//初始化字符串 </span></span><br><span class="line">&#123;</span><br><span class="line">    String* s = (String*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(String));    <span class="comment">//为字符串开辟动态内存空间</span></span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>;                                 <span class="comment">//为</span></span><br><span class="line">    s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringAssign</span><span class="params">(String* s, <span class="type">char</span>* data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;data) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* temp = data;</span><br><span class="line">    <span class="keyword">while</span> (*temp) </span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        temp = data;</span><br><span class="line">        s-&gt;len = len;</span><br><span class="line">        s-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++, temp++) </span><br><span class="line">        &#123;</span><br><span class="line">            s-&gt;data[i] = *temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printString</span><span class="params">(String* s)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s-&gt;len; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(i == <span class="number">0</span> ? <span class="string">&quot;%c &quot;</span> : <span class="string">&quot;-&gt; %c &quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceMatch</span><span class="params">(String* master, String* sub)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp; j &lt; sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;data[i] == sub-&gt;data[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match success.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match fail.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    String* s = initString();</span><br><span class="line">    String* s1 = initString();</span><br><span class="line">    stringAssign(s, argv[<span class="number">1</span>]);</span><br><span class="line">    stringAssign(s1, argv[<span class="number">2</span>]);</span><br><span class="line">    printString(s);</span><br><span class="line">    printString(s1);</span><br><span class="line">    forceMatch(s, s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-7-循环队列</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要知道队列当前有多少个元素</span></span><br><span class="line">    <span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">    <span class="type">int</span> index = Q-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, Q-&gt;data[index]);</span><br><span class="line">        index = (index + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(Queue* Q, <span class="type">int</span> data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = data;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data = Q-&gt;data[Q-&gt;front];</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-6-栈</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义栈结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">initStack</span><span class="params">()</span>                               <span class="comment">//初始化栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));     <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L-&gt;data = <span class="number">0</span>;                                <span class="comment">//data初始化</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                             <span class="comment">//头结点next指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> L;                                   <span class="comment">//返回头结点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Node *L, <span class="type">int</span> data)</span>                    <span class="comment">//入栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                          <span class="comment">//为data赋值</span></span><br><span class="line">    node-&gt;next = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    L-&gt;next = node;                             <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    L-&gt;data++;                                  <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Node *L)</span>                            <span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span>)                       <span class="comment">//判断栈是否为空栈 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//是空栈则返回 1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Node *node = L-&gt;next;               <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        <span class="type">int</span> data = node-&gt;data;              <span class="comment">//将头结点的下一结点的data 赋值给 data</span></span><br><span class="line">        L-&gt;next = node-&gt;next;               <span class="comment">//将头结点的下一结点的next 赋值给头结点的next</span></span><br><span class="line">        <span class="built_in">free</span>(node);                         <span class="comment">//释放头结点的下一结点的动态内存空间</span></span><br><span class="line">        L-&gt;data--;                          <span class="comment">//将头结点的data--</span></span><br><span class="line">        <span class="keyword">return</span> data;                        <span class="comment">//返回取出的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node *L)</span>                        <span class="comment">//判断是否为空栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span> || L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的data == 0 或者 头结点的next的值为NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">//返回 1，代表此栈为空栈</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//返回 0，代表此栈不是空栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Node *<span class="built_in">stack</span>)</span>            <span class="comment">//打印栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = <span class="built_in">stack</span>-&gt;next;           <span class="comment">//将头结点的next的值 赋值给node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                        <span class="comment">//判断node是否为NULL</span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);   <span class="comment">//打印node的data</span></span><br><span class="line">        node = node-&gt;next;              <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node *<span class="built_in">stack</span> = initStack();          <span class="comment">//创建栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">1</span>);                     <span class="comment">//1 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">2</span>);                     <span class="comment">//2 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">3</span>);                     <span class="comment">//3 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">4</span>);                     <span class="comment">//4 入栈</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pop = %d\n&quot;</span>, pop(<span class="built_in">stack</span>));   <span class="comment">//出战</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-5-队列</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="comment">//往头结点前面入队 ，从头结点后面出队</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义队列的结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initQueue</span><span class="params">()</span>                               <span class="comment">//初始化队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为头结点分配动态内春空间</span></span><br><span class="line">    Q-&gt;data = <span class="number">0</span>;                </span><br><span class="line">    Q-&gt;pre = Q;                                 <span class="comment">//初始化pre</span></span><br><span class="line">    Q-&gt;next = Q;                                <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Node* Q, <span class="type">int</span> data)</span>                         <span class="comment">//入队       </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));           <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                                  <span class="comment">//为新结点赋值</span></span><br><span class="line">    node-&gt;next = Q;                                     <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    node-&gt;pre = Q-&gt;pre;                                 <span class="comment">//将头结点的pre的值 赋值给 新结点的pre</span></span><br><span class="line">    Q-&gt;pre-&gt;next = node;                                <span class="comment">//将新结点的地址 赋值给 头结点的pre指向的结点的next</span></span><br><span class="line">    Q-&gt;pre = node;                                      <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    Q-&gt;data++;                                          <span class="comment">//头结点的data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node* Q)</span>                                    <span class="comment">//判队列是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;data == <span class="number">0</span> || Q-&gt;next == Q)                   <span class="comment">//如果头结点的data == 0，或者头结点的next == 自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                       <span class="comment">//返回 1，代表队列为空</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0，代表队列不为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Node* Q)</span>                                    <span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q))                                     <span class="comment">//判断队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//为空则返回 0</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;                                          </span><br><span class="line">        Node* node = Q-&gt;next;                           <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next;                        <span class="comment">//将头结点的next指向的结点的next的值 赋值给 头结点的next</span></span><br><span class="line">        Q-&gt;next-&gt;pre = Q;                               <span class="comment">//将头结点的地址 赋值给 头结点的next指向的结点的pre</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;data;                              <span class="comment">//返回出队结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Node* Q)</span>                                <span class="comment">//打印队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = Q -&gt; next;                             <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != Q)                                   <span class="comment">//判断node 是否是头结点的地址       </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);                 <span class="comment">//打印node的data</span></span><br><span class="line">        node = node -&gt; next;                            <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = initQueue();                      <span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(Q, <span class="number">1</span>);                              <span class="comment">//1 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">2</span>);                              <span class="comment">//2 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">3</span>);                              <span class="comment">//3 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">4</span>);                              <span class="comment">//4 入队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-4-双循环链表</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化头结点，创建链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化头结点的data</span></span><br><span class="line">    L -&gt; pre = L;                           <span class="comment">//初始化头结点的pre，指向自己</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化头结点的next，指向next</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//为新结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    node -&gt; pre = L;                            <span class="comment">//将头头结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    L -&gt; next -&gt; pre = node;                    <span class="comment">//将新结点的地址 赋值给 原来头结点的下一个结点的pre</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 头结点的next </span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L)                     <span class="comment">//判断node是否是最后一个结点</span></span><br><span class="line">    &#123;                                           <span class="comment">//如果不是</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将原来最后一个结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    n -&gt; next = L;                              <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; pre = n;                               <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                       <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                         <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != L)                               <span class="comment">//判断node 是否是 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)                   <span class="comment">//判断node是否是目标结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next的值 赋值给 目标结点的pre指向的结点的next</span></span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;      <span class="comment">//将目标结点的pre的值  赋值给 目标结点的next指向的结点的pre</span></span><br><span class="line">            <span class="built_in">free</span>(node);                             <span class="comment">//释放目标结点的动态内存空间</span></span><br><span class="line">            L -&gt; data --;                           <span class="comment">//头结点的data--</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;                               <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                        <span class="comment">//如果不是目标结点，更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否是 目标结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);           <span class="comment">//打印node的值</span></span><br><span class="line">        node = node-&gt;next;                      <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">///打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();           <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);               <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);               <span class="comment">//头插 2</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);               <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);               <span class="comment">//头插 5</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);               <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);               <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">7</span>);                   <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-3-双链表</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>             //创建结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;   Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//创建链表头结点，分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化链表结点数</span></span><br><span class="line">    L -&gt; pre = <span class="literal">NULL</span>;                        <span class="comment">//初始化pre</span></span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;                       <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> L;                               <span class="comment">//返沪Node类型的指针L</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>           <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//开辟结点动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                     <span class="comment">//结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                <span class="comment">//将头结点next指向的结点地址 赋值给 新的结点</span></span><br><span class="line">    node -&gt; pre = L;                         <span class="comment">//新结点的pre指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L -&gt; next)                           <span class="comment">//判断头结点的next是否是NULL</span></span><br><span class="line">    &#123;                                        <span class="comment">//如果不为空</span></span><br><span class="line">        L -&gt; next -&gt; pre = node;             <span class="comment">//将新结点的地址 赋值给 头结点下一个结点的 pre</span></span><br><span class="line">        L -&gt; next = node;                    <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                     <span class="comment">//当链表中只有头结点时</span></span><br><span class="line">    &#123; </span><br><span class="line">        L -&gt; next = node;                       <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    <span class="keyword">while</span> (node -&gt; next)                        <span class="comment">//遍历到链表最后一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;                                           <span class="comment">//node此时为尾结点</span></span><br><span class="line">    n -&gt; next = node -&gt; next;                   <span class="comment">//将尾结点next指向的地址 赋值给 新结点的next     </span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将尾结点的next指向n   </span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将新结点的pre指向原来的尾结点</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;                                  </span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点next指向的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//如果node不为空结点</span></span><br><span class="line">    &#123;                             </span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)               <span class="comment">//如果node是目标结点 </span></span><br><span class="line">        &#123;     </span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next; <span class="comment">//将node的next 赋值给 node上一个结点的next</span></span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next)                   <span class="comment">//如果node不是尾结点</span></span><br><span class="line">            &#123;                                       </span><br><span class="line">                node -&gt; next -&gt; pre = node -&gt; pre;  <span class="comment">//将node的pre 赋值给 node下一结点的pre</span></span><br><span class="line">            &#125;</span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点数据 --</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放node的空间</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//找到目标值，删除成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//node更新为下一结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到值，删除失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点指向的结点 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//当node不为空时， </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);         <span class="comment">//打印node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node为下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//当node为空结点时打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();                       <span class="comment">//创建链表，初始化头结点</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);                           <span class="comment">//头插1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);                           <span class="comment">//头插2</span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);                           <span class="comment">//头插3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);                           <span class="comment">//头插4</span></span><br><span class="line">    tailInsert(L, <span class="number">5</span>);                           <span class="comment">//尾插5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);                           <span class="comment">//尾插6</span></span><br><span class="line">    printList(L);                               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">6</span>);                               <span class="comment">//删除6</span></span><br><span class="line">    printList(L);                               <span class="comment">//删除链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-2-单循环链表</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义结点结构体</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>      <span class="comment">//结构体指针，指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化结构体，创建头结点 </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//开辟口结点空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化data数据</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化指针，指向自己</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//开辟结点空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将数据赋值给data</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的的next 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//新结点的地址 赋值给 头结点的node</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* n = L;                                <span class="comment">//将头结点 赋值给 n</span></span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将data 赋值给 新结点的data</span></span><br><span class="line">    <span class="keyword">while</span>(n -&gt; next != L)                       <span class="comment">//使用遍历，判断n的next 是否 指向 头结点，找到最后一个结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        n = n -&gt; next;                          <span class="comment">//不是则更新n</span></span><br><span class="line">    &#125;</span><br><span class="line">    node -&gt; next = L;                           <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    n -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* preNode = L;                          <span class="comment">//将头结点的地址 赋值给 preNode</span></span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next存储的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node的 地址 是否等于 头结点的地址</span></span><br><span class="line">    &#123;               </span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)                <span class="comment">//判断node的data 是否等于 目标值</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next值 赋值给 前一个结点的next</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放目标结点 动态内存空间</span></span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点的数据--</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;                         <span class="comment">//更新preNode</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到目标结点，返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否等于 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node -&gt; data);           <span class="comment">//打应node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//单循环链表，最后一个结点的next应指向头结点，此处代码错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();       <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);           <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);           <span class="comment">//头插 2 </span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);           <span class="comment">//头插 3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);           <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);           <span class="comment">//头插 5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);           <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);           <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">4</span>);               <span class="comment">//删除 4</span></span><br><span class="line">    delete(L, <span class="number">7</span>);               <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-1-单链表</title>
      <link href="/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
      <url>/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>     //定义一个结点的数据结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;   Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                                <span class="comment">//创建链表头</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//开辟空间</span></span><br><span class="line">    <span class="built_in">list</span> -&gt;data = <span class="number">0</span>;                            <span class="comment">//头结点值为0</span></span><br><span class="line">    <span class="built_in">list</span> -&gt;next = <span class="literal">NULL</span>;                         <span class="comment">//头结点 指向 NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span>          <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//开辟空间   </span></span><br><span class="line">    node -&gt; data = data;                       <span class="comment">//给新结点赋值</span></span><br><span class="line">    node -&gt; next = <span class="built_in">list</span> -&gt; next;               <span class="comment">//新结点的指针 指向 下一个结点</span></span><br><span class="line">    <span class="built_in">list</span> -&gt; next = node;                       <span class="comment">//头结点的指针 指向 新结点</span></span><br><span class="line">    <span class="built_in">list</span> -&gt; data++;                            <span class="comment">//头结点数据++，代表链表中的结点增多</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点赋值给node</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L -&gt; data; i++)          <span class="comment">//遍历原来的尾结点，i&lt;非头结点的结点数量</span></span><br><span class="line">    &#123;       </span><br><span class="line">        node = node-&gt;next;                      <span class="comment">//两个非头结点移一次，</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//给新结点开辟内存空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//给新结点赋值</span></span><br><span class="line">    n -&gt; next = <span class="literal">NULL</span>;                           <span class="comment">//将新结点指向NULL</span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//原来的为节点node指向 新的尾结点n</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点的值++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                    <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* preNode = L;                            <span class="comment">//将头结点赋值给preNode</span></span><br><span class="line">    Node* node = L -&gt; next;                       <span class="comment">//将头结点的指向的地址赋给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node)                                   <span class="comment">//当node的地址不为空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)                  <span class="comment">//判断node的值是否等于要删除的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;    <span class="comment">//将目标结点指向的地址 赋值给 上一个结点的指针</span></span><br><span class="line">            <span class="built_in">free</span>(node);                           <span class="comment">//释放空间</span></span><br><span class="line">            L -&gt; data--;                          <span class="comment">//链表个数--</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        </span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;                          <span class="comment">//不等于,头节点等于node</span></span><br><span class="line">        node = node -&gt; next;                     <span class="comment">//不等于，node等于node指向的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                          <span class="comment">//打印链表中的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                      <span class="comment">//将头节点指向的结点赋值给node</span></span><br><span class="line">    <span class="keyword">while</span>(node)                                  <span class="comment">//当node不是尾结点时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;node = %d \n&quot;</span>,node -&gt; data);     <span class="comment">//打印node的值</span></span><br><span class="line">        node = node -&gt; next;                     <span class="comment">//更新node的结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    Node* <span class="built_in">list</span> = initList();</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">6</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">7</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">8</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">9</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">10</span>);</span><br><span class="line">    printList(<span class="built_in">list</span>);</span><br><span class="line">    delete(<span class="built_in">list</span>,<span class="number">9</span>);</span><br><span class="line">    printList(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ADC</title>
      <link href="/2025/02/24/ADC/"/>
      <url>/2025/02/24/ADC/</url>
      
        <content type="html"><![CDATA[<h1 id="HAL-ADC-Init"><a href="#HAL-ADC-Init" class="headerlink" title="HAL_ADC_Init()"></a>HAL_ADC_Init()</h1><p><code>HAL_ADC_Init()</code> 是 STM32 HAL 库中的一个函数，用于初始化 ADC 外设。通过此函数，你可以配置 ADC 的基本参数，如分辨率、数据对齐方式、扫描模式等。它是使用 ADC 外设之前必需的初始化步骤。</p><h1 id="HAL-ADC-DeInit"><a href="#HAL-ADC-DeInit" class="headerlink" title="HAL_ADC_DeInit()"></a>HAL_ADC_DeInit()</h1><p><code>HAL_ADC_DeInit()</code> 用于反初始化 ADC 外设，将其恢复到默认的初始状态。这通常用于在不再需要 ADC 时禁用其工作，或者在配置 ADC 的其他工作模式之前调用，以清除之前的配置。</p><h1 id="HAL-ADC-MspInit"><a href="#HAL-ADC-MspInit" class="headerlink" title="HAL_ADC_MspInit()"></a>HAL_ADC_MspInit()</h1><p><code>HAL_ADC_MspInit()</code> 是一个与底层硬件相关的函数，用于初始化 ADC 外设所需的硬件资源。这通常包括启用外设时钟、配置 GPIO 引脚（如果需要）、配置中断、DMA 设置等。此函数通常在 <code>HAL_ADC_Init()</code> 调用时自动执行。</p><h1 id="HAL-ADC-MspDeInit"><a href="#HAL-ADC-MspDeInit" class="headerlink" title="HAL_ADC_MspDeInit()"></a>HAL_ADC_MspDeInit()</h1><p><code>HAL_ADC_MspDeInit()</code> 是与底层硬件相关的反初始化函数，用于恢复 ADC 外设的硬件资源，通常是在 <code>HAL_ADC_DeInit()</code> 调用时自动执行。此函数会禁用 ADC 外设所需的硬件资源，如时钟、GPIO 配置、中断等。</p><h1 id="HAL-ADC-Start"><a href="#HAL-ADC-Start" class="headerlink" title="HAL_ADC_Start()"></a>HAL_ADC_Start()</h1><p><code>HAL_ADC_Start()</code> 是 STM32 HAL 库中的一个函数，用于启动 ADC 外设的转换过程。它启动一个单次的 ADC 转换，或者在连续模式下，启动 ADC 并开始定期转换。</p><h1 id="HAL-ADC-Stop"><a href="#HAL-ADC-Stop" class="headerlink" title="HAL_ADC_Stop()"></a>HAL_ADC_Stop()</h1><p><code>HAL_ADC_Stop()</code> 用于停止 ADC 转换。调用此函数后，ADC 将停止转换过程，不再进行数据采样。</p><h1 id="HAL-ADC-PollForConversion"><a href="#HAL-ADC-PollForConversion" class="headerlink" title="HAL_ADC_PollForConversion()"></a>HAL_ADC_PollForConversion()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_PollForConversion</span><span class="params">(ADC_HandleTypeDef* hadc, <span class="type">uint32_t</span> Timeout)</span>;</span><br></pre></td></tr></table></figure><p><code>HAL_ADC_PollForConversion()</code> 是 STM32 HAL 库中的一个函数，用于在<strong>轮询模式</strong>下<strong>等待 ADC 转换完成</strong>。该函数会在<strong>指定的超时时间内不断检查 ADC 转换是否完成</strong>，如果完成则返回成功，否则会在超时后返回失败。</p><h1 id="HAL-ADC-PollForEvent"><a href="#HAL-ADC-PollForEvent" class="headerlink" title="HAL_ADC_PollForEvent()"></a>HAL_ADC_PollForEvent()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_PollForEvent</span><span class="params">(ADC_HandleTypeDef* hadc, <span class="type">uint32_t</span> EventType, <span class="type">uint32_t</span> Timeout)</span>;</span><br></pre></td></tr></table></figure><p><code>HAL_ADC_PollForEvent()</code> 是 STM32 HAL 库中的一个函数，用于在<strong>轮询模式</strong>下<strong>等待 ADC 事件的发生</strong>。这可以让你检测 ADC 是否发生了特定的事件，比如转换完成、错误、模拟看门狗报警等。与 <code>HAL_ADC_PollForConversion()</code> 相似，<code>HAL_ADC_PollForEvent()</code> 允许你在指定的超时时间内轮询等待事件发生。</p><ul><li><code>ADC_AWD_EVENT</code> 是 <strong>模拟看门狗事件</strong>（Analog Watchdog Event）</li><li><code>ADC_OVR_EVENT</code>  是<strong>ADC 溢出事件</strong>（ADC Overrun Event）</li></ul><h1 id="HAL-ADC-Start-IT"><a href="#HAL-ADC-Start-IT" class="headerlink" title="HAL_ADC_Start_IT()"></a>HAL_ADC_Start_IT()</h1><p><code>HAL_ADC_Start_IT()</code> 函数<strong>启动 ADC 转换</strong>并<strong>启用 ADC 中断</strong>。调用此函数后，ADC 开始转换，并在转换完成后会触发中断，进入中断服务程序（ISR）进行处理。适用于那些需要通过中断来处理 ADC 转换结果的应用。</p><h1 id="HAL-ADC-Stop-IT"><a href="#HAL-ADC-Stop-IT" class="headerlink" title="HAL_ADC_Stop_IT()"></a>HAL_ADC_Stop_IT()</h1><p><code>HAL_ADC_Stop_IT()</code> 函数<strong>停止 ADC 转换</strong>并<strong>禁用 ADC 中断</strong>。调用此函数后，ADC 将停止转换，并且 ADC 中断被禁用。适用于那些不再需要 ADC 转换时，或者需要手动停止转换并清除中断时。</p><h1 id="HAL-ADC-IRQHandler"><a href="#HAL-ADC-IRQHandler" class="headerlink" title="HAL_ADC_IRQHandler()"></a>HAL_ADC_IRQHandler()</h1><p><code>HAL_ADC_IRQHandler()</code> 是 STM32 HAL 库中的一个函数，用于处理 ADC 的中断请求。当 ADC 发生中断时，这个函数会被自动调用，它会检查 ADC 的状态并执行相应的中断服务程序（ISR）。</p><h1 id="HAL-ADC-Start-DMA"><a href="#HAL-ADC-Start-DMA" class="headerlink" title="HAL_ADC_Start_DMA()"></a>HAL_ADC_Start_DMA()</h1><p><code>HAL_ADC_Start_DMA()</code> 函数用于启动 ADC 并通过 DMA 将 ADC 转换的结果直接传输到内存。DMA 可以直接将 ADC 转换的结果写入到预定义的内存数组中，避免了 CPU 的参与。</p><h1 id="HAL-ADC-Stop-DMA"><a href="#HAL-ADC-Stop-DMA" class="headerlink" title="HAL_ADC_Stop_DMA()"></a>HAL_ADC_Stop_DMA()</h1><p><code>HAL_ADC_Stop_DMA()</code> 函数用于停止正在进行的 ADC DMA 操作。调用此函数后，DMA 会停止传输数据，ADC 也会停止转换。</p><h1 id="HAL-ADC-GetValue"><a href="#HAL-ADC-GetValue" class="headerlink" title="HAL_ADC_GetValue()"></a>HAL_ADC_GetValue()</h1><p><code>HAL_ADC_GetValue()</code> 是 STM32 HAL 库中的一个函数，用于<strong>获取 ADC 转换的结果</strong>。该函数可以在 ADC 转换完成后调用，返回当前 ADC 数据寄存器中的转换结果。</p><h1 id="HAL-ADC-ConvCpltCallback"><a href="#HAL-ADC-ConvCpltCallback" class="headerlink" title="HAL_ADC_ConvCpltCallback()"></a>HAL_ADC_ConvCpltCallback()</h1><p><code>HAL_ADC_ConvCpltCallback()</code> 是一个回调函数，当 <strong>ADC 转换完成</strong>并且所有<strong>数据都已转换时</strong>调用。这通常用于处理 ADC 转换结果，特别是在使用 DMA 模式时，当所有的转换数据已经被传输到内存后触发此回调。</p><h1 id="HAL-ADC-ConvHalfCpltCallback"><a href="#HAL-ADC-ConvHalfCpltCallback" class="headerlink" title="HAL_ADC_ConvHalfCpltCallback()"></a>HAL_ADC_ConvHalfCpltCallback()</h1><p><code>HAL_ADC_ConvHalfCpltCallback()</code> 是一个回调函数，当 <strong>ADC 转换完成的一半</strong>数据被传输到内存时触发。这通<strong>常与 DMA 模式结合</strong>使用，特别是在进行批量转换时。这个回调可以在数据的一半完成时执行某些操作，比如处理已经转换的前半部分数据。</p><h1 id="HAL-ADC-LevelOutOfWindowCallback"><a href="#HAL-ADC-LevelOutOfWindowCallback" class="headerlink" title="HAL_ADC_LevelOutOfWindowCallback()"></a>HAL_ADC_LevelOutOfWindowCallback()</h1><p><code>HAL_ADC_LevelOutOfWindowCallback()</code> 是一个回调函数，当 ADC 转换结果超出了模拟看门狗的设置窗口时调用。模拟看门狗（Analog Watchdog，简称 AWD）功能可以用来监测 ADC 输入信号是否超出了预设的上限或下限。当 ADC 转换结果落在这个“窗口”之外时，触发此回调。</p><h1 id="HAL-ADC-ErrorCallback"><a href="#HAL-ADC-ErrorCallback" class="headerlink" title="HAL_ADC_ErrorCallback()"></a>HAL_ADC_ErrorCallback()</h1><p><code>HAL_ADC_ErrorCallback()</code> 是一个回调函数，当 <strong>ADC 出现错误时调用</strong>。常见的错误包括 ADC 过载、硬件故障等。此回调函数可以帮助你在 ADC 发生错误时进行适当的错误处理，如重启 ADC、输出错误信息或执行错误恢复操作。</p><h1 id="HAL-ADC-ConfigChannel"><a href="#HAL-ADC-ConfigChannel" class="headerlink" title="HAL_ADC_ConfigChannel()"></a>HAL_ADC_ConfigChannel()</h1><p><code>HAL_ADC_ConfigChannel()</code> 用于配置 ADC 的通道。每个 ADC 通道代表一个输入源，例如模拟信号、温度传感器或外部引脚输入。通过此函数，你可以配置 ADC 将采样的信号从哪一个通道获取，并指定该通道的其他参数。</p><h1 id="HAL-ADC-AnalogWDGConfig"><a href="#HAL-ADC-AnalogWDGConfig" class="headerlink" title="HAL_ADC_AnalogWDGConfig()"></a>HAL_ADC_AnalogWDGConfig()</h1><p><code>HAL_ADC_AnalogWDGConfig()</code> 用于配置 ADC 的模拟看门狗（Analog Watchdog，AWD）功能。模拟看门狗功能用于检测 ADC 输入信号是否超出设定的预定范围。通过此功能，可以监测输入信号是否超出了允许的最大值或最小值，并在超出时触发报警事件。</p><h1 id="HAL-ADC-GetState"><a href="#HAL-ADC-GetState" class="headerlink" title="HAL_ADC_GetState()"></a>HAL_ADC_GetState()</h1><p><code>HAL_ADC_GetState()</code> 用于获取当前 ADC 外设的状态。这些状态可以帮助你了解 ADC 的工作进程，并确定是否可以开始下一次转换或是否存在其他问题。</p><h1 id="HAL-ADC-GetError"><a href="#HAL-ADC-GetError" class="headerlink" title="HAL_ADC_GetError()"></a>HAL_ADC_GetError()</h1><p><code>HAL_ADC_GetError()</code> 用于获取当前 ADC 外设的错误状态。当 ADC 操作失败时，调用此函数可以帮助你诊断问题。</p>]]></content>
      
      
      <categories>
          
          <category> 外设 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 外设 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread-PIN</title>
      <link href="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/"/>
      <url>/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/</url>
      
        <content type="html"><![CDATA[<h2 id="1-设置引脚模式-rt-pin-mode"><a href="#1-设置引脚模式-rt-pin-mode" class="headerlink" title="1. 设置引脚模式 rt_pin_mode()"></a>1. 设置引脚模式 rt_pin_mode()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/1.png" alt="image-20250219155159103"> </p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">PIN_MODE_OUTPUT</td><td align="center">输出</td></tr><tr><td align="center">PIN_MODE_INPUT</td><td align="center">输入</td></tr><tr><td align="center">PIN_MODE_INPUT_PULLUP</td><td align="center">上拉输入</td></tr><tr><td align="center">PIN_MODE_INPUT_PULLDOWN</td><td align="center">下拉输入</td></tr><tr><td align="center">PIN_MODE_OUTPUT_OD</td><td align="center">开漏输出</td></tr></tbody></table><h2 id="2-设置引脚电平-rt-pin-write"><a href="#2-设置引脚电平-rt-pin-write" class="headerlink" title="2. 设置引脚电平 rt_pin_write()"></a>2. 设置引脚电平 rt_pin_write()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/2.png" alt="image-20250219155633545"></p><h2 id="3-读取引脚电平-rt-pin-read"><a href="#3-读取引脚电平-rt-pin-read" class="headerlink" title="3. 读取引脚电平 rt_pin_read ()"></a>3. 读取引脚电平 rt_pin_read ()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/image-20250219161129046.png" alt="image-20250219161129046"></p><h2 id="4-绑定引脚中断回调函数-rt-pin-attach-irq"><a href="#4-绑定引脚中断回调函数-rt-pin-attach-irq" class="headerlink" title="4. 绑定引脚中断回调函数 rt_pin_attach_irq ()"></a>4. 绑定引脚中断回调函数 rt_pin_attach_irq ()</h2><h2 id="5-脱离引脚中断回调函数-rt-pin-detach-irq"><a href="#5-脱离引脚中断回调函数-rt-pin-detach-irq" class="headerlink" title="5.脱离引脚中断回调函数 rt_pin_detach_irq ()"></a>5.脱离引脚中断回调函数 rt_pin_detach_irq ()</h2><h2 id="6-使能-屏蔽引脚中断-rt-pin-irq-enable"><a href="#6-使能-屏蔽引脚中断-rt-pin-irq-enable" class="headerlink" title="6. 使能 &#x2F; 屏蔽引脚中断 rt_pin_irq_enable ()"></a>6. 使能 &#x2F; 屏蔽引脚中断 rt_pin_irq_enable ()</h2>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread-IO</title>
      <link href="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/"/>
      <url>/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/</url>
      
        <content type="html"><![CDATA[<h1 id="一、drv-gpio-c"><a href="#一、drv-gpio-c" class="headerlink" title="一、drv_gpio.c"></a>一、drv_gpio.c</h1><h1 id="1-1在drv-common-c中调用rt-hw-pin-init-函数"><a href="#1-1在drv-common-c中调用rt-hw-pin-init-函数" class="headerlink" title="1.1在drv_common,c中调用rt_hw_pin_init()函数"></a>1.1在drv_common,c中调用rt_hw_pin_init()函数</h1><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/1.png" alt="image-20250217174741243"></p><h2 id="1-2-rt-hw-pin-init"><a href="#1-2-rt-hw-pin-init" class="headerlink" title="1.2 rt_hw_pin_init()"></a>1.2 rt_hw_pin_init()</h2><p>启用 STM32 微控制器中 <strong>GPIOA</strong> 外设的时钟</p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/2.png" alt="image-20250217175841655"></p><h1 id="1-3-pins"><a href="#1-3-pins" class="headerlink" title="1.3 pins[]"></a>1.3 pins[]</h1><p><strong>为每个pin定义编号</strong></p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/3.png" alt="image-20250217181636459"></p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/4.png" alt="image-20250217181926120"></p><p>这个宏会创建一个结构体，结构体中包含了三个成员：</p><ul><li><code>index</code>：通常是一个标识符或索引，用于标识该引脚的具体位置。</li><li><code>GPIO##gpio</code>：指定了 GPIO 端口（如 <code>GPIOA</code>、<code>GPIOB</code> 等）。</li><li><code>GPIO_PIN_##gpio_index</code>：指定了具体的引脚（如 <code>GPIO_PIN_0</code>、<code>GPIO_PIN_1</code> 等）。</li></ul><h1 id="stm32-pin-write"><a href="#stm32-pin-write" class="headerlink" title="stm32_pin_write"></a>stm32_pin_write</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stm32_pin_write</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin, <span class="type">rt_base_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_WritePin(index-&gt;gpio, index-&gt;pin, (GPIO_PinState)value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stm32-pin-read"><a href="#stm32-pin-read" class="headerlink" title="stm32_pin_read"></a>stm32_pin_read</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stm32_pin_read</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line"></span><br><span class="line">    value = PIN_LOW;</span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value = HAL_GPIO_ReadPin(index-&gt;gpio, index-&gt;pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stm32-pin-mode"><a href="#stm32-pin-mode" class="headerlink" title="stm32_pin_mode"></a>stm32_pin_mode</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">atic <span class="type">void</span> <span class="title function_">stm32_pin_mode</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin, <span class="type">rt_base_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure GPIO_InitStructure */</span></span><br><span class="line">    GPIO_InitStruct.Pin = index-&gt;pin;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == PIN_MODE_OUTPUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* output setting */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: not pull. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT_PULLUP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: pull up. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT_PULLDOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: pull down. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_PULLDOWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_OUTPUT_OD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* output setting: od. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_Init(index-&gt;gpio, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread-2-时钟管理</title>
      <link href="/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、时钟节拍"><a href="#一、时钟节拍" class="headerlink" title="一、时钟节拍"></a>一、时钟节拍</h1><ul><li><p>时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的实时响应越快，但是系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。</p></li><li><p>时钟节拍的长度可以根据 RT_TICK_PER_SECOND 的定义来调整，等于 1&#x2F;RT_TICK_PER_SECOND 秒。</p><p>  <img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/1.png" alt="image-20250217164837198"></p></li></ul><h1 id="二、时钟节拍的实现方式"><a href="#二、时钟节拍的实现方式" class="headerlink" title="二、时钟节拍的实现方式"></a>二、时钟节拍的实现方式</h1><p>中断触发模式的硬件定时器产生，当中断到来时，将调用一次：void rt_tick_increase(void)，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 进入中断 */</span></span><br><span class="line">    rt_interrupt_enter();</span><br><span class="line">    ……</span><br><span class="line">    rt_tick_increase();</span><br><span class="line">    <span class="comment">/* 退出中断 */</span></span><br><span class="line">    rt_interrupt_leave();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中断函数中调用 rt_tick_increase() 对全局变量 rt_tick 进行自加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_tick_increase</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 全局变量 rt_tick 自加 */</span></span><br><span class="line">    ++ rt_tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查时间片 */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    -- thread-&gt;remaining_tick;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;remaining_tick == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 重新赋初值 */</span></span><br><span class="line">        thread-&gt;remaining_tick = thread-&gt;init_tick;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 线程挂起 */</span></span><br><span class="line">        rt_thread_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查定时器 */</span></span><br><span class="line">    rt_timer_check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rt_tick 的值表示了系统<strong>从启动开始</strong>总共经过的时钟节拍数，即<strong>系统时间</strong></p><p>每经过一个时钟节拍时，都会检查当前线程的时间片是否用完，以及是否有定时器超时。</p><h1 id="三、获取时钟节拍"><a href="#三、获取时钟节拍" class="headerlink" title="三、获取时钟节拍"></a>三、获取时钟节拍</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_tick_t</span> <span class="title function_">rt_tick_get</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="四、定时器管理"><a href="#四、定时器管理" class="headerlink" title="四、定时器管理"></a>四、定时器管理</h1><ul><li><strong>硬件定时器</strong>是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</li><li><strong>软件定时器</strong>是由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</li><li>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍，例如一个 OS Tick 是 10ms，那么上层软件定时器只能是 10ms，20ms，100ms 等，而不能定时为 15ms。RT-Thread 的定时器也基于系统的节拍，提供了基于节拍整数倍的定时能力。</li></ul><h1 id="五、RT-Thread定时器介绍"><a href="#五、RT-Thread定时器介绍" class="headerlink" title="五、RT-Thread定时器介绍"></a>五、RT-Thread定时器介绍</h1><p>RT-Thread 的定时器提供两类定时器机制：</p><ul><li>第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。</li><li>第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止，否则将永远持续执行下去。</li></ul><p>超时函数执行时所处的上下文环境，RT-Thread 的定时器可以分为 HARD_TIMER 模式与 SOFT_TIMER 模式</p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/2.png" alt="定时器上下文环境"></p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread-1-线程管理</title>
      <link href="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、线程栈"><a href="#一、线程栈" class="headerlink" title="一、线程栈"></a>一、线程栈</h1><ul><li>RT-Thread 线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复。</li><li>线程栈还用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；函数中局部变量初始时从寄存器中分配（ARM 架构），当这个函数再调用另一个函数时，这些局部变量将放入栈中。</li></ul><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/1.png" alt="线程栈 (ARM)"></p><ul><li>线程栈大小可以这样设定，对于资源相对较大的 MCU，可以适当设计较大的线程栈；也可以在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 <strong>FinSH</strong> 中用 <strong>list_thread</strong> 命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的<strong>最大栈深度</strong>，而后加上适当的余量形成最终的线程栈大小，最后对栈空间大小加以修改。</li></ul><h1 id="二、线程状态"><a href="#二、线程状态" class="headerlink" title="二、线程状态"></a>二、线程状态</h1><table><thead><tr><th>状态</th><th align="center">描述</th></tr></thead><tbody><tr><td>初始状态</td><td align="center">当线程刚开始创建还没开始运行时就处于初始状态；在初始状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td></tr><tr><td>就绪状态</td><td align="center">在就绪状态下，线程按照优先级排队，等待被执行；一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td></tr><tr><td>运行状态</td><td align="center">线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；在多核系统中，可能就不止这一个线程处于运行状态。此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td></tr><tr><td>挂起状态</td><td align="center">也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。在挂起状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td></tr><tr><td>关闭状态</td><td align="center">当线程运行结束时将处于关闭状态。关闭状态的线程不参与线程的调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td></tr></tbody></table><h1 id="三、线程优先级"><a href="#三、线程优先级" class="headerlink" title="三、线程优先级"></a>三、线程优先级</h1><p>RT-Thread 最大支持 256 个线程优先级 (0~255)，<strong>数值越小的优先级越高</strong>，0 为最高优先级。在一些资源比较紧张的系统中，可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置；对于 <strong>ARM Cortex-M</strong> 系列，<strong>普遍采用 32 个优先级</strong>。最低优先级<strong>默认分配给空闲线程</strong>使用，用户一般不使用。在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将<strong>立刻被换出</strong>，高优先级线程抢占处理器运行。(YDW：并不会等到线程此次允许结束)</p><h1 id="四、时间片"><a href="#四、时间片" class="headerlink" title="四、时间片"></a>四、时间片</h1><ul><li><p>每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效</p></li><li><p>时间片起到约束线程单次运行时长的作用，其单位是一个系统节拍（OS Tick）</p></li></ul><h1 id="五、线程的入口函数"><a href="#五、线程的入口函数" class="headerlink" title="五、线程的入口函数"></a>五、线程的入口函数</h1><p><strong>无限循环模式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* paramenter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 等待事件的发生 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对事件进行服务、进行处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-<strong>顺序执行或有限次循环模式：</strong></p><ul><li><strong>在执行完毕后，线程将被系统自动删除。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 处理事务 #1 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #2 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、线程错误码"><a href="#六、线程错误码" class="headerlink" title="六、线程错误码"></a>六、线程错误码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EOK           0 <span class="comment">/* 无错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ERROR         1 <span class="comment">/* 普通错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ETIMEOUT      2 <span class="comment">/* 超时错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EFULL         3 <span class="comment">/* 资源已满     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EEMPTY        4 <span class="comment">/* 无资源     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOMEM        5 <span class="comment">/* 无内存     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOSYS        6 <span class="comment">/* 系统不支持     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EBUSY         7 <span class="comment">/* 系统忙     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EIO           8 <span class="comment">/* IO 错误       */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINTR         9 <span class="comment">/* 中断系统调用   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINVAL       10 <span class="comment">/* 非法参数      */</span></span></span><br></pre></td></tr></table></figure><h1 id="七、线程状态切换"><a href="#七、线程状态切换" class="headerlink" title="七、线程状态切换"></a>七、线程状态切换</h1><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/2.png" alt="线程状态转换图"></p><ul><li>线程通过调用函数 rt_thread_create&#x2F;init() 进入到初始状态（RT_THREAD_INIT）；初始状态的线程通过调用函数 rt_thread_startup() 进入到就绪状态（RT_THREAD_READY）；</li><li>就绪状态的线程被调度器调度后进入运行状态（RT_THREAD_RUNNING）；</li><li>当处于运行状态的线程调用 rt_thread_delay()，rt_sem_take()，rt_mutex_take()，rt_mb_recv() 等函数或者获取不到资源时，将进入到挂起状态（RT_THREAD_SUSPEND）；</li><li>处于挂起状态的线程，如果等待超时依然未能获得资源或由于其他线程释放了资源，那么它将返回到就绪状态。挂起状态的线程，如果调用 rt_thread_delete&#x2F;detach() 函数，将更改为关闭状态（RT_THREAD_CLOSE）；</li><li>而运行状态的线程，如果运行结束，就会在线程的最后部分执行 rt_thread_exit() 函数，将状态更改为关闭状态。</li></ul><h1 id="八、系统线程"><a href="#八、系统线程" class="headerlink" title="八、系统线程"></a>八、系统线程</h1><p><strong>在 RT-Thread 内核中的系统线程有空闲线程和主线程。</strong></p><h1 id="九、空闲线程"><a href="#九、空闲线程" class="headerlink" title="九、空闲线程"></a>九、空闲线程</h1><ul><li>空闲线程状态永远为就绪态，当系统中无其他就绪线程存在时，调度器将调度到空闲线程，它通常是一个<strong>死循环</strong>，且<strong>永远不能被挂起</strong>。</li><li>若某线程运行完毕，系统将<strong>自动删除线程</strong>：自动执行 rt_thread_exit() 函数，先将该线程从系统<strong>就绪队列中删除</strong>，再将该线程的状态更改为<strong>关闭状态</strong>，不再参与系统调度，然后挂入 rt_thread_defunct <strong>僵尸队列</strong>（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</li><li>空闲线程也提供了接口来运行用户设置的<strong>钩子函</strong>数，在空闲线程运行时会调用该钩子函数，适合处理<strong>功耗管理</strong>、看门狗喂狗等工作。空闲线程必须有得到执行的机会，即其他线程不允许一直while(1)死卡，必须调用具有阻塞性质的函数；<strong>否则例如线程删除、回收等操作将无法得到正确执行。</strong></li></ul><h1 id="十、主线程"><a href="#十、主线程" class="headerlink" title="十、主线程"></a>十、主线程</h1><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/3.png" alt="主线程调用过程"></p><h1 id="十一、创建和删除线程"><a href="#十一、创建和删除线程" class="headerlink" title="十一、创建和删除线程"></a>十一、创建和删除线程</h1><ul><li>动态创建</li></ul><p><strong>分配出来的栈空间是按照 rtconfig.h 中配置的 RT_ALIGN_SIZE 方式对齐</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter),</span></span><br><span class="line"><span class="params">                            <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint8_t</span> priority,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>thread</td><td>线程创建成功，返回线程句柄</td></tr><tr><td>RT_NULL</td><td>线程创建失败</td></tr></tbody></table><ul><li>删除</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delete</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li>用 rt_thread_delete() 函数删除线程接口，仅仅是把相应的线程状态更改为 RT_THREAD_CLOSE 状态，然后放入到 rt_thread_defunct 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作</li></ul><p><strong>仅在使能了系统动态堆时才有效</strong></p><h1 id="十二、初始化和脱离线程"><a href="#十二、初始化和脱离线程" class="headerlink" title="十二、初始化和脱离线程"></a>十二、初始化和脱离线程</h1><ul><li>静态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_init</span><span class="params">(<span class="keyword">struct</span> rt_thread* thread,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter), <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>* stack_start, <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span> priority, <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td></tr><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_start</td><td>线程栈起始地址</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程创建成功</td></tr><tr><td>-RT_ERROR</td><td>线程创建失败</td></tr></tbody></table><ul><li>脱离</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_detach</span> <span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p><strong>线程本身不应调用这个接口脱离线程本身</strong></p><h1 id="十三、启动线程"><a href="#十三、启动线程" class="headerlink" title="十三、启动线程"></a>十三、启动线程</h1><p><strong>创建（初始化）的线程状态处于初始状态，并未进入就绪线程的调度队列，我们可以在线程初始化 &#x2F; 创建成功后调用下面的函数接口让该线程进入就绪态：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_startup</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h1 id="十四、获得当前线程"><a href="#十四、获得当前线程" class="headerlink" title="十四、获得当前线程"></a>十四、获得当前线程</h1><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="十五、使线程让出CUP资源"><a href="#十五、使线程让出CUP资源" class="headerlink" title="十五、使线程让出CUP资源"></a>十五、使线程让出CUP资源</h1><p>当前线程的时间片用完或者该线程主动要求让出处理器资源时，它将不再占有处理器，调度器会选择相同优先级的下一个线程执行。线程调用这个接口后，这个线程仍然在就绪队列中。线程让出处理器使用下面的函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="十六、线程睡眠"><a href="#十六、线程睡眠" class="headerlink" title="十六、线程睡眠"></a>十六、线程睡眠</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_sleep</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delay</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_mdelay</span><span class="params">(<span class="type">rt_int32_t</span> ms)</span>;</span><br></pre></td></tr></table></figure><h1 id="十七、挂起和恢复线程"><a href="#十七、挂起和恢复线程" class="headerlink" title="十七、挂起和恢复线程"></a>十七、挂起和恢复线程</h1><h1 id="十八、控制线程"><a href="#十八、控制线程" class="headerlink" title="十八、控制线程"></a>十八、控制线程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_control</span><span class="params">(<span class="type">rt_thread_t</span> thread, <span class="type">rt_uint8_t</span> cmd, <span class="type">void</span>* arg)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td>cmd</td><td>指示控制命令</td></tr><tr><td>arg</td><td>控制参数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>控制执行正确</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><ul><li>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</li><li>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</li><li>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 或 rt_thread_detach() 函数调用。</li></ul><h1 id="十九、设置和删除空闲钩子"><a href="#十九、设置和删除空闲钩子" class="headerlink" title="十九、设置和删除空闲钩子"></a>十九、设置和删除空闲钩子</h1><p>可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_delhook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>注：空闲线程是一个线程状态永远为就绪态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，例如 rt_thread_delay()，rt_sem_take() 等可能会导致线程挂起的函数都不能使用。并且，由于 malloc、free 等内存相关的函数内部使用了信号量作为临界区保护，因此在钩子函数内部也不允许调用此类函数！</p><h1 id="二十、设置调度器钩子"><a href="#二十、设置调度器钩子" class="headerlink" title="二十、设置调度器钩子"></a>二十、设置调度器钩子</h1><p>有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_scheduler_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to))</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hook</span><span class="params">(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>from</td><td>表示系统所要切换出的线程控制块指针</td></tr><tr><td>to</td><td>表示系统所要切换到的线程控制块指针</td></tr></tbody></table><p>在这个钩子函数中，基本上不允许调用系统 API</p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread-1-ADC</title>
      <link href="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/"/>
      <url>/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-初始化设备stm32-adc-init"><a href="#一、-初始化设备stm32-adc-init" class="headerlink" title="一、 初始化设备stm32_adc_init()"></a>一、 初始化设备stm32_adc_init()</h1><p>​进行板级初始化</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/1.png" alt="image-20250213213546245"></p><h3 id="1-1定义adc-config数组"><a href="#1-1定义adc-config数组" class="headerlink" title="1.1定义adc_config数组"></a>1.1定义adc_config数组</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/2.png" alt="image-20250213215103492"></p><p>数组中有几个值通过board.h中的宏定义来确定，同时数组中的最后一个元素后面在某些标准下是被允许加逗号的</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/3.png" alt="image-20250213215514039"></p><p>如果打开ADC1和ADC2，那么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc_config[] =&#123;ADC1_CONFIG,ADC3_CONFIG&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-ADC1-CONFIG是什么"><a href="#1-2-ADC1-CONFIG是什么" class="headerlink" title="1.2 ADC1_CONFIG是什么"></a>1.2 ADC1_CONFIG是什么</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/4.png" alt="image-20250213215847418"></p><h3 id="1-3-ADC-HandleTypeDef是什么类型"><a href="#1-3-ADC-HandleTypeDef是什么类型" class="headerlink" title="1.3 ADC_HandleTypeDef是什么类型"></a>1.3 ADC_HandleTypeDef是什么类型</h3><p>是 <strong>STM32 HAL（硬件抽象层）库</strong> 中的一个结构体，用于表示 <strong>ADC（模拟到数字转换器）</strong> 外设的配置和状态</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/5.png" alt="image-20250213221307498"></p><p><strong><code>Instance</code></strong></p><ul><li>类型：<code>ADC_TypeDef *</code></li><li><strong>描述</strong>：指向 ADC 模块寄存器的指针。不同的 STM32 微控制器有多个 ADC 模块（如 <code>ADC1</code>, <code>ADC2</code>, <code>ADC3</code> 等），<code>Instance</code> 用于标识当前操作的是哪个 ADC 模块。</li></ul><p><strong><code>Init</code></strong></p><ul><li><p>类型：<code>ADC_InitTypeDef</code></p></li><li><p>描述</p><p>  ：包含 ADC 初始化配置的结构体。它包含了多个配置选项，如 ADC 时钟、分辨率、数据对齐方式等。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef</span><br></pre></td></tr></table></figure><p>   是一个结构体，通常包括以下字段：</p><ul><li><code>ClockPrescaler</code>：ADC 时钟的预分频器。</li><li><code>Resolution</code>：ADC 分辨率（如 12 位、10 位、8 位）。</li><li><code>DataAlign</code>：数据对齐方式（如左对齐或右对齐）。</li><li><code>ScanConvMode</code>：是否启用扫描模式（多个通道转换）。</li><li><code>ContinuousConvMode</code>：是否启用连续转换模式。</li><li><code>ExternalTrigConv</code>：外部触发类型（如软件触发、定时器触发等）。</li></ul></li></ul><p><strong><code>DMA_Handle</code></strong></p><ul><li>类型：<code>DMA_HandleTypeDef *</code></li><li><strong>描述</strong>：指向 DMA（直接存储器访问）句柄的指针。如果使用 DMA 进行 ADC 数据传输，这个字段指向一个 <code>DMA_HandleTypeDef</code> 结构，用于管理 DMA 的配置。</li></ul><p><strong><code>State</code></strong></p><ul><li>类型：<code>__IO uint32_t *</code></li><li><strong>描述</strong>：指向 ADC 状态的指针。这个字段通常用于存储 ADC 的当前状态，如转换进行中、转换完成等状态信息。</li></ul><p><strong><code>ErrorCode</code></strong></p><ul><li>类型：<code>__IO uint32_t</code></li><li><strong>描述</strong>：存储 ADC 操作过程中发生的错误代码。这可以帮助调试和排查问题，比如发生了什么错误，是否由于配置问题导致操作失败等。</li></ul><h3 id="1-4-启用了几个ADC就定义几个stm32-adc-obj-元素"><a href="#1-4-启用了几个ADC就定义几个stm32-adc-obj-元素" class="headerlink" title="1.4 启用了几个ADC就定义几个stm32_adc_obj[]元素"></a>1.4 启用了几个ADC就定义几个stm32_adc_obj[]元素</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/8.png" alt="image-20250213223809186"></p><h3 id="1-5-ADC-Handler和adc-config是一个类型的变量"><a href="#1-5-ADC-Handler和adc-config是一个类型的变量" class="headerlink" title="1.5 ADC_Handler和adc_config是一个类型的变量"></a>1.5 ADC_Handler和adc_config是一个类型的变量</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/7.png" alt="image-20250213224057191"></p><h3 id="1-6-for循环"><a href="#1-6-for循环" class="headerlink" title="1.6 for循环"></a>1.6 for循环</h3><p>用sizeof判断使用了几个ADC，使用了几个ADC就循环几此</p><p>1.把adc_config赋值给ADC_Hander(因为第6小点)</p><p>2.通过stm32f407xx.h判断是否有这个外设</p><p>3.Instance中存放的名字是ADCx，是ADC几就把几赋值给name_buf[3]</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/6.png" alt="image-20250213222200867"></p><h3 id="1-7-HAL-ADC-Init"><a href="#1-7-HAL-ADC-Init" class="headerlink" title="1.7 HAL_ADC_Init()"></a>1.7 HAL_ADC_Init()</h3><p>1.传入ADC_HandleTypeDef类型的值，初始化ADC</p><p>2.如果返回错误，答应init failed</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/9.png" alt="99e47c9c-0550-49aa-992d-62ec87fad64a"></p><h3 id="1-8-rt-hw-adc-register"><a href="#1-8-rt-hw-adc-register" class="headerlink" title="1.8 rt_hw_adc_register()"></a>1.8 rt_hw_adc_register()</h3><p>用于注册硬件 ADC 的函数，它将 ADC 驱动和硬件抽象层（HAL）关联起来,使得 RT-Thread 可以识别和使用指定的 ADC 外设</p><ul><li><strong>初始化硬件 ADC 驱动</strong>：这个函数将硬件 ADC 外设与 RT-Thread 的设备模型进行注册，使得 RT-Thread 可以管理和访问硬件 ADC。</li><li><strong>设备注册</strong>：它会在 RT-Thread 的设备模型中创建一个 ADC 设备对象，从而让系统能够通过统一的接口（例如 <code>read()</code>、<code>write()</code> 等）来操作硬件。</li><li><strong>设备抽象层支持</strong>：通过设备抽象层，用户可以通过设备操作接口（如打开设备、关闭设备、读取数据等）与硬件 ADC 进行交互。</li></ul><h3 id="1-9rt-adc-device-是用于表示一个-ADC-设备-的结构体"><a href="#1-9rt-adc-device-是用于表示一个-ADC-设备-的结构体" class="headerlink" title="1.9rt_adc_device 是用于表示一个 ADC 设备 的结构体"></a>1.9<code>rt_adc_device</code> 是用于表示一个 <strong>ADC 设备</strong> 的结构体</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/10.png" alt="image-20250213230813789"></p><h3 id="1-10-struct-rt-adc-ops"><a href="#1-10-struct-rt-adc-ops" class="headerlink" title="1.10 struct rt_adc_ops"></a>1.10 struct rt_adc_ops</h3><p> RT-Thread 中与 <strong>ADC（模拟到数字转换器）</strong> 设备交互的操作函数结构体，它包含了一组函数指针</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/13.png" alt="image-20250213231324141"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/11.png" alt="image-20250213231110666"></p><h1 id="二、查找ADC设备rt-device-find"><a href="#二、查找ADC设备rt-device-find" class="headerlink" title="二、查找ADC设备rt_device_find()"></a>二、查找ADC设备rt_device_find()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_NAME        <span class="string">&quot;adc1&quot;</span>  <span class="comment">/* ADC 设备名称 */</span></span></span><br><span class="line"><span class="type">rt_adc_device_t</span> adc_dev;            <span class="comment">/* ADC 设备句柄 */</span></span><br><span class="line"><span class="comment">/* 查找设备 */</span></span><br><span class="line">adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br></pre></td></tr></table></figure><h1 id="三、使能ADC通道rt-adc-enable（）"><a href="#三、使能ADC通道rt-adc-enable（）" class="headerlink" title="三、使能ADC通道rt_adc_enable（）"></a>三、使能ADC通道rt_adc_enable（）</h1><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/18.png" alt="image-20250218192237456"></p><h3 id="3-1-stm32-adc-enabled"><a href="#3-1-stm32-adc-enabled" class="headerlink" title="3.1 stm32_adc_enabled"></a>3.1 stm32_adc_enabled</h3><p><strong>rt_adc_enable()<strong>中调用了硬件驱动层函数</strong>stm32_adc_enabled()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/19.png" alt="image-20250218192444206"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/12.png" alt="image-20250218143021553"></p><ul><li>传入<strong>device</strong>和<strong>enabled</strong>参数，此处的<strong>channel</strong>没用到</li></ul><h1 id="四、读取通道值rt-adc-read（）"><a href="#四、读取通道值rt-adc-read（）" class="headerlink" title="四、读取通道值rt_adc_read（）"></a>四、读取通道值rt_adc_read（）</h1><p>获取ADC通道的值，存入<strong>value</strong>变量中</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/23.png" alt="image-20250218193225562"></p><h3 id="4-1-stm32-get-adc-value"><a href="#4-1-stm32-get-adc-value" class="headerlink" title="4.1 stm32_get_adc_value()"></a>4.1 stm32_get_adc_value()</h3><p><strong>rt_adc_read()<strong>中调用了硬件驱动层函数</strong>1stm32_get_adc_value()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/20.png" alt="image-20250218193118064"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/16.png" alt="image-20250218193915303"></p><h3 id="4-2-stm32-adc-get-channel"><a href="#4-2-stm32-adc-get-channel" class="headerlink" title="4.2 stm32_adc_get_channel()"></a>4.2 stm32_adc_get_channel()</h3><p>将通道的数字转换成ADC通道的地址</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/14.png" alt="image-20250218143654896"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/15.png" alt="image-20250218143716406"></p><h1 id="五、-关闭ADC通道rt-adc-disable"><a href="#五、-关闭ADC通道rt-adc-disable" class="headerlink" title="五、 关闭ADC通道rt_adc_disable()"></a>五、 关闭ADC通道rt_adc_disable()</h1><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/21..png" alt="image-20250218194154075"></p><h3 id="5-1-stm32-adc-enabled"><a href="#5-1-stm32-adc-enabled" class="headerlink" title="5.1 stm32_adc_enabled()"></a>5.1 stm32_adc_enabled()</h3><p><strong>rt_adc_disable()<strong>中调用了硬件驱动层函数</strong>stm32_adc_enabled()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/22.png" alt="image-20250218200837908"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_NAME        <span class="string">&quot;adc1&quot;</span>  <span class="comment">/* ADC 设备名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_CHANNEL     5       <span class="comment">/* ADC 通道 */</span></span></span><br><span class="line"><span class="type">rt_adc_device_t</span> adc_dev;            <span class="comment">/* ADC 设备句柄 */</span></span><br><span class="line"><span class="type">rt_uint32_t</span> value；</span><br><span class="line"><span class="comment">/* 查找设备 */</span></span><br><span class="line">adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br><span class="line"><span class="comment">/* 使能设备 */</span></span><br><span class="line">rt_adc_enable(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"><span class="comment">/* 读取采样值 */</span></span><br><span class="line">value = rt_adc_read(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"><span class="comment">/* 转换为对应电压值 */</span></span><br><span class="line">vol = value * REFER_VOLTAGE / CONVERT_BITS;</span><br><span class="line">rt_kprintf(<span class="string">&quot;the voltage is :%d.%02d \n&quot;</span>, vol / <span class="number">100</span>, vol % <span class="number">100</span>);</span><br><span class="line"><span class="comment">/* 关闭通道 */</span></span><br><span class="line">rt_adc_disable(adc_dev, ADC_DEV_CHANNEL);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread-0-启动流程</title>
      <link href="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、startup-stm32f407xx-S"><a href="#一、startup-stm32f407xx-S" class="headerlink" title="一、startup_stm32f407xx.S"></a>一、startup_stm32f407xx.S</h1><p>系统进入汇编文件</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image-20250215165008148"></p><p><strong>RT-Thread使用的是GCC</strong></p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/rtt_startup.png" alt="启动流程"></p><h1 id="二、不同编译器的启动函数"><a href="#二、不同编译器的启动函数" class="headerlink" title="二、不同编译器的启动函数"></a>二、不同编译器的启动函数</h1><p>调用stm32f407_demo3\rt-thread\src\components.c中的$Sub$$main()</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image-20250215223923007"></p><h1 id="三、调用rtthread-startup-void"><a href="#三、调用rtthread-startup-void" class="headerlink" title="三、调用rtthread_startup(void)"></a>三、调用rtthread_startup(void)</h1><p>在stm32f407_demo3\rt-thread\src\components.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rtthread_startup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 禁用了所有中断 */</span></span><br><span class="line">    rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* 执行板级支持包（BSP）初始化 </span></span><br><span class="line"><span class="comment">       包括配置硬件、系统时钟、外设初始化等 */</span></span><br><span class="line">    rt_hw_board_init();</span><br><span class="line"> <span class="comment">/* 打印 RT-Thread 操作系统的版本信息 */</span></span><br><span class="line">    rt_show_version();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的定时器子系统 */</span></span><br><span class="line">    rt_system_timer_init();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的调度器 */</span></span><br><span class="line">    rt_system_scheduler_init();</span><br><span class="line"><span class="comment">/* 如果启用了信号系统 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SIGNALS</span></span><br><span class="line">    <span class="comment">/* 初始化信号系统 */</span></span><br><span class="line">    rt_system_signal_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 创建应用任务、初始化外设 */</span></span><br><span class="line">    rt_application_init();</span><br><span class="line">    <span class="comment">/* 初始化定时器线程 */</span></span><br><span class="line">    rt_system_timer_thread_init();</span><br><span class="line">    <span class="comment">/* 初始化空闲线程 */</span></span><br><span class="line">    rt_thread_idle_init();</span><br><span class="line"><span class="comment">/* 如果启用了 SMP（对称多处理） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SMP</span></span><br><span class="line">    <span class="comment">/* 进行多核处理器的初始化和同步 */</span></span><br><span class="line">    rt_hw_spin_lock(&amp;_cpus_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*RT_USING_SMP*/</span></span></span><br><span class="line">    <span class="comment">/* 开始任务调度 */</span></span><br><span class="line">    rt_system_scheduler_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* never reach here */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1rt-hw-board-init和rt-application-init的-外设初始化的不同"><a href="#3-1rt-hw-board-init和rt-application-init的-外设初始化的不同" class="headerlink" title="3.1rt_hw_board_init和rt_application_init的 外设初始化的不同"></a>3.1rt_hw_board_init和rt_application_init的 外设初始化的不同</h2><ul><li><strong>rt_hw_board_init</strong></li></ul><p><strong>硬件初始化</strong>：<em><strong>初始化硬件资源</strong></em>，如 GPIO、串口、SPI、I2C、PWM、ADC、定时器等。</p><p><strong>系统时钟配置</strong>：配置系统时钟、外设时钟以及 PLL（锁相环）等，确保系统和外设运行在合适的频率下。</p><p><strong>内存初始化</strong>：配置堆栈、堆内存和静态内存区域，确保系统资源可用。</p><p><strong>中断配置</strong>：初始化中断控制器，并为特定外设启用中断。</p><p><strong>启动引导程序</strong>：执行系统初始化，如配置时钟源、初始化硬件外设等，通常会包括一个初始化阶段的启动代码。</p><p><strong>设备驱动注册</strong>：为基础硬件外设（如 UART、SPI、I2C 等）注册驱动，使操作系统能够访问这些外设。</p><ul><li><strong>rt_application_init</strong></li></ul><p><strong>创建应用任务</strong>：创建系统中的应用任务，例如数据采集任务、处理任务等。</p><p><strong>初始化外设</strong>：在 <strong>应用层</strong> 对外设进行更高层次的初始化。例如，在硬件初始化后，可能会初始化一些<em><strong>外设的具体参数</strong></em>，如设置 ADC 采样周期、配置传感器等。</p><p><strong>启动应用程序逻辑</strong>：进行传感器数据采集、通信协议的初始化、数据处理等应用相关的工作。</p><p><strong>任务调度和资源管理</strong>：创建并调度多个任务，管理应用程序层的资源。</p><h2 id="3-2rt-hw-board-init"><a href="#3-2rt-hw-board-init" class="headerlink" title="3.2rt_hw_board_init()"></a>3.2rt_hw_board_init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RT_WEAK <span class="type">void</span> <span class="title function_">rt_hw_board_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Heap initialization */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_HEAP)</span></span><br><span class="line">    rt_system_heap_init((<span class="type">void</span> *) HEAP_BEGIN, (<span class="type">void</span> *) HEAP_END);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 时钟源初始化，配置 MCU 的时钟系统，设置系统时钟、外设时钟 */</span></span><br><span class="line">    hw_board_init(BSP_CLOCK_SOURCE, BSP_CLOCK_SOURCE_FREQ_MHZ, BSP_CLOCK_SYSTEM_FREQ_MHZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置控制台设备。通常，这意味着将输出通过串口或其他通信接口进行调试输出。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_DEVICE) &amp;&amp; defined(RT_USING_CONSOLE)</span></span><br><span class="line">    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 始化板级硬件组件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_COMPONENTS_INIT</span></span><br><span class="line">    rt_components_board_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1hw-board-init"><a href="#3-2-1hw-board-init" class="headerlink" title="3.2.1hw_board_init()"></a>3.2.1hw_board_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">oid <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rt_hw_systick_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clk_init</span><span class="params">(<span class="type">char</span> *clk_source, <span class="type">int</span> source_freq, <span class="type">int</span> target_freq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableICache</span></span><br><span class="line">    <span class="comment">/* 开启指令缓存，用于加速程序的指令获取。*/</span></span><br><span class="line">    SCB_EnableICache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableDCache</span></span><br><span class="line">    <span class="comment">/* 开启数据缓存，用于加速数据存取。*/</span></span><br><span class="line">    SCB_EnableDCache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 HAL 库需要的硬件资源，例如时钟配置、外设初始化等 */</span></span><br><span class="line">    HAL_Init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器清零，开启全局中断 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 初始化系统时钟 */</span></span><br><span class="line">    clk_init(clock_src, clock_src_freq, clock_target_freq);</span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器设置为 1，禁止全局中断。确保时钟配置的过程中不会受到中断的干扰 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 初始化 SysTick 定时器 */</span></span><br><span class="line">    rt_hw_systick_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化与硬件引脚相关的驱动（如 GPIO 控制）。 </span></span><br><span class="line"><span class="comment">       初始化所有的通用输入输出引脚，设置引脚模式、方向、输出类型等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_PIN</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_pin_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_pin_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 USART 驱动 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SERIAL</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_usart_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image-20250215174007724"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 计算定义了几个串口，通过串口配置结构体的总大小/每个结构体的大小来计算*/</span></span><br><span class="line">    <span class="type">rt_size_t</span> obj_num = <span class="keyword">sizeof</span>(uart_obj) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stm32_uart);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_configure</span> <span class="title">config</span> =</span> RT_SERIAL_CONFIG_DEFAULT;</span><br><span class="line">    <span class="type">rt_err_t</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stm32_uart_get_dma_config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_obj[i].config = &amp;uart_config[i];</span><br><span class="line">        uart_obj[i].serial.ops    = &amp;stm32_uart_ops;</span><br><span class="line">        uart_obj[i].serial.config = config;</span><br><span class="line">        <span class="comment">/* 用于注册串口设备，将串口设备与操作系统的设备管理系统连接起来，使得串口设备能够被操作系统识别和管理</span></span><br><span class="line"><span class="comment">        register ----  注册*/</span></span><br><span class="line">        result = rt_hw_serial_register(&amp;uart_obj[i].serial, uart_obj[i].config-&gt;name,</span><br><span class="line">                                       RT_DEVICE_FLAG_RDWR</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_RX</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_TX</span><br><span class="line">                                       | uart_obj[i].uart_dma_flag</span><br><span class="line">                                       , <span class="literal">NULL</span>);</span><br><span class="line">        RT_ASSERT(result == RT_EOK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image-20250215174346247"></p><h2 id="3-3-rt-show-version-void"><a href="#3-3-rt-show-version-void" class="headerlink" title="3.3 rt_show_version(void)"></a>3.3 rt_show_version(void)</h2><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image-20250215224815579"></p><h2 id="3-4-rt-application-init"><a href="#3-4-rt-application-init" class="headerlink" title="3.4 rt_application_init()"></a>3.4 rt_application_init()</h2><p>创建main()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image-20250215230134023"></p><h2 id="3-5-rt-system-timer-thread-init"><a href="#3-5-rt-system-timer-thread-init" class="headerlink" title="3.5 rt_system_timer_thread_init()"></a>3.5 rt_system_timer_thread_init()</h2><p>创建rt_thread_timer_entry()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image-20250215230248093"></p><h3 id="3-5-1rt-thread-timer-entry"><a href="#3-5-1rt-thread-timer-entry" class="headerlink" title="3.5.1rt_thread_timer_entry()"></a>3.5.1rt_thread_timer_entry()</h3><p>专门用于处理软件定时器的线程函数,定期检查并触发到期的定时器回调。当没有定时器超时时，当前线程会被挂起，直到下一个定时器到期为止。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image-20250215231635484"></p><ul><li>它首先通过 <code>rt_timer_list_next_timeout</code> 获取下一个定时器的超时时间。</li><li>如果没有定时器超时，它会挂起当前线程，直到有定时器超时。</li><li>如果有定时器将要超时，函数会计算剩余时间，并使线程在该时间段内休眠，直到定时器超时。</li><li>每次循环结束时，<code>rt_soft_timer_check()</code> 会检查所有的软件定时器，触发到期的定时器回调。</li></ul><h2 id="3-6-rt-thread-idle-init"><a href="#3-6-rt-thread-idle-init" class="headerlink" title="3.6 rt_thread_idle_init()"></a>3.6 rt_thread_idle_init()</h2><p>初始化 <strong>空闲线程</strong>,是操作系统中的一个特殊线程，它在所有其他任务都没有运行时执行。通常，空闲线程用来降低系统功耗，或者执行一些后台清理任务。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image-20250215232409967"></p><h1 id="四、宏定义函数执行顺序"><a href="#四、宏定义函数执行顺序" class="headerlink" title="四、宏定义函数执行顺序"></a>四、宏定义函数执行顺序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 负责硬件平台的初始化，如时钟配置、外设初始化等。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, <span class="string">&quot;1&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化一些软件模块，可能包括设置一些内核参数、初始化操作系统调度器等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_PREV_EXPORT(fn)            INIT_EXPORT(fn, <span class="string">&quot;2&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化系统中的外设，如串口、GPIO、I2C、SPI 等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, <span class="string">&quot;3&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 包括文件系统（如 FatFS）、网络协议栈（如 lwIP）和其他应用组件的初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, <span class="string">&quot;4&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 涉及外部设备的挂载、环境配置、磁盘挂载等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_ENV_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;5&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 与应用程序级别的初始化相关，如图形界面（rtgui）、应用任务初始化等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;6&quot;</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
          <category> RT-Thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯嵌入式模块使用指北</title>
      <link href="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
      <url>/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><center>本文不涉及原理，只涉及模块的使用<center>南京工业大学浦江学院 22级自动化 姚道文<p>[TOC]</p><h1 id="零、项目新建和LCD底层移植"><a href="#零、项目新建和LCD底层移植" class="headerlink" title="零、项目新建和LCD底层移植"></a>零、项目新建和LCD底层移植</h1><p><strong>链接： <a href="https://www.bilibili.com/video/BV18F4m1K7Ji/?share_source=copy_web&vd_source=63b2bec79fe7e44c34a744e91284ebb2">项目新建和LCD底层移植</a></strong></p><h1 id="一、Systick系统滴答定时器"><a href="#一、Systick系统滴答定时器" class="headerlink" title="一、Systick系统滴答定时器"></a>一、Systick系统滴答定时器</h1><blockquote><p>24位向下递减计数器，0~16,777,216</p><p>CubeMAX会自动将Systick配置成1ms中断的定时器，并将变量uwTick每1ms增加1</p><p>精确延时：HAL_Delay()函数,但会阻塞程序，在while中应控制在10s以内</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序每1ms进入1次该函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_IncTick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、KEY模块"><a href="#二、KEY模块" class="headerlink" title="二、KEY模块"></a><strong>二、KEY模块</strong></h1><h2 id="1-KEY模块CubeMX设置"><a href="#1-KEY模块CubeMX设置" class="headerlink" title="1.KEY模块CubeMX设置"></a>1.KEY模块CubeMX设置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/1.png" alt="img"></p><h2 id="2-KEY模块代码"><a href="#2-KEY模块代码" class="headerlink" title="2.KEY模块代码"></a>2.KEY模块代码</h2><h3 id="1-main-c文件"><a href="#1-main-c文件" class="headerlink" title="1.main.c文件"></a>1.main.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&quot;key.h&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-key-c文件"><a href="#2-key-c文件" class="headerlink" title="2.key.c文件"></a>2.key.c文件</h3><p><strong>宏定义的括号不可省略，想想#define KB1  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)和</strong></p><p><strong>KB1 &#x3D; HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)；有什么区别！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="comment">//没有按下是高电平，按下时低电平</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB1  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)    <span class="comment">//读取KB1电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB2  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1)    <span class="comment">//读取KB2电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB3  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2)    <span class="comment">//读取KB3电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB4  HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)    <span class="comment">//读取KB4电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPORT  KB1 | (KB2&lt;&lt;1) | (KB3&lt;&lt;2) | (KB4&lt;&lt;3) | 0xf0    <span class="comment">//读取的电平数据整合</span></span></span><br><span class="line">                                   </span><br><span class="line">u8 Trg;  <span class="comment">// 全局变量，单次触发</span></span><br><span class="line">u8 Cont;  <span class="comment">// 全局变量，长按</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ReadData = (KEYPORT)^<span class="number">0xff</span>;   <span class="comment">//将读取的电平数据转变成按下数据，按下之后对应位的数据变1</span></span><br><span class="line">  <span class="comment">//u8 ReadData = ~（KEYPORT）;                  //可替代上行代码</span></span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);      <span class="comment">//</span></span><br><span class="line">    Cont = ReadData;                         <span class="comment">//储存这次的按下数据，用于下次的比较</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*   代码解释</span></span><br><span class="line"><span class="comment">u8 ReadData = (KEYPORT)^0xff; //相当于取反操作，将读取的电平数据转变成亮灭数据</span></span><br><span class="line"><span class="comment">    (ReadData ^ Cont)         //将本次读数的按键与上次做对比，位不同则改位为1</span></span><br><span class="line"><span class="comment">    ReadData &amp; (ReadData ^ Cont)//将按下数据与改变情况做对比，位相同为1</span></span><br><span class="line"><span class="comment">*/</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//Example:</span></span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x01</span>)     <span class="comment">//单词触发</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Cont &amp; <span class="number">0x01</span>)    <span class="comment">//长按</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_cnt++;</span><br><span class="line">        <span class="keyword">if</span>(key_cnt == <span class="number">100</span>)    <span class="comment">//每10ms读取一次，此处判断是否长按1s</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt_key = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//do</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u32 keyTick;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(uwTick - keyTick &lt; <span class="number">20</span>) <span class="keyword">return</span>;     <span class="comment">//当小于20ms时，return出函数</span></span><br><span class="line">    keyTick = uwTick;</span><br><span class="line">    Key_Read();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x01</span>)    <span class="comment">//B2单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x02</span>)   <span class="comment">//B2单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x04</span>)   <span class="comment">//B3单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp;<span class="number">0x08</span>)    <span class="comment">//B4单次</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg == <span class="number">0x0C</span>)   <span class="comment">//B3和B4同时按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-key-h文件"><a href="#3-key-h文件" class="headerlink" title="3.key.h文件"></a>3.key.h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span>    <span class="comment">//包含后可使用u8</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 Trg;  <span class="comment">// 全局变量，单次触发</span></span><br><span class="line"><span class="keyword">extern</span> u8 Cont;  <span class="comment">// 全局变量，长按</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//最后必须留一空行</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、LED模块"><a href="#三、LED模块" class="headerlink" title="三、LED模块"></a>三、LED模块</h1><h2 id="1-LED模块CubeMX设置"><a href="#1-LED模块CubeMX设置" class="headerlink" title="1.LED模块CubeMX设置"></a>1.LED模块CubeMX设置</h2><p><strong>LED和LCD引脚冲突，PD2为LED的锁存器</strong></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/2.png" alt="img"></p><h2 id="2-LED模块代码"><a href="#2-LED模块代码" class="headerlink" title="2.LED模块代码"></a>2.LED模块代码</h2><h3 id="1-main-c文件-1"><a href="#1-main-c文件-1" class="headerlink" title="1.main.c文件"></a>1.main.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 LED_DATA ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LED_DATA |= <span class="number">0x01</span>;        <span class="comment">//开灯LED1 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LED_DATA &amp;= ~<span class="number">0x02</span>;       <span class="comment">//灭灯LED2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LED_Control(LED_DATA );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="2-led-c文件（led驱动文件）"><a href="#2-led-c文件（led驱动文件）" class="headerlink" title="2.led.c文件（led驱动文件）"></a>2.led.c文件（led驱动文件）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Control</span><span class="params">(u8 led_ctrl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先熄灭所有LED灯</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOC,<span class="number">0xff00</span>,GPIO_PIN_SET);       <span class="comment">//关闭所有灯，PC8~PC15为8个LED的引脚</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);   <span class="comment">//打开锁存器</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); <span class="comment">//打开锁存器</span></span><br><span class="line">    </span><br><span class="line">    HAL_GPIO_WritePin(GPIOC,led_ctrl &lt;&lt; <span class="number">8</span>,GPIO_PIN_RESET);<span class="comment">//开灯   </span></span><br><span class="line">    <span class="comment">//上一行是：0x01&lt;&lt;8变为0x0100,拉低PC8引脚，LED1点亮</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);   <span class="comment">//打开锁存器</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); <span class="comment">//打开锁存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-led-h文件"><a href="#3-led-h文件" class="headerlink" title="3.led.h文件"></a>3.led.h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span>                     <span class="comment">//包含后可使用u8</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Control</span><span class="params">(u8 led_ctrl)</span>;        <span class="comment">//声明函数</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="comment">//最后必须有一空行</span></span><br></pre></td></tr></table></figure><hr><h1 id="四、LCD模块"><a href="#四、LCD模块" class="headerlink" title="四、LCD模块"></a>四、LCD模块</h1><h3 id="1-LCD模块CubeMX设置"><a href="#1-LCD模块CubeMX设置" class="headerlink" title="1.LCD模块CubeMX设置"></a>1.LCD模块CubeMX设置</h3><p>配置见第<strong>零</strong>章</p><h3 id="2-LCD模块代码"><a href="#2-LCD模块代码" class="headerlink" title="2.LCD模块代码"></a>2.LCD模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏幕大小为20*10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>            <span class="comment">//sprintf需包含此头文件</span></span></span><br><span class="line"></span><br><span class="line">u32 lcdTick;                         <span class="comment">//读取计数器值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(uwTick - lcdTick &lt; <span class="number">200</span>) <span class="keyword">return</span>;   <span class="comment">//LCD每200ms刷新一次</span></span><br><span class="line">    uwTick = lcdTick;</span><br><span class="line"></span><br><span class="line">    u8 display_buf[<span class="number">20</span>];               <span class="comment">//定义缓冲区数组存储数据</span></span><br><span class="line"></span><br><span class="line">    LCD_DisplayStringLine(Line1,(u8*)<span class="string">&quot;        DATA&quot;</span>);   </span><br><span class="line">  <span class="comment">//sprintf函数作用，第二2.3参数与print函数使用相同，第一个参数是printf打印出的值</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   VR37:%4.2fV&quot;</span>,VR37);      </span><br><span class="line">    LCD_DisplayStringLine(Line3,(u8*)display_buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   VR38:%4.2fV&quot;</span>,VR38);</span><br><span class="line">    LCD_DisplayStringLine(Line4,(u8*)display_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   FR39:%05dHZ&quot;</span>,FR39);</span><br><span class="line">    LCD_DisplayStringLine(Line5,(u8*)display_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   FR40:%05dHZ&quot;</span>,FR40);</span><br><span class="line">    LCD_DisplayStringLine(Line6,(u8*)display_buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main（<span class="type">void</span>）</span><br><span class="line">&#123;    </span><br><span class="line">    LCD_Clear(Blue);           <span class="comment">//设置背景颜色</span></span><br><span class="line">    LCD_SetBackColor(Blue);    <span class="comment">//设置字体背景颜色</span></span><br><span class="line">    LCD_SetTextColor(White);   <span class="comment">//设置字体颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                     &#x3D;&#x3D;<strong>以上部分为嵌入式必考模块，务必熟练！！！</strong>&#x3D;&#x3D;</p><p>​                                                                           &#x3D;&#x3D;<strong>以下部分为嵌入式选考模块！！！</strong>&#x3D;&#x3D;</p><hr><h1 id="五、ADC模块"><a href="#五、ADC模块" class="headerlink" title="五、ADC模块"></a>五、ADC模块</h1><h3 id="1-ADC模块CubeMX设置"><a href="#1-ADC模块CubeMX设置" class="headerlink" title="1.ADC模块CubeMX设置"></a>1.ADC模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/3.png" alt="3cd136daad534bd48907ecb751b3fcf9.png"></p><ul><li>设置引脚</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/4.png" alt="efd7f43d3f52414fb7ca6ca3e0aabc63.png"></p><ul><li>设置ADC1</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/5.png" alt="d77692ab112c499eb5fac08be9c285a1.png"></p><ul><li>设置ADC2</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/6.png" alt="e3527d1a94d44343ba5274224aee9663.png"></p><h3 id="2-ADC多路采集模块代码"><a href="#2-ADC多路采集模块代码" class="headerlink" title="2.ADC多路采集模块代码"></a>2.ADC多路采集模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> VR37,VR38,VMCP;      <span class="comment">//定义电压变量</span></span><br><span class="line"><span class="type">float</span> val_R37,val_R38,val_MCP;<span class="comment">//0-4095</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span>                          </span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);                  <span class="comment">//开启adc1_ch5</span></span><br><span class="line">    val_MCP = HAL_ADC_GetValue(&amp;hadc1);     <span class="comment">//获取adc1_ch5的值</span></span><br><span class="line">    VMCP= val_MCP / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VMCP的值</span></span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);                  <span class="comment">//开启adc1_ch11</span></span><br><span class="line">    val_R38 = HAL_ADC_GetValue(&amp;hadc1);     <span class="comment">//获取adc1_ch11的值</span></span><br><span class="line">    VR38= val_R38 / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VR38的值</span></span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc2);                  <span class="comment">//开启adc2</span></span><br><span class="line">    val_R37 = HAL_ADC_GetValue(&amp;hadc2);     <span class="comment">//获取adc2的值</span></span><br><span class="line">    VR37 = val_R37 / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VR37的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ADC数字滤波代码（题目不要求，不用滤波）"><a href="#3-ADC数字滤波代码（题目不要求，不用滤波）" class="headerlink" title="3.ADC数字滤波代码（题目不要求，不用滤波）"></a>3.ADC数字滤波代码（题目不要求，不用滤波）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数字滤波*/</span></span><br><span class="line"><span class="type">float</span> VR37;        <span class="comment">//定义R37电压变量</span></span><br><span class="line">u32 sum_val_R37;   <span class="comment">//电压和变量</span></span><br><span class="line">u8 val_37_buf;     <span class="comment">//每次读出的值</span></span><br><span class="line">u8 adc_cnt = <span class="number">0</span>;    <span class="comment">//计数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    val_37_buf = HAL_ADC_GetValue(&amp;hadc2); <span class="comment">//获取值</span></span><br><span class="line">    sum_val_R37 += VR37;        <span class="comment">//和</span></span><br><span class="line">    adc_cnt++;                  <span class="comment">//次数加</span></span><br><span class="line">    <span class="keyword">if</span>(adc_cnt == <span class="number">10</span>)           <span class="comment">//判断否已经读取10次</span></span><br><span class="line">    &#123;</span><br><span class="line">        VR37 = sum_val_R37 / <span class="number">10.0f</span> / <span class="number">4095.0f</span> * <span class="number">3.3f</span>; <span class="comment">//求电压平均值</span></span><br><span class="line">        sum_val_R37 = <span class="number">0</span>;                             <span class="comment">//求和清零</span></span><br><span class="line">        adc_cnt = <span class="number">0</span>;                                 <span class="comment">//计数清零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历刷新数组中最老的值，求数组的平均值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc2);</span><br><span class="line">    adc2_val = HAL_ADC_GetValue(&amp;hadc2);</span><br><span class="line">    </span><br><span class="line">    ADC_buf[ADC_cnt] = adc2_val / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;      <span class="comment">//储存电压</span></span><br><span class="line">    <span class="keyword">for</span>(cnt=<span class="number">0</span> ;cnt &lt; <span class="number">10</span>;cnt++)                <span class="comment">//电压求和</span></span><br><span class="line">    &#123;</span><br><span class="line">        ADC_sum = ADC_sum + ADC_buf[cnt];    </span><br><span class="line">    &#125;    </span><br><span class="line">        VR37 = ADC_sum / <span class="number">10.0f</span>;              <span class="comment">//电压平均值</span></span><br><span class="line">        ADC_sum = <span class="number">0</span>;                        <span class="comment">//求和清零</span></span><br><span class="line">        ADC_cnt++;                          <span class="comment">//数组下标++</span></span><br><span class="line">    <span class="keyword">if</span>(ADC_cnt == <span class="number">9</span>)                        <span class="comment">//下标范围判断</span></span><br><span class="line">        ADC_cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>学自此可做第十届省赛真题：此届只涉及到了ADC外设。<br>链接:<a href="https://pan.baidu.com/s/1EFhwaQNt6CUTW5c5j0Eaxg">百度网盘：第十届省赛真题</a>  提取码: 6666 </p><h1 id="六、DAC输出模块"><a href="#六、DAC输出模块" class="headerlink" title="六、DAC输出模块"></a>六、DAC输出模块</h1><h2 id="1-DAC双路输出模块CubeMX设置"><a href="#1-DAC双路输出模块CubeMX设置" class="headerlink" title="1.DAC双路输出模块CubeMX设置"></a>1.DAC双路输出模块CubeMX设置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/7.png" alt="bdf317270b204cecb17134591f7d3799.png"></p><p>设置引脚</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/8.png" alt="{3b89c9117fbf41ac8e0bfc75f1446a68.png}"></p><p>DAC1设置</p><h2 id="2-DAC双路输出模块代码"><a href="#2-DAC双路输出模块代码" class="headerlink" title="2.DAC双路输出模块代码"></a>2.DAC双路输出模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">u16 dac_ch1_val,dac_ch2_val;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DAC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    dac_ch1_val = (<span class="number">1.1f</span>/<span class="number">3.3f</span>)*<span class="number">4095.0f</span>;  <span class="comment">//CH1输出1.1V</span></span><br><span class="line">    dac_ch2_val = (<span class="number">2.3f</span>/<span class="number">3.3f</span>)*<span class="number">4095.0f</span>;  <span class="comment">//CH2输出2.3V</span></span><br><span class="line">    </span><br><span class="line">    HAL_DAC_SetValue(&amp;hdac1,DAC_CHANNEL_1,DAC_ALIGN_12B_R,dac_ch1_val);<span class="comment">//设置DAC1，CH1的值</span></span><br><span class="line">    HAL_DAC_Start(&amp;hdac1,DAC_CHANNEL_1);            <span class="comment">//打开DAC1,CH1</span></span><br><span class="line">    </span><br><span class="line">    HAL_DAC_SetValue(&amp;hdac1,DAC_CHANNEL_2,DAC_ALIGN_12B_R,dac_ch2_val);<span class="comment">//设置DAC1，CH2的值</span></span><br><span class="line">    HAL_DAC_Start(&amp;hdac1,DAC_CHANNEL_2);            <span class="comment">//打开DAC1,CH2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="七、PWM捕获模块"><a href="#七、PWM捕获模块" class="headerlink" title="七、PWM捕获模块"></a>七、PWM捕获模块</h1><h3 id="1-PWM双路捕获模块CubeMX设置"><a href="#1-PWM双路捕获模块CubeMX设置" class="headerlink" title="1.PWM双路捕获模块CubeMX设置"></a>1.PWM双路捕获模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/9.png" alt="228e9d0e491a42d5a14bbf9698c3b860.png"></p><p><strong>设置引脚</strong></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/10.png" alt="0dbd4b9828e04a32b829f1d03cadc0df.png"></p><p>设置TIM2</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/11.png" alt="075bf965a7bc46fcaabe7bc08f3720e2.png"></p><p>设置TIM3</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/12.png" alt="ecb7f96fc5fd4cbda32ab62e34ef15e0.png"></p><p>打开TIM中断</p><h3 id="2-PWM双路捕获模块代码"><a href="#2-PWM双路捕获模块代码" class="headerlink" title="2.PWM双路捕获模块代码"></a>2.PWM双路捕获模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> VR37,VR38;      <span class="comment">//定义电压变量</span></span><br><span class="line">u16 FR39,FR40;        <span class="comment">//定义频率变量</span></span><br><span class="line"><span class="type">float</span> DR40,DR39;      <span class="comment">//占空比变量</span></span><br><span class="line"><span class="type">float</span> val_R37,val_R38;<span class="comment">//0-4095</span></span><br><span class="line">u8 PWM_R40_state =<span class="number">0</span>,PWM_R39_state;<span class="comment">//状态改变变量</span></span><br><span class="line">u16 R40_cnt1 = <span class="number">0</span>,R40_cnt2 = <span class="number">0</span>,R39_cnt1 = <span class="number">0</span>,R39_cnt2 = <span class="number">0</span>;    <span class="comment">//存储中断发生时间变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>    <span class="comment">//PWM捕获回调函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)      <span class="comment">//判断TIM2，R40</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(PWM_R40_state == <span class="number">0</span>)      <span class="comment">//第一个上升沿产生</span></span><br><span class="line">        &#123;   </span><br><span class="line">            TIM2-&gt;CNT = <span class="number">0</span>;          <span class="comment">//计数器清零</span></span><br><span class="line">            TIM2-&gt;CCER |= <span class="number">0x02</span>;  <span class="comment">//改为下降沿中断，CCER寄存器的第二位的值控制CH1的上下沿捕获</span></span><br><span class="line">            PWM_R40_state = <span class="number">1</span>;      <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R40_state == <span class="number">1</span>)      <span class="comment">//下降沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R40_cnt1 = TIM2-&gt;CNT;        <span class="comment">//获取计数(高电平时间)</span></span><br><span class="line">            TIM2-&gt;CCER &amp;= ~<span class="number">0x02</span>;         <span class="comment">//改为上升沿中断</span></span><br><span class="line">            PWM_R40_state = <span class="number">2</span>;           <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R40_state == <span class="number">2</span>)              <span class="comment">//第二个上升沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R40_cnt2 = TIM2-&gt;CNT;                <span class="comment">//获取计数（周期）</span></span><br><span class="line">            FR40 = <span class="number">1000000</span> / R40_cnt2;           <span class="comment">//计算频率</span></span><br><span class="line">            DR40 = R40_cnt1 *<span class="number">100.0f</span> / R40_cnt2 ; <span class="comment">//计算占空比</span></span><br><span class="line">            PWM_R40_state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_TIM_IC_Start_IT(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//重新打开中断</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim3)      <span class="comment">//判断TIM3，R39</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(PWM_R39_state == <span class="number">0</span>)      <span class="comment">//第一个上升沿产生</span></span><br><span class="line">        &#123;   </span><br><span class="line">            TIM3-&gt;CNT = <span class="number">0</span>;          <span class="comment">//计数器清零</span></span><br><span class="line">            TIM3-&gt;CCER |= <span class="number">0x02</span>;     <span class="comment">//改为下降沿中断</span></span><br><span class="line">            PWM_R39_state = <span class="number">1</span>;      <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R39_state == <span class="number">1</span>)      <span class="comment">//下降沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R39_cnt1 = TIM3-&gt;CNT;       <span class="comment">//获取计数(高电平时间)</span></span><br><span class="line">            TIM3-&gt;CCER &amp;= ~<span class="number">0x02</span>;        <span class="comment">//改为上升沿中断</span></span><br><span class="line">            PWM_R39_state = <span class="number">2</span>;          <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R39_state == <span class="number">2</span>)      <span class="comment">//第二个上升沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R39_cnt2 = TIM3-&gt;CNT;        <span class="comment">//获取计数（周期）</span></span><br><span class="line">            FR39 = <span class="number">1000000</span> / R39_cnt2;   <span class="comment">//计算频率</span></span><br><span class="line">            DR39 = R39_cnt1  *<span class="number">100.0f</span>/ R39_cnt2;   <span class="comment">//计算占空比</span></span><br><span class="line">            PWM_R39_state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_TIM_IC_Start_IT(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//重新打开中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码在main()中</span></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//开启PWM捕获中断</span></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//开启PWM捕获中断</span></span><br></pre></td></tr></table></figure><hr><h1 id="八、PWM输出模块"><a href="#八、PWM输出模块" class="headerlink" title="八、PWM输出模块"></a>八、PWM输出模块</h1><h3 id="1-PWM输出模块CubeMX设置"><a href="#1-PWM输出模块CubeMX设置" class="headerlink" title="1.PWM输出模块CubeMX设置"></a>1.PWM输出模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/13.png" alt="40f57283c6b34721ba805510e0f9f617.png"></p><p>设置引脚</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/14.png" alt="148c5a4ab14f4796b0f7cea266ac76c4.png"></p><p>TIM16设置</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/15.png" alt="3799c54ca0d74373a4edc908a878fdbb.png"></p><p>TIM17设置</p><h3 id="2-PWM输出模块代码"><a href="#2-PWM输出模块代码" class="headerlink" title="2.PWM输出模块代码"></a>2.PWM输出模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARR自动重装载值，CRR比较寄存器</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim16,TIM_CHANNEL_1);<span class="comment">//启用TIM16，通道1，PWM输出</span></span><br><span class="line">TIM16-&gt;ARR = <span class="number">999</span>;       <span class="comment">//设置频率为1000HZ</span></span><br><span class="line">TIM16-&gt;CCR1 = <span class="number">400</span>;      <span class="comment">//通道1，设置60%占空比</span></span><br><span class="line">    </span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim17,TIM_CHANNEL_1);<span class="comment">//启用TIM17，通道1，PWM输出</span></span><br><span class="line">TIM17-&gt;ARR = <span class="number">1999</span>;      <span class="comment">//设置频率为500HZ</span></span><br><span class="line">TIM17-&gt;CCR1 = <span class="number">100</span>;       <span class="comment">//通道1，设置95%占空比</span></span><br></pre></td></tr></table></figure><hr><h1 id="九、I2C模块"><a href="#九、I2C模块" class="headerlink" title="九、I2C模块"></a>九、I2C模块</h1><p>直接将官方的i2c.c,i2c.h添加到项目中</p><h2 id="1-I2C模块代码"><a href="#1-I2C模块代码" class="headerlink" title="1.I2C模块代码"></a>1.I2C模块代码</h2><h3 id="1-i2c-c文件"><a href="#1-i2c-c文件" class="headerlink" title="1.i2c.c文件"></a>1.i2c.c文件</h3><p>​    在i2c.c后编写    各函数主体9-12-6-7行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写24C02</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(u8 add,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">I2CStart();          <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa0</span>);   <span class="comment">//发送24c02地址，第一位0为写信号</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(add); <span class="comment">//发送填写地址</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(dat);    <span class="comment">//发送要储存的数据</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应 </span></span><br><span class="line"></span><br><span class="line">I2CStop();           <span class="comment">//发送停止信号</span></span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">5</span>);        <span class="comment">//延时，两次写入的间隔要5ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读24C02</span></span><br><span class="line">u8 <span class="title function_">EEPROM_Read</span><span class="params">(u8 add)</span>   </span><br><span class="line">&#123;</span><br><span class="line">I2CStart();          <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa0</span>);   <span class="comment">//发送24c02地址，第一位0为写信号</span></span><br><span class="line">I2CWaitAck();      </span><br><span class="line"></span><br><span class="line">I2CSendByte(add);    <span class="comment">//发送要读取数据的储存地址</span></span><br><span class="line">I2CWaitAck();        </span><br><span class="line"></span><br><span class="line">I2CStart();               <span class="comment">//再次发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa1</span>);        <span class="comment">//发送24c02地址，第一位1为读信号</span></span><br><span class="line">I2CWaitAck();           </span><br><span class="line"></span><br><span class="line">u8 dat = I2CReceiveByte();   <span class="comment">//读取数据</span></span><br><span class="line">I2CSendNotAck();          <span class="comment">//不应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                <span class="comment">//发送停止信号</span></span><br><span class="line"><span class="keyword">return</span>(dat);              <span class="comment">//返回数据接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写MCP4017</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MCP4017_Write</span><span class="params">(u8 val)</span></span><br><span class="line">&#123;   </span><br><span class="line">I2CStart();                <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0x5E</span>);         <span class="comment">//发送器件地址，写信号</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(val);          <span class="comment">//发送数据        //8位数据，但最高位为0</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                 <span class="comment">//发送结束信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读MCP4017</span></span><br><span class="line">u8 <span class="title function_">MCP4017_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">I2CStart();                <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0x5F</span>);         <span class="comment">//发送器件地址，读信号</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">u8 val = I2CReceiveByte();    <span class="comment">//接收数据</span></span><br><span class="line">I2CSendNotAck();           <span class="comment">//不应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                 <span class="comment">//发送停止信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val;                <span class="comment">//返回接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MCP4017数字电位器*/</span></span><br></pre></td></tr></table></figure><h2 id="2-main-c文件"><a href="#2-main-c文件" class="headerlink" title="2.main.c文件"></a>2.main.c文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span>    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2CInit();    <span class="comment">//初始化IO口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Rs * 127 &#x3D; 100k -&gt;Rs &#x3D; 100k &#x2F; 127    Rs是接入电路的每段电阻，共127个</p><p>R &#x3D; 8 *（100 &#x2F; 127）        R是接入电路的电阻</p><p>V &#x3D; 3.3 * R &#x2F; (R + 10)        输出的理论电压</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EEPROM_Write(<span class="number">0x08</span>);</span><br></pre></td></tr></table></figure><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/16.png" alt="aedc1195217f4e1ab2be933a6cc9aea4.png"></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/17.png" alt="91eecd4f6d85424597c59150f1aec333.png"></p><hr><h1 id="十、UART模块"><a href="#十、UART模块" class="headerlink" title="十、UART模块"></a>十、UART模块</h1><h2 id="1-UART模块CubeMX配置"><a href="#1-UART模块CubeMX配置" class="headerlink" title="1.UART模块CubeMX配置"></a>1.UART模块CubeMX配置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/21.png" alt="img"></p><h2 id="2-UART发送模块代码"><a href="#2-UART发送模块代码" class="headerlink" title="2.UART发送模块代码"></a>2.UART发送模块代码</h2><p>查找fputs()的方法</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/18.png" alt="img"></p><p>务必勾选MicroLIB库，否则fputs()重映射无法使用</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/19.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在&quot;usart.h&quot;中声明*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>        <span class="comment">//包含后可使用FILE</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*printf重定向在&quot;usart.c&quot;中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(<span class="type">unsigned</span> <span class="type">char</span>*)&amp;ch,<span class="number">1</span>,<span class="number">50</span>);    <span class="comment">//串口发送函数</span></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在&quot;main.c&quot;中直接使用printf发出数据*/</span></span><br><span class="line">u8 val = <span class="number">123</span>;                     <span class="comment">//定义变量</span></span><br><span class="line">u8 buf[<span class="number">50</span>] = &#123;<span class="string">&quot;lanqiaobei\r\n&quot;</span>&#125;;  <span class="comment">//定义数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!\r\n&quot;</span>);        <span class="comment">//发送字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="number">666</span>);             <span class="comment">//发送数字    </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d\r\n&quot;</span>,val);        <span class="comment">//发送变量中的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>,buf);             <span class="comment">//发送数组</span></span><br></pre></td></tr></table></figure><h2 id="3-UART接收模块代码"><a href="#3-UART接收模块代码" class="headerlink" title="3.UART接收模块代码"></a>3.UART接收模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//包含后可使用memset()函数</span></span></span><br><span class="line">u8 uart_buf[<span class="number">20</span>];       <span class="comment">//uart接收数组</span></span><br><span class="line">u32 uartTick;          <span class="comment">//uart定时器计数变量</span></span><br><span class="line">u8 rx_cnt;             <span class="comment">//uart数据下表变量</span></span><br><span class="line">u8 rx_buf[<span class="number">10</span>];         <span class="comment">//uart接收缓存数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RxIdle_Process</span><span class="params">()</span>                   <span class="comment">//拓展部分函数，用于清空储存数组中的垃圾值        </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(uwTick - uartTick &lt; <span class="number">50</span>)<span class="keyword">return</span>;           <span class="comment">//50ms执行一次</span></span><br><span class="line">    uartTick = uwTick;</span><br><span class="line"></span><br><span class="line">    rx_cnt = <span class="number">0</span>;                                 <span class="comment">//计数下标清零</span></span><br><span class="line">    <span class="built_in">memset</span>(rx_buf,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(rx_buf));         <span class="comment">//清空rx_buf中的数据，使用要引用&lt;string.h&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>     <span class="comment">//uart接收回调中断</span></span><br><span class="line">&#123;</span><br><span class="line">    uartTick = uwTick;                          <span class="comment">//重新计时50ms</span></span><br><span class="line">    </span><br><span class="line">    rx_buf[rx_cnt++] = uart_buf[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(rx_cnt == <span class="number">3</span>)                    <span class="comment">//此处代码为：当接收到3个值时，执行亮灯操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        rx_cnt = <span class="number">0</span>;</span><br><span class="line">        LED_Control(rx_buf[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,uart_buf,<span class="number">1</span>);    <span class="comment">//重新打开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,uart_buf,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="十一、RTC模块"><a href="#十一、RTC模块" class="headerlink" title="十一、RTC模块"></a>十一、RTC模块</h1><h2 id="1-RTC模块CubeMX配置"><a href="#1-RTC模块CubeMX配置" class="headerlink" title="1.RTC模块CubeMX配置"></a>1.RTC模块CubeMX配置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/20.png" alt="3bd079d3540a45a6aa1f6ab3f3300362.png"></p><p>RTC配置</p><h2 id="2-RTC模块代码"><a href="#2-RTC模块代码" class="headerlink" title="2.RTC模块代码"></a>2.RTC模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTC_TimeTypeDef RTC_time;<span class="comment">//定义时间结构体变量</span></span><br><span class="line">RTC_DateTypeDef RTC_data;<span class="comment">//定义日期结构体变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc,&amp;RTC_time,RTC_FORMAT_BIN);<span class="comment">//获取时间，返回十进制</span></span><br><span class="line">    HAL_RTC_GetDate(&amp;hrtc,&amp;RTC_data,RTC_FORMAT_BIN);<span class="comment">//获取日期，返回十进制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></center></center>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPIO基础知识</title>
      <link href="/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>GPIO：通用型输入输出，可以<code>控制输入输出</code>的STM32引脚</strong></p><table><thead><tr><th align="center"><strong>浮空输入</strong></th><th align="center"><strong>Input floating</strong></th></tr></thead><tbody><tr><td align="center"><strong>拉上输入</strong></td><td align="center"><strong>Input pull-up</strong></td></tr><tr><td align="center"><strong>下拉输入</strong></td><td align="center"><strong>Input-pull-down</strong></td></tr><tr><td align="center"><strong>模拟输入</strong></td><td align="center"><strong>Anglog</strong></td></tr><tr><td align="center"><strong>开漏输出</strong></td><td align="center"><strong>Output open-drain</strong></td></tr><tr><td align="center"><strong>推挽输出</strong></td><td align="center"><strong>Output push-pull</strong></td></tr><tr><td align="center"><strong>推挽复用</strong></td><td align="center"><strong>Alternate function push-pull</strong></td></tr><tr><td align="center"><strong>开漏复用</strong></td><td align="center"><strong>Alternate function open-drain</strong></td></tr></tbody></table><p><strong>输出模式：<code>控制端口输出高电平低电平</code>，用于驱动LED，蜂鸣器等，若十大功率器件，则要加上驱动器（小电流控制大电流）</strong></p><p><strong>输入模式：<code>读取端口的高低电平</code>，用于读取外接按键，外接模拟信号的输入，ADC电压采集，模拟通信协议接受数据等</strong></p><p><img src="/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240927202349798.png" alt="image-20240927202349798"></p><ul><li><strong>端口位设置&#x2F;清除寄存器(GPIOx_BSRR)(x&#x3D;A…E):低位用于设置ODRy位为1，高位用于设置ODRy位为0</strong></li><li><strong>端口输出数据寄存器(GPIOx_ODR)(x&#x3D;A..E):可以分别地对各个ODR位进行独立的设置&#x2F;清除</strong></li></ul><h1 id="一、推挽输出"><a href="#一、推挽输出" class="headerlink" title="一、推挽输出"></a>一、推挽输出</h1><ul><li><p><strong>当输出控制为1时</strong></p><p>  <strong>P-MOS导通，N-MOS不导通，输出<code>高电平</code></strong></p></li><li><p><strong>当输出控制为0时</strong></p></li></ul><p>​<strong>P-MOS永远不导通，N-MOS导通，输出低电平</strong></p><ul><li><strong>引脚<code>电流流向单片机內部</code>或着<code>从单片机内部流向外部</code></strong></li><li><strong>可以同时从输入寄存器读取引脚状态</strong></li><li><strong>使用场所</strong></li></ul><ol><li><strong>驱动能力需求高的场合</strong></li><li><strong>高速信号传输</strong></li><li><strong>无需共用信号线的场合</strong></li></ol><h1 id="二、开漏输出"><a href="#二、开漏输出" class="headerlink" title="二、开漏输出"></a>二、开漏输出</h1><ul><li><p><strong>输出控制为0</strong></p><p>  <strong>P-MOS永远关闭，N-MOS导通，  输出低电平</strong></p></li><li><p><strong>输出控制为1</strong></p></li></ul><p>​<strong>P-MOS永远不导通,N-MOS也不导通，输出高阻态</strong></p><p>​<strong>此时要想引脚输出高电平或低电平，需要在单片机外部，接上拉或下拉电阻</strong></p><p>​电阻很大–弱上拉     电阻很小–强上拉</p><ul><li><strong>可以同时从输入寄存器读取引脚状态</strong></li><li><strong>使用场所</strong></li></ul><ol><li><p><strong>多个设备共用信号线</strong></p></li><li><p><strong>不同电压系统之间的接口</strong></p></li><li><p><strong>需要外部上拉电阻来确定逻辑高电平的场合</strong></p></li><li><p><strong>工作时，两个MOS管交替工作来驱动负载。</strong></p><p> <strong>输出1时，上部晶体管导通将电流推向负载</strong></p></li></ol><p>​<strong>输出0时，下部集体管导通将电流拉回地线</strong></p><h1 id="三、复用功能"><a href="#三、复用功能" class="headerlink" title="三、复用功能"></a>三、复用功能</h1><p><strong>引脚不作为IO口来使用，用作其它功能</strong></p><h1 id="四、上拉和下拉输入"><a href="#四、上拉和下拉输入" class="headerlink" title="四、上拉和下拉输入"></a>四、上拉和下拉输入</h1><p><strong>读取引脚的电平</strong></p><ul><li><p><strong>当IO输入电压大于VDD，二极管导通，此时VIO &#x3D;&#x3D; VDD，保护芯片</strong></p></li><li><p><strong>当IO输入电压小于VDD，二极管导通，此时VIO &#x3D;&#x3D; VSS，保护芯片</strong>  </p></li><li><p><strong>该模式下输出功能无效</strong></p></li><li><p><strong>施密特触发器作用</strong></p></li></ul><p><img src="/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240928000612157.png" alt="image-20240928000612157"></p><h1 id="五、模拟输入"><a href="#五、模拟输入" class="headerlink" title="五、模拟输入"></a>五、模拟输入</h1><ul><li><p><strong>施密特触发器禁用，输入数据寄存器值为0</strong></p></li><li><p><strong>ADC</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
          <category> 外设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL(二)部件部分</title>
      <link href="/2024/09/25/LVGL/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/"/>
      <url>/2024/09/25/LVGL/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、标签控件"><a href="#一、标签控件" class="headerlink" title="一、标签控件"></a>一、标签控件</h1><p><strong>主体   滚动条   选中的文本</strong>    </p><h2 id="1-创建标签部件"><a href="#1-创建标签部件" class="headerlink" title="1 .创建标签部件"></a>1 .创建标签部件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *label =lv_label_create(lv_scr_act()); <span class="comment">//create中传入父对象</span></span><br></pre></td></tr></table></figure><h2 id="2-设置文本的三种方式"><a href="#2-设置文本的三种方式" class="headerlink" title="2. 设置文本的三种方式"></a>2. 设置文本的三种方式</h2><ul><li><strong>直接设置文本，存储文本的<u>内存动态分配</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text(label,<span class="string">&quot;hello\n lvgl&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>文本不存储在动态内存，而是在<u>指定的缓冲区中</u>，代码块中只读，修改可能会崩溃(慎用)</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text_static(label,<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>格式化显示文本，类似printf</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text_fmt(label,<span class="string">&quot;Value:%d&quot;</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="3-设置文本样式"><a href="#3-设置文本样式" class="headerlink" title="3.设置文本样式"></a>3.设置文本样式</h2><ul><li><strong>背景颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_bg_color(label,    <span class="comment">//父对象</span></span><br><span class="line">         lv_color_hex(<span class="number">0xff0000</span>),    <span class="comment">//十六进制颜色</span></span><br><span class="line">              LV_STATE_DEFAULT);    <span class="comment">//触发类型</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置背景透明度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_bg_opa(label,</span><br><span class="line">                          <span class="number">100</span>，<span class="comment">//0-255,越大越不透明</span></span><br><span class="line">            LV_STATE_DEFAULT); <span class="comment">//触发类型  </span></span><br></pre></td></tr></table></figure><ul><li><strong>字体大小</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_font(label,    <span class="comment">//对象</span></span><br><span class="line">           &amp;lv_font_montserrat_30,    <span class="comment">//字号       使用字体要打开lv_conf,h中对应的宏定义</span></span><br><span class="line">               LV_STATE_DEFAULT);    <span class="comment">//触发类型</span></span><br></pre></td></tr></table></figure><ul><li><strong>文本颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_color(label,<span class="comment">//对象</span></span><br><span class="line">           lv_color_hex(<span class="number">0x5084db</span>),<span class="comment">//字体颜色</span></span><br><span class="line">                LV_STATE_DEFAULT);<span class="comment">//触发类型</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>单独设置字体颜色</strong></p><ul><li><strong>开启重新着色的功能</strong></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_recolor(label,ture);</span><br></pre></td></tr></table></figure><ul><li></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text(label,<span class="string">&quot;hello #ff0000 lvgl#&quot;</span>);</span><br><span class="line">lv_label_set_text_fmt(label, <span class="string">&quot;%s%d%s%s&quot;</span>, <span class="string">&quot;www.&quot;</span>, <span class="number">100</span>, <span class="string">&quot;ask&quot;</span>, <span class="string">&quot;.net&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-文本长度"><a href="#4-文本长度" class="headerlink" title="4. 文本长度"></a>4. 文本长度</h2><ul><li><p><strong>默认情况下，如果没有限定标签部件大小，那它的大小自动拓展为文本大小</strong></p></li><li><p><strong>长文本模式</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_long_mode(label,  <span class="comment">//对象</span></span><br><span class="line">       LV_LABEL_LONG_SCROLL);  <span class="comment">//显示模式</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LV_LABEL_LONG_WRAP,             <span class="comment">/* 默认模式，如果部件大小已固定，超出的文本将被剪切 */</span></span><br><span class="line">    LV_LABEL_LONG_DOT,              <span class="comment">/* 将label右下角的最后3个字符替换为... */</span></span><br><span class="line">    LV_LABEL_LONG_SCROLL,           <span class="comment">/* 来回滚动 */</span></span><br><span class="line">    LV_LABEL_LONG_SCROLL_CIRCULAR,  <span class="comment">/* 循环滚动 */</span></span><br><span class="line">    LV_LABEL_LONG_CLIP,             <span class="comment">/* 直接剪切掉部件外面的文本部分 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、按钮部件"><a href="#二、按钮部件" class="headerlink" title="二、按钮部件"></a>二、按钮部件</h1><p><strong>按钮部件相比基础对象，没有新增功能</strong></p><ul><li><strong>创建按钮部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *btn = lv_btn_create(lv_scr_act());</span><br></pre></td></tr></table></figure><ul><li><strong>设置样式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size(btn,<span class="number">100</span>,<span class="number">50</span>);    <span class="comment">// 大小</span></span><br><span class="line">lv_obj_set_align(btn,LV_ALIGN_CENTER);  <span class="comment">// 对齐方式</span></span><br><span class="line">lv_obj_set_style_bg_color(btn,lv_color_hex(<span class="number">0xde4d3e</span>),LV_STATE_PRESSED);</span><br></pre></td></tr></table></figure><ul><li><strong>添加事件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_flag(btn,LV_OBJ_FLAG_CHECKABLE);         <span class="comment">// 开启状态 </span></span><br><span class="line">lv_obj_add_event_cb(btn,<span class="comment">//对象</span></span><br><span class="line">               event_cb,<span class="comment">//回调函数名称</span></span><br><span class="line"> LV_EVENT_VALUE_CHANGED,<span class="comment">//触发类型</span></span><br><span class="line">                  <span class="literal">NULL</span>);<span class="comment">//  </span></span><br></pre></td></tr></table></figure><h1 id="三、开关部件"><a href="#三、开关部件" class="headerlink" title="三、开关部件"></a>三、开关部件</h1><p><strong>开关部件常用于控制某个功能的开启或关闭，可以直接显示被控对象的状态</strong></p><p><strong>主体（关闭时显示）    <code>LV_PART_MAIN</code></strong></p><p><strong>手柄       <code>LV_PART_KNOB</code></strong></p><p><strong>指示器（开启时显示）<code>LV_PART_INDICATOR</code></strong></p><ul><li><strong>创建开关部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *switch1 = lv_switch_create(lv_scr_act());</span><br><span class="line">lv_obj_set_style_bg_color(switch1,lv_color_hex(<span class="number">0xdf5345</span>),LV_STATE_CHECKED|LV_PART_INDICATOR); <span class="comment">//指示器要设置显示状态</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加、清除开关状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_state(switch1, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">// 添加状态：默认打开且不可修改</span></span><br><span class="line">lv_obj_clear_state(switch1, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">// 清除开关的状态 </span></span><br></pre></td></tr></table></figure><ul><li><strong>获取（判断）开关状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_has_state(switch1, LV_STATE_CHECKED) <span class="comment">//判断是否是LV_STATE_CHECKED状态， 返回值：bool类型</span></span><br></pre></td></tr></table></figure><h1 id="四、复选框"><a href="#四、复选框" class="headerlink" title="四、复选框"></a>四、复选框</h1><p><strong>主体</strong></p><p><strong>勾选框</strong></p><ul><li><strong>创建复选框</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *checkbox  = lv_checkbox_create (parent );</span><br></pre></td></tr></table></figure><ul><li><strong>文本设置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_checkbox_set_text( checkbox, <span class="string">&quot;remember the password&quot;</span> );<span class="comment">/* 设置文本内容 */</span></span><br><span class="line">lv_obj_set_style_pad_column( checkbox, <span class="number">20</span>, LV_STATE_DEFAULT ); <span class="comment">/* 设置文本和勾选框的间距</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加、清除复选框状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_state(checkbox, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">/* 添加状态：默认选中且不可修改 */</span></span><br><span class="line">lv_obj_clear_state(checkbox, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">/* 清除复选框的状态 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取（判断）复选框状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_has_state(checkbox, LV_STATE_CHECKED); <span class="comment">/* 返回值：1，选中； 0，非选中 */</span></span><br></pre></td></tr></table></figure><h1 id="五、进度条部件"><a href="#五、进度条部件" class="headerlink" title="五、进度条部件"></a>五、进度条部件</h1><p><strong>常用于显示当前任务的进度</strong></p><p><strong>主体</strong></p><p><strong>指示器</strong></p><ul><li>xxxxxxxxxx12 1static void event_cb(lv_event_t* e)2{3    lv_obj_t *target &#x3D; lv_event_get_target(e);&#x2F;&#x2F;获取触发事件的部件4    if(target &#x3D;&#x3D; target_obj)                  &#x2F;&#x2F;判断触发事件的部件5    {6        printf(“父对象触发事件\r\n”);            &#x2F;&#x2F;执行相应操作7    }8    else if(target &#x3D;&#x3D; child_obj)9    {10        printf(“子对象触发事件\r\n”);    11    }12}c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *bar  = lv_bar_create ( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置大小、当前值、范围值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size( bar, <span class="number">400</span>, <span class="number">20</span> );<span class="comment">/* 设置大小 */</span> <span class="comment">// 决定进度条从左往右，还是从下往上</span></span><br><span class="line">lv_bar_set_value( bar, <span class="number">50</span>, LV_ANIM_ON );<span class="comment">/* 设置当前值 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置动画时间</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_anim_time( bar, <span class="number">500</span>, LV_STATE_DEFAULT ); <span class="comment">/* 动画设置必须放在当前值设置之前 */</span> </span><br><span class="line">                                         <span class="comment">//选择器</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置样式和起始值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_bar_set_mode( bar, LV_BAR_MODE_RANGE );<span class="comment">/* 设置模式 */</span></span><br><span class="line">lv_bar_set_start_value( bar, <span class="number">-50</span>, LV_ANIM_OFF );<span class="comment">/* 设置起始</span></span><br></pre></td></tr></table></figure><ul><li><strong>模式枚举</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LV_BAR_MODE_NORMAL,<span class="comment">/* 默认模式 */</span></span><br><span class="line">    LV_BAR_MODE_SYMMETRICAL,    <span class="comment">/* 从零值绘制到当前值（当前值可以小于0） */</span></span><br><span class="line">    LV_BAR_MODE_RANGE<span class="comment">/* 允许设置起始值，但起始值必须小于当前值 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="六、加载器部件"><a href="#六、加载器部件" class="headerlink" title="六、加载器部件"></a>六、加载器部件</h1><p><strong>常用于提示当前任务正在加载</strong></p><p><strong>主体</strong></p><p><strong>指示器</strong></p><p><strong>手柄（指示器的起点）</strong></p><ul><li><strong>创建加载器部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *spinner  = lv_spinner_create( parent, spin_time, arc_length );</span><br></pre></td></tr></table></figure><ul><li><strong>设置圆弧的颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_arc_color( spinner, lv_color_hex(<span class="number">0x4a9f00</span>), LV_PART_MAIN );    <span class="comment">/* 设置主体圆弧颜色 */</span></span><br><span class="line">lv_obj_set_style_arc_color( spinner, lv_color_hex(<span class="number">0x83bd55</span>), LV_PART_INDICATOR );   <span class="comment">/* 设置指示器圆弧颜色 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置圆弧宽度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_arc_width( spinner, <span class="number">30</span>, LV_PART_MAIN ); <span class="comment">/* 设置主体圆弧宽度 */</span></span><br><span class="line">lv_obj_set_style_arc_width( spinner, <span class="number">30</span>, LV_PART_INDICATOR );<span class="comment">/* 设置指示器圆弧宽度 */</span></span><br></pre></td></tr></table></figure><h1 id="七、LED部件"><a href="#七、LED部件" class="headerlink" title="七、LED部件"></a>七、LED部件</h1><p><strong>常用于指示控制对象的状态</strong></p><ul><li><strong>创建LED部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *led = lv_led_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置LED颜色、亮度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_led_set_color( led, lv_color_hex(<span class="number">0xff0000</span>) )；<span class="comment">/* 设置LED颜色 */</span></span><br><span class="line">lv_led_set_brightness( led, <span class="number">0</span> );    <span class="comment">/* 设置LED亮度，范围0~255 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置LED状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_led_on( led );    <span class="comment">/* 打开LED（设置亮度为255）*/</span></span><br><span class="line">lv_led_off( led );    <span class="comment">/* 关闭LED */</span></span><br><span class="line">lv_led_toggle( led );<span class="comment">/* 翻转LED状态 */</span></span><br></pre></td></tr></table></figure><h1 id="八、列表部件"><a href="#八、列表部件" class="headerlink" title="八、列表部件"></a>八、列表部件</h1><p><strong>常用于多选一的场景，默认会展现多个选项</strong></p><p><strong>主体</strong></p><p><strong>滚动条</strong></p><ul><li><strong>创建列表部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *<span class="built_in">list</span> = lv_list_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>添加列表文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_list_add_text( <span class="built_in">list</span>, “Settings<span class="string">&quot; );</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加列表按钮</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *btn= lv_list_add_btn( <span class="built_in">list</span>, LV_SYMBOL_WIFI, “WLAN<span class="string">&quot;); </span></span><br></pre></td></tr></table></figure><ul><li><strong>获取列表按钮文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_list_get_btn_text( <span class="built_in">list</span>, list_btn );</span><br></pre></td></tr></table></figure><ul><li><strong>回调</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *list_btn = lv_event_get_target(e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> *list_btn = lv_event_get_target(e);   <span class="comment">// 获取触发源</span></span><br><span class="line">    lv_label_set_text(list_label,lv_list_get_btn_text(<span class="built_in">list</span>,list_btn)); <span class="comment">// 获取按钮文本并显示</span></span><br><span class="line">    lv_obj_add_state(list_btn,LV_STATE_FOCUS_KEY);    <span class="comment">// 添加状态（聚焦）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、下拉列表部件"><a href="#九、下拉列表部件" class="headerlink" title="九、下拉列表部件"></a>九、下拉列表部件</h1><p><strong>按钮</strong></p><p><strong>列表</strong></p><ul><li><strong>创建下拉列表部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *dd = lv_dropdown_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置选项内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_set_options( dd, <span class="string">&quot;a\nb\nc\nd&quot;</span>);   <span class="comment">/* 设置选项 */</span></span><br><span class="line">lv_dropdown_set_options_static( dd, <span class="string">&quot;a\nb\nc\nd &quot;</span>);<span class="comment">/* 设置选项 （静态）*/</span></span><br><span class="line">lv_dropdown_add_option( dd, <span class="string">&quot;e&quot;</span>, <span class="number">4</span>);<span class="comment">/* 添加选项，索引从0开始 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前所选项</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_set_selected( dd, <span class="number">1</span>);<span class="comment">/* 注意：索引从0开始 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取选项内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_get_selected( dd);<span class="comment">/* 获取索引 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">lv_dropdown_get_selected_str( dd, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">/* 获取选项文本</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置方向和图标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_set_dir(dd, LV_DIR_RIGHT);<span class="comment">/* 设置列表展开方向 */</span></span><br><span class="line">lv_dropdown_set_symbol(dd, LV_SYMBOL_RIGHT);    <span class="comment">/* 设置图标 */</span></span><br></pre></td></tr></table></figure><h1 id="十、滚轮部件"><a href="#十、滚轮部件" class="headerlink" title="十、滚轮部件"></a>十、滚轮部件</h1><p><strong>常用于多选一的场景，它以滚轮的形式来展现多个选项</strong></p><p><strong>主体</strong></p><p><strong>选项框</strong></p><ul><li><strong>创建滚轮部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *roller= lv_roller_create( parent )；</span><br></pre></td></tr></table></figure><ul><li><strong>设置选项间隔</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_line_space(roller, <span class="number">30</span>, </span><br><span class="line">                          LV_STATE_DEFAULT);  <span class="comment">//选择器，什么状态下应用</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置选项内容、滚动模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_set_options(roller, “a\nb\nc\nd”, LV_ROLLER_MODE_NORMAL); <span class="comment">/* 正常模式 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前所选项</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_set_selected(roller, <span class="number">3</span>, LV_ANIM_ON);</span><br></pre></td></tr></table></figure><ul><li><strong>设置可见行数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_set_visible_row_count(roller, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>获取选项内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_get_selected(roller);<span class="comment">/* 获取索引 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">lv_roller_get_selected_str(roller, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">/* 获取选项文</span></span><br></pre></td></tr></table></figure><h1 id="十一、滑块部件"><a href="#十一、滑块部件" class="headerlink" title="十一、滑块部件"></a>十一、滑块部件</h1><p><strong>常用于调节某个参数的值，它以直线滑动的形式来修改数值</strong></p><p><strong>主体</strong></p><p><strong>指示器</strong></p><p><strong>旋钮</strong></p><ul><li><strong>创建跨快部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *slider = lv_slider_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置大小、当前值、范围值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size(slider, <span class="number">20</span>, <span class="number">200</span>);<span class="comment">/* 高度&gt;宽度时，滑块为纵向 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_slider_get_value(slider);</span><br></pre></td></tr></table></figure><ul><li><strong>模式设置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_slider_set_mode(slider, LV_SLIDER_MODE_...);</span><br></pre></td></tr></table></figure><ul><li><strong>设置、获取左值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_slider_set_left_value(slider, <span class="number">20</span>, LV_ANIM_OFF);<span class="comment">/* 设置左值 */</span></span><br><span class="line">lv_slider_get_left_value(slider);<span class="comment">/* 获取左值 */</span></span><br></pre></td></tr></table></figure><h1 id="十二、圆弧部件"><a href="#十二、圆弧部件" class="headerlink" title="十二、圆弧部件"></a>十二、圆弧部件</h1><p><strong>以弧形滑动的形式来调节、显示某个参数的值</strong></p><p><strong>背景弧</strong></p><p><strong>前景弧</strong></p><p><strong>旋钮</strong></p><ul><li><strong>创建圆弧部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *arc = lv_arc_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置范围值、当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_value(arc, <span class="number">80</span>);<span class="comment">/* 设置当前值（需要在范围值之内）*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置圆弧角度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_angles(arc, <span class="number">135</span>, <span class="number">270</span>);<span class="comment">/* 设置前景弧角度 */</span></span><br><span class="line">lv_arc_set_bg_angles(arc, <span class="number">135</span>, <span class="number">45</span>);<span class="comment">/* 设置背景弧角度 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置旋转角度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_rotation(arc, <span class="number">180</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>获取当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_get_value(arc);</span><br></pre></td></tr></table></figure><ul><li><strong>设置模式、圆弧绘制速率</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_mode(arc, LV_ARC_MODE_REVERSE);<span class="comment">/* 设置模式 */</span></span><br><span class="line">lv_arc_set_change_rate(arc, <span class="number">90</span>);<span class="comment">/* 绘制速率：90°/秒 */</span></span><br></pre></td></tr></table></figure><h1 id="十三-、线条部件"><a href="#十三-、线条部件" class="headerlink" title="十三 、线条部件"></a>十三 、线条部件</h1><p><strong>线条部件能够在一组坐标点之间依次绘制直线</strong></p><p><strong>主体</strong></p><ul><li><strong>创建线条部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *line = lv_line_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置线条坐标点</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">lv_point_t</span>  line_points[] = &#123; &#123;<span class="number">15</span>, <span class="number">5</span>&#125;, &#123;<span class="number">25</span>, <span class="number">20</span>&#125;, &#123;<span class="number">5</span>, <span class="number">20</span>&#125;, &#123;<span class="number">15</span>, <span class="number">5</span>&#125; &#125;;</span><br><span class="line">lv_line_set_points(line, line_points, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>设置线条样式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_line_width(line, <span class="number">8</span>, LV_PART_MAIN);           <span class="comment">/* 设置宽度 */</span></span><br><span class="line">lv_obj_set_style_line_rounded(line, <span class="literal">true</span>, LV_PART_MAIN);   <span class="comment">/* 设置圆角 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置Y轴翻转</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_line_set_y_invert(line, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h1 id="十四、图片部件"><a href="#十四、图片部件" class="headerlink" title="十四、图片部件"></a>十四、图片部件</h1><p><strong>用于图片显示、功能界面优化、背景优化等</strong></p><p><strong>主体</strong></p><ul><li><strong>创建图片部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *img = lv_img_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置图片源</strong><ul><li><strong>图片来源：C语言数组、Bin文件、LVGL内置字体图标</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LV_IMG_DECLARE(img_bird);<span class="comment">/* 声明图片 在函数外 */</span></span><br><span class="line">lv_img_set_src(img, &amp;img_bird);<span class="comment">/* 设置图片源 * /</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置图片偏移</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_img_set_offset_x(img, <span class="number">100</span>);<span class="comment">/* x轴偏移100 */</span></span><br><span class="line">lv_img_set_offset_y(img, <span class="number">20</span>); <span class="comment">/* y轴偏移20  */</span></span><br></pre></td></tr></table></figure><ul><li><strong>图片重新着色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_img_recolor(img, lv_color_hex(<span class="number">0xffe1d2</span>), LV_PART_MAIN);<span class="comment">/* 对图片进行蒙色*/</span></span><br><span class="line">lv_coloc_make(R,G,B); <span class="comment">// 获取RGB三通道的值</span></span><br><span class="line">lv_obj_set_style_img_recolor_opa(img, <span class="number">150</span>, LV_PART_MAIN);<span class="comment">/* 修该蒙色透明度 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置图片缩放、旋转</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_img_set_zoom(img, <span class="number">512</span>);<span class="comment">/* 放大2倍 ，原尺寸256 */</span></span><br><span class="line">lv_img_set_angle(img, <span class="number">900</span>);<span class="comment">/* 顺时针方向旋转90° */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>设置中心点</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_update_layout(img);<span class="comment">/* 更新图片布局信息 */</span></span><br><span class="line">lv_img_set_pivot(img, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">/* 设置中心点 ，中心点坐标是相对于原坐标来说的*/</span></span><br></pre></td></tr></table></figure><h1 id="十五、色环部件"><a href="#十五、色环部件" class="headerlink" title="十五、色环部件"></a>十五、色环部件</h1><p><strong>在UI设计中，色环部件一般用作颜色选择器</strong></p><ul><li><strong>创建色环部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *cw = lv_colorwheel_create( parent, </span><br><span class="line">                               knob_recolor ); <span class="comment">//手柄是否重新着色</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前选中的颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_colorwheel_set_rgb(cw, lv_color_hex(<span class="number">0xff0000</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>获取当前选中的颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_colorwheel_get_rgb(cw);</span><br></pre></td></tr></table></figure><ul><li><strong>设置色环模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_colorwheel_set_mode(cw, LV_COLORWHEEL_MODE_HUE/SATURATION/VALUE); <span class="comment">/* 色相、饱和度、明度 */</span></span><br><span class="line">lv_colorwheel_set_mode_fixed(cw, <span class="literal">true</span>);<span class="comment">// 固定色环模式</span></span><br></pre></td></tr></table></figure><p><img src="/2024/09/25/LVGL/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/image-20240928151156900-1727619652515-6.png" alt="image-20240928151156900"></p><h1 id="十六、按钮矩阵部件"><a href="#十六、按钮矩阵部件" class="headerlink" title="十六、按钮矩阵部件"></a>十六、按钮矩阵部件</h1><p><strong>可以在不同的行和列中显示多个轻量级按钮</strong></p><p><strong>主体</strong></p><p><strong>按钮</strong></p><ul><li><strong>创建按钮矩阵部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *btnm = lv_btnmatrix_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>设置按钮数量、文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="built_in">map</span>[] = &#123; <span class="string">&quot;btn1&quot;</span>, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;btn2&quot;</span>, <span class="string">&quot;btn3&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;<span class="comment">/* 定义按钮数组，最后一个元素必须为空 */</span></span><br><span class="line">lv_btnmatrix_set_map(btnm, <span class="built_in">map</span>);<span class="comment">/* 设置按钮 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置按钮相对高度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_set_btn_width(btnm, id, width);<span class="comment">/* 索引 (id) 从0开始，宽度1~7 ( 默认为1 ) */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取按钮索引、文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_get_selected_btn(btnm);<span class="comment">/* 获取索引 */</span></span><br><span class="line">lv_btnmatrix_get_btn_text(btnm, id);<span class="comment">/* 获取文本 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置、清除按钮属性</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_set_btn_ctrl(btnm, id, LV_BTNMATRIX_CTRL_...); <span class="comment">/* 设置单个按钮属性 */</span></span><br><span class="line">lv_btnmatrix_clear_btn_ctrl(btnm, id, LV_BTNMATRIX_CTRL_...); <span class="comment">/* 清除单个按钮属性 */</span></span><br><span class="line">lv_btnmatrix_set_btn_ctrl_all(btnm, LV_BTNMATRIX_CTRL_...);  <span class="comment">/* 设置所有按钮属性 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_HIDDEN, <span class="comment">/* 隐藏 */</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_DISABLED,<span class="comment">/* 失能 */</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_CHECKABLE, <span class="comment">/* 允许状态切换 */</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_RECOLOR, <span class="comment">/* 允许文本重新着色 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>设置单次选中属性</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_set_one_checked(btnm, <span class="literal">true</span>);  <span class="comment">/* 注意：需要先设置允许状态切换属性 */</span></span><br></pre></td></tr></table></figure><h1 id="十七、文本区域部件"><a href="#十七、文本区域部件" class="headerlink" title="十七、文本区域部件"></a>十七、文本区域部件</h1><p><strong>即文本输入框，用户可以在其中输入文本内容</strong></p><p><strong>主体</strong></p><p><strong>滚动条</strong></p><p><strong>所选文本</strong></p><p><strong>光标</strong></p><p><strong>占位符</strong></p><ul><li><strong>创建文本去部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *ta = lv_textarea_create(parent);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>添加文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_add_char(ta, <span class="string">&#x27;A&#x27;</span>);<span class="comment">/* 添加一个字符到当前光标处 */</span></span><br><span class="line">lv_textarea_add_text(ta, <span class="string">&quot;BCDEF&quot;</span>); <span class="comment">/* 添加字符串到当前光标处 */</span></span><br><span class="line"><span class="type">lv_obj_t</span> *keyboard = lv_keyboard_create(lv_scr_act());<span class="comment">/* 创建键盘部件 */</span></span><br><span class="line">lv_keyboard_set_textarea(keyboard, ta);<span class="comment">/* 关联键盘和文本区域部件 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置光标位置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_cursor_pos(ta, <span class="number">0</span>);<span class="comment">/* 0：最左侧，  LV_TEXTAREA_CURSOR_LAST：最右侧 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>删除文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_del_char(ta);<span class="comment">/* 删除光标左侧的一个字符 */</span></span><br><span class="line">lv_textarea_del_char_forward(ta);<span class="comment">/* 删除光标右侧的一个字符 </span></span><br></pre></td></tr></table></figure><ul><li><strong>设置模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_one_line(ta, <span class="literal">true</span>);<span class="comment">/* 单行模式 */</span></span><br><span class="line">lv_textarea_set_password_mode(ta, <span class="literal">true</span>);<span class="comment">/* 密码模式（隐藏输入的内容） */</span></span><br></pre></td></tr></table></figure><ul><li><strong>限制字符输入</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_accepted_chars(ta,<span class="string">&quot;0123456789&quot;</span>);<span class="comment">/* 限制接收的字符 */</span></span><br><span class="line">lv_textarea_set_max_length(ta,<span class="number">6</span>); <span class="comment">/* 限制字符长度 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置占位符</strong>(提示文本)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_placeholder_text(ta, <span class="string">&quot;password&quot;</span>); <span class="comment">/* 提示输入密码 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *txt = lv_textarea_get_text(ta); <span class="comment">/* 获取文本框文本 */</span> </span><br></pre></td></tr></table></figure><ul><li><strong>比对文本内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2);<span class="comment">/* 当s1=s2时，返回0 */</span></span><br></pre></td></tr></table></figure><h1 id="十八、键盘部件"><a href="#十八、键盘部件" class="headerlink" title="十八、键盘部件"></a>十八、键盘部件</h1><p><strong>可用于输入文本内容，其本质上就是一个特殊的按钮矩阵</strong></p><p><strong>主体</strong></p><p><strong>按钮</strong></p><ul><li><strong>创建键盘部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *kb = lv_keyboard_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>关联文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *ta = lv_textarea_create(lv_scr_act());<span class="comment">/* 创建文本区域部件 */</span></span><br><span class="line">lv_keyboard_set_textarea(kb, ta);<span class="comment">/* 关联键盘和文本区域部件</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置按键弹窗</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_keyboard_set_popovers(kb, <span class="literal">true</span>);<span class="comment">/* 允许按键弹窗提示 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置键盘模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_keyboard_set_mode(kb, LV_KEYBOARD_MODE_NUMBER);<span class="comment">/* 数字键盘模式 */</span></span><br></pre></td></tr></table></figure><h1 id="十九、图片按钮部件"><a href="#十九、图片按钮部件" class="headerlink" title="十九、图片按钮部件"></a>十九、图片按钮部件</h1><p><strong>类似于按钮部件，不同的是，用户可以在其中设置图片</strong></p><p><strong>主体</strong></p><ul><li><strong>创建图片按钮部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_keyboard_set_mode(kb, LV_KEYBOARD_MODE_NUMBER);<span class="comment">/* 数字键盘模式 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置图片源、按钮大小</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_imgbtn_set_src(imgbtn, LV_IMGBTN_STATE_..., src_left, src_mid, src_right);<span class="comment">/* 设置某个状态的图片源 */</span></span><br><span class="line">lv_obj_set_size(imgbtn, <span class="number">64</span> * <span class="number">3</span>, <span class="number">64</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>设置按钮状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_imgbtn_set_state(imgbtn, LV_IMGBTN_STATE_PRESSED);<span class="comment">/* 设置按下状态 */</span></span><br></pre></td></tr></table></figure><h1 id="二十、选项卡部件"><a href="#二十、选项卡部件" class="headerlink" title="二十、选项卡部件"></a>二十、选项卡部件</h1><p><strong>主体</strong></p><p><strong>按钮</strong></p><ul><li><strong>创建选项卡部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *tabview =  lv_tabview_create(parent, LV_DIR_..., tab_size);</span><br></pre></td></tr></table></figure><ul><li><strong>添加选项卡</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *tab1 = lv_tabview_add_tab(tabview, <span class="string">&quot;Tab 1&quot;</span>); </span><br><span class="line"><span class="type">lv_obj_t</span> *tab2 = lv_tabview_add_tab(tabview, <span class="string">&quot;Tab 2&quot;</span>); </span><br></pre></td></tr></table></figure><ul><li><strong>设置当前选中的选项卡</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_tabview_set_act(tabview, <span class="number">1</span>, LV_ANIM_OFF); <span class="comment">/* 索引从0开始 */</span></span><br></pre></td></tr></table></figure><h1 id="二十一、平铺视图部件"><a href="#二十一、平铺视图部件" class="headerlink" title="二十一、平铺视图部件"></a>二十一、平铺视图部件</h1><p><strong>可以实现不同方向的页面切换，用户可以在页面中添加内容</strong></p><p><strong>主体</strong></p><p><strong>滚动条</strong></p><ul><li><strong>创建平铺视图部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *tileview = lv_tileview_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>添加页面</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *tile1 = lv_tileview_add_tile( tileview, <span class="number">0</span>, <span class="number">0</span>, LV_DIR_RIGHT );</span><br><span class="line"><span class="type">lv_obj_t</span> *tile2 = lv_tileview_add_tile( tileview, <span class="number">1</span>, <span class="number">0</span>, LV_DIR_LEFT );</span><br></pre></td></tr></table></figure><ul><li><strong>设置当前显示页面</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_update_layout( tileview );<span class="comment">/* 更新参数 */</span></span><br><span class="line">lv_obj_set_tile( tileview, tile2, LV_ANIM_OFF );<span class="comment">/* 根据页面对象设置 */</span></span><br><span class="line">lv_obj_set_tile_id( tileview, <span class="number">1</span>, <span class="number">0</span>, LV_ANIM_OFF );<span class="comment">/* 根据页面行列设置 */</span></span><br></pre></td></tr></table></figure><h1 id="二十二、窗口部件"><a href="#二十二、窗口部件" class="headerlink" title="二十二、窗口部件"></a>二十二、窗口部件</h1><p><strong>可以作为一个容器，展示不同功能的页面</strong></p><ul><li><strong>创建窗口部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *win = lv_win_create(parent, header_height);</span><br></pre></td></tr></table></figure><ul><li><strong>添加标题、按钮</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *title = lv_win_add_title(win, <span class="string">&quot;Setting&quot;</span>);</span><br><span class="line"><span class="type">lv_obj_t</span> *btn = lv_win_add_btn(win, LV_SYMBOL_CLOSE, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>添加主体内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *content = lv_win_get_content(win); <span class="comment">/* 获取主体 */</span></span><br><span class="line"><span class="type">lv_obj_t</span> *label = lv_label_create(content);<span class="comment">/* 添加内容 */</span></span><br></pre></td></tr></table></figure><h1 id="二十三、消息框部件"><a href="#二十三、消息框部件" class="headerlink" title="二十三、消息框部件"></a>二十三、消息框部件</h1><p><strong>消息框部件可以实现弹窗提示，常用于消息通知、确定操作等</strong></p><p><strong>主体</strong></p><p><strong>标题</strong></p><p><strong>关闭按钮</strong></p><p><strong>按钮矩阵</strong></p><ul><li><strong>创建消息框部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *btns[] = &#123; <span class="string">&quot;Continue&quot;</span>, <span class="string">&quot;Close&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line"><span class="type">lv_obj_t</span> *msgbox = lv_msgbox_create( lv_scr_act(), <span class="string">&quot;Notice&quot;</span>, <span class="string">&quot;Do you want to continue?&quot;</span>, btns, <span class="literal">true</span> );</span><br><span class="line"><span class="comment">//   标题       主体文本                  按钮矩阵 关闭按钮</span></span><br></pre></td></tr></table></figure><ul><li><strong>关闭消息框</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_msgbox_close(msgbox);</span><br></pre></td></tr></table></figure><ul><li><strong>获取按钮索引、文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *target = lv_event_get_current_target(e);<span class="comment">/* 获取当前触发源 */</span></span><br><span class="line">lv_msgbox_get_active_btn(target);<span class="comment">/* 获取按钮索引 */</span></span><br><span class="line">lv_msgbox_get_active_btn_text(target);<span class="comment">/* 获取按钮文本 */</span></span><br></pre></td></tr></table></figure><h1 id="二十四、微调器部件"><a href="#二十四、微调器部件" class="headerlink" title="二十四、微调器部件"></a>二十四、微调器部件</h1><p><strong>微调器部件本质上就是一个数字文本，常用于精确调节某个参数的值</strong></p><p><strong>主体</strong></p><p><strong>光标</strong></p><ul><li><strong>创建微调器部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *spinbox = lv_spinbox_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>数值递增、递减</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_increment(spinbox);<span class="comment">/* 递增 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置步进值、范围值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_set_step(spinbox, <span class="number">200</span>);<span class="comment">/* 设置步进值，默认为1*/</span></span><br><span class="line">lv_spinbox_set_range(spinbox, <span class="number">-1000</span>, <span class="number">1000</span>);<span class="comment">/* 设置范围值，默认±99999*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_set_value(spinbox, <span class="number">400</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>设置数字格式、光标位置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_set_digit_format(spinbox, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">/* 设置数字位数、小数点位置 */</span></span><br><span class="line">lv_spinbox_set_pos(spinbox, <span class="number">3</span>);<span class="comment">/* 设置光标位置 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_get_value(spinbox); <span class="comment">/* 返回值为整数，而非小数 */</span></span><br></pre></td></tr></table></figure><h1 id="二十五、表格部件"><a href="#二十五、表格部件" class="headerlink" title="二十五、表格部件"></a>二十五、表格部件</h1><p><strong>有一个个单元格组成，它的单元格中只能存放文本形式的内容</strong></p><p><strong>主体</strong></p><p><strong>单元格</strong></p><ul><li><strong>创建表格部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *table = lv_table_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>设置行数、列数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_table_set_row_cnt(table,<span class="number">2</span>); <span class="comment">/* 设置行数 */</span></span><br><span class="line">lv_table_set_col_cnt(table,<span class="number">2</span>); <span class="comment">/* 设置列数 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置单元格的内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_table_set_cell_value(table, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">lv_table_set_cell_value_fmt(table, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;%d&quot;</span>, <span class="number">100</span> );<span class="comment">/* 格式化输入，类似printf */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL(一)基础对象</title>
      <link href="/2024/09/22/LVGL/LVGL-1-%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/09/22/LVGL/LVGL-1-%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、对象的创建和基础设置"><a href="#一、对象的创建和基础设置" class="headerlink" title="一、对象的创建和基础设置"></a>一、对象的创建和基础设置</h1><h2 id="1-1-代码"><a href="#1-1-代码" class="headerlink" title="1.1 代码"></a>1.1 代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = lv_obj_create(lv_screen_active()); <span class="comment">//在当前活动的屏幕上创建一个对象</span></span><br><span class="line">lv_obj_set_size(obj, LV_PCT(<span class="number">40</span>), LV_PCT(<span class="number">30</span>));<span class="comment">//设置 obj 对象的尺寸</span></span><br><span class="line">lv_obj_align(obj, LV_ALIGN_CENTER, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">//将 obj 对象对齐</span></span><br></pre></td></tr></table></figure><h2 id="1-2-说明"><a href="#1-2-说明" class="headerlink" title="1.2 说明"></a>1.2 说明</h2><ul><li><code>lv_screen_active()</code>获取当前活动屏幕</li><li><code>LV_PCT(40)</code>宽度占屏幕宽度的 40%。</li><li><code>LV_ALIGN_CENTER</code>将对象对齐到屏幕的中心位置</li><li><code>0，0</code>相对位置偏移量，意味着对象的中心点与屏幕的中心对齐，没有偏移</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> * obj = lv_obj_create(lv_screen_active());<span class="comment">//窗机爱你对象</span></span><br><span class="line">lv_obj_set_size(obj,<span class="number">300</span>, <span class="number">300</span>);   <span class="comment">//设置对象宽高</span></span><br><span class="line"></span><br><span class="line">lv_obj_update_layout(obj);   <span class="comment">//强制计算大小</span></span><br><span class="line"></span><br><span class="line">LV_LOG_USER(<span class="string">&quot;w:%d\n&quot;</span>, lv_obj_get_width(obj));      <span class="comment">//获取对象宽度</span></span><br><span class="line">LV_LOG_USER(<span class="string">&quot;h:%d\n&quot;</span>, lv_obj_get_height(obj));     <span class="comment">//获取对象高度</span></span><br><span class="line">LV_LOG_USER(<span class="string">&quot;content_w:%d&quot;</span>, lv_obj_get_content_width(obj));<span class="comment">//对象实际可用的宽度</span></span><br><span class="line">LV_LOG_USER(<span class="string">&quot;content_h:%d&quot;</span>, lv_obj_get_content_height(obj));<span class="comment">//获取对象实际可用的高度</span></span><br></pre></td></tr></table></figure><ul><li><code>LV_LOG_USER()</code>控制台输出数据</li></ul><h1 id="二、位置"><a href="#二、位置" class="headerlink" title="二、位置"></a>二、位置</h1><h2 id="2-1-LCD坐标系"><a href="#2-1-LCD坐标系" class="headerlink" title="2.1 LCD坐标系"></a>2.1 LCD坐标系</h2><p><img src="/2024/09/22/LVGL/LVGL-1-%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1/1.png" alt="WebGL屏幕坐标系、canvas坐标系和WebGL坐标系转换——学习笔记_canvas to webgl-CSDN博客"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、盒子模型"><a href="#三、盒子模型" class="headerlink" title="三、盒子模型"></a>三、盒子模型</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h1 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h1><ul><li><strong>在屏幕上创建开关部件switch</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>* switch1 = lv_switch_create(lv_scr_act());</span><br></pre></td></tr></table></figure><ul><li><strong>在按键switch1上创建开关部件switch2</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>* switch2 = lv_switch_create(switch1);</span><br></pre></td></tr></table></figure><h1 id="二、设置大小"><a href="#二、设置大小" class="headerlink" title="二、设置大小"></a>二、设置大小</h1><ul><li><strong>设置宽度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_width(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> width);</span><br></pre></td></tr></table></figure><ul><li><strong>设置高度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_height(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> height);</span><br></pre></td></tr></table></figure><ul><li><strong>同时设置宽度和高度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> width, <span class="type">lv_coord_t</span> height);</span><br></pre></td></tr></table></figure><h1 id="三、设置位置"><a href="#三、设置位置" class="headerlink" title="三、设置位置"></a>三、设置位置</h1><ul><li><strong>原点为(0,0)，X轴向右，Y轴向下</strong></li><li><strong>若屏幕像素为800*480，则原点的对点为(799,470)</strong></li><li><strong>子类以父类的左上角为原点，超出父对象的区域不显示</strong></li><li><strong>设置X轴坐标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_x(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> x);</span><br></pre></td></tr></table></figure><ul><li><strong>设置Y轴坐标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_y(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> y);</span><br></pre></td></tr></table></figure><ul><li><strong>同时设置X、Y轴坐标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_pos(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> x, <span class="type">lv_coord_t</span> y);</span><br></pre></td></tr></table></figure><h1 id="四、设置对齐方式"><a href="#四、设置对齐方式" class="headerlink" title="四、设置对齐方式"></a>四、设置对齐方式</h1><h2 id="1-参照父对象对齐"><a href="#1-参照父对象对齐" class="headerlink" title="1. 参照父对象对齐"></a>1. 参照父对象对齐</h2><ul><li>参照父对象对齐</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_align(<span class="type">lv_obj_t</span> * obj, <span class="comment">//子对象</span></span><br><span class="line">                 <span class="type">lv_align_t</span> align); <span class="comment">//对齐模式 LV_ALIGN_XXXX</span></span><br></pre></td></tr></table></figure><ul><li>参照父对象对齐，在进行偏移</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_align(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">           <span class="type">lv_align_t</span> align,    <span class="comment">//对齐模式 LV_ALIGN_XXXX</span></span><br><span class="line">           <span class="type">lv_coord_t</span> x_ofs,<span class="comment">//X轴偏移量</span></span><br><span class="line">           <span class="type">lv_coord_t</span> y_ofs);<span class="comment">//Y轴偏移量</span></span><br></pre></td></tr></table></figure><h2 id="2-参照其它对象对齐"><a href="#2-参照其它对象对齐" class="headerlink" title="2. 参照其它对象对齐"></a>2. 参照其它对象对齐</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_align_to(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">         <span class="type">const</span> <span class="type">lv_obj_t</span> * base,    <span class="comment">//参照对象</span></span><br><span class="line">              <span class="type">lv_align_t</span> align,    <span class="comment">//对齐模式 LV_ALIGN_XXXX</span></span><br><span class="line">              <span class="type">lv_coord_t</span> x_ofs,    <span class="comment">//X轴偏移量</span></span><br><span class="line">              <span class="type">lv_coord_t</span> y_ofs);   <span class="comment">//Y轴偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-对齐模式"><a href="#3-对齐模式" class="headerlink" title="3. 对齐模式"></a>3. 对齐模式</h2><table><thead><tr><th align="center"></th><th align="center">OUT_TOP_LEFT</th><th align="center">OUT_TOP_MID</th><th align="center">OUT_TOP_RIGHT</th><th align="center"></th></tr></thead><tbody><tr><td align="center"><strong>OUT_LEFT_TOP</strong></td><td align="center"><strong>TOP_LEFT</strong></td><td align="center"><strong>TOP_MID</strong></td><td align="center"><strong>TOP_RIGHT</strong></td><td align="center"><strong>OUT_RIGHT_TOP</strong></td></tr><tr><td align="center"><strong>OUT_LEFT_MID</strong></td><td align="center"><strong>LEFT_MID</strong></td><td align="center"><strong>CENTER</strong></td><td align="center"><strong>RIGHT_MID</strong></td><td align="center"><strong>OUT_RIGHT_MID</strong></td></tr><tr><td align="center"><strong>OUT_LEFT_BOTTOM</strong></td><td align="center"><strong>BOTTOM_LEFT</strong></td><td align="center"><strong>BOTTOM_MID</strong></td><td align="center"><strong>BOTTOM_RIGHT</strong></td><td align="center"><strong>OUT_RIGHT_BOTTOM</strong></td></tr><tr><td align="center"></td><td align="center"><strong>OUT_BOTTOM_LEFT</strong></td><td align="center"><strong>OUT_BOTTOM_MID</strong></td><td align="center"><strong>OUT_BOTTOM_RIGHT</strong></td><td align="center"></td></tr></tbody></table><h1 id="五、设置样式"><a href="#五、设置样式" class="headerlink" title="五、设置样式"></a>五、设置样式</h1><ul><li><strong>样式用于设置部件的外观，以优化显示界面和实现用户交互</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">lv_style_t</span> style;<span class="comment">//定义样式变量</span></span><br><span class="line">lv_style_init(&amp;style);<span class="comment">//初始化样式</span></span><br><span class="line">lv_style_set_bg_color(&amp;style,lv_color_hex(<span class="number">0xf4183</span>));<span class="comment">//设置背景颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">lv_obj_t</span> *obj = lv_boj_create(lv_scr_act());  <span class="comment">//创建一个部件</span></span><br><span class="line">lv_obj_add_style(obj,&amp;style,LV_STATE_DEFAULT);<span class="comment">//设置部件的样式</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加本地样式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *obj = lv_boj_create(lv_scr_act());<span class="comment">//创建一个部件</span></span><br><span class="line">lv_obj_set_style_bg_color(boj,  <span class="comment">//子对象</span></span><br><span class="line">       lv_color_hex(<span class="number">0xf4b183</span>),  <span class="comment">//设置颜色</span></span><br><span class="line">            LV_STATE_DEFAULT);<span class="comment">//样式何时生效</span></span><br></pre></td></tr></table></figure><h1 id="六、设置事件"><a href="#六、设置事件" class="headerlink" title="六、设置事件"></a>六、设置事件</h1><ul><li><strong>在LVGL中，当发生用户感兴趣的事情时，可以触发<u>回调事件</u>，以执行相关操作</strong></li><li><strong>添加事件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_event_cb(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">            <span class="type">lv_event_cb_t</span> event_cb,    <span class="comment">//事件回调函数，自己定义</span></span><br><span class="line">            <span class="type">lv_event_code_t</span> filter,    <span class="comment">//事件类型</span></span><br><span class="line">                  <span class="type">void</span> * user_data);   <span class="comment">//用户数据</span></span><br></pre></td></tr></table></figure><ul><li><strong>删除事件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_remove_event_cb(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">               <span class="type">lv_event_cb_t</span> event_cb);   a<span class="comment">//事件回调函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>不同的事件类型共用同一个回调函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="type">lv_event_t</span>* e)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_event_code code = lv_event_get_code(e);<span class="comment">//获取事件类型</span></span><br><span class="line">    <span class="keyword">if</span>(code == LV_EVENT_CLICKED)     <span class="comment">//判断事件类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;事件类型，按下后释放\r\n&quot;</span>);  <span class="comment">//执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(code == LV_EVENT_LONG_PRESSED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;事件类型按下（长按）\r\n&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>不同的部件共用同一个回调函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="type">lv_event_t</span>* e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> *target = lv_event_get_target(e);<span class="comment">//获取触发事件的部件</span></span><br><span class="line">    <span class="keyword">if</span>(target == target_obj)       <span class="comment">//判断触发事件的部件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父对象触发事件\r\n&quot;</span>);      <span class="comment">//执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target == child_obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子对象触发事件\r\n&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LVGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I2C通信协议</title>
      <link href="/2024/09/21/RTC/"/>
      <url>/2024/09/21/RTC/</url>
      
        <content type="html"><![CDATA[<h1 id="一、RTC-Init"><a href="#一、RTC-Init" class="headerlink" title="一、RTC_Init()"></a>一、RTC_Init()</h1><h2 id="1-1-RTC-HandleTypeDef"><a href="#1-1-RTC-HandleTypeDef" class="headerlink" title="1.1 RTC_HandleTypeDef"></a>1.1 RTC_HandleTypeDef</h2><ul><li><strong>Instance</strong>:指向 RTC 外设寄存器基地址</li><li><strong>Init</strong>:包含初始化 RTC 所需的参数</li><li><strong>Lock</strong>:用于锁定和解锁 RTC 外设</li><li><strong>State</strong>:定义 RTC 的状态</li></ul><h2 id="1-2-RTC-InitTypeDef"><a href="#1-2-RTC-InitTypeDef" class="headerlink" title="1.2 RTC_InitTypeDef"></a>1.2 RTC_InitTypeDef</h2><ul><li><strong>HourFormat</strong>:设置 RTC 的小时制格式</li></ul><p>​<code>RTC_HOURFORMAT_24</code>:使用 24 小时制</p><p>​<code>RTC_HOURFORMAT_12</code>:使用 12 小时制</p><ul><li><strong>AsynchPrediv</strong>:设置 RTC 外设的异步预分频器</li></ul><p>​<code>通常设置为 127</code></p><ul><li><strong>SynchPrediv</strong>:RTC 的同步预分频器</li></ul><p>​<code>通常设置为 255</code></p><ul><li><strong>OutPut</strong>:选择将哪个信号输出到 RTC 输出引脚</li></ul><p>​<code>RTC_OUTPUT_DISABLE</code>:禁用 RTC 输出</p><p>​<code>RTC_OUTPUT_ALARMA</code>:闹钟 A 输出</p><p>​<code>RTC_OUTPUT_ALARMB</code>:闹钟 B 输出</p><p>​<code>RTC_OUTPUT_WAKEUP</code>:唤醒信号输出</p><ul><li><strong>OutPutPolarity</strong>:配置输出信号的极性</li></ul><p>​<code>RTC_OUTPUT_POLARITY_HIGH</code>:输出高电平</p><p>​<code>RTC_OUTPUT_POLARITY_LOW</code>:输出低电平</p><ul><li><strong>OutPutType</strong>:配置 RTC 输出引脚的类型</li></ul><p>​<code>RTC_OUTPUT_TYPE_OPENDRAIN</code>:开漏模式</p><p>​<code>RTC_OUTPUT_TYPE_PUSHPULL</code>:推挽模式</p><h2 id="1-3-HAL-RTC-Init"><a href="#1-3-HAL-RTC-Init" class="headerlink" title="1.3 HAL_RTC_Init()"></a>1.3 HAL_RTC_Init()</h2><p>HAL_RTC_Init(RTC_HandleTypeDef *hrtc)</p><p>调用函数初始化1.1 1.2的配置</p><h2 id="1-4-RTC事件设置"><a href="#1-4-RTC事件设置" class="headerlink" title="1.4 RTC事件设置"></a>1.4 RTC事件设置</h2><h3 id="1-4-1-RTC-TimeTypeDef"><a href="#1-4-1-RTC-TimeTypeDef" class="headerlink" title="1.4.1 RTC_TimeTypeDef"></a>1.4.1 RTC_TimeTypeDef</h3><ul><li><strong>Hours</strong>：小时</li></ul><p>​<code>0 到 23</code>或<code> 1 到 12</code></p><ul><li><strong>Minutes</strong>：分钟</li></ul><p>​<code> 0 到 59</code></p><ul><li><strong>Seconds</strong>：秒钟</li></ul><p>​<code> 0 到 59</code></p><ul><li><strong>TimeFormat</strong>：指示时间是 12 小时制还是 24 小时制</li></ul><p>​<code>RTC_HOURFORMAT_12</code>:12 小时制</p><p>​<code>RTC_HOURFORMAT_24</code>:24 小时制</p><ul><li><p><strong>SubSeconds</strong>：表示秒钟的更高精度</p></li><li><p><strong>SecondFraction</strong>：表示时间的分数部分</p></li><li><p><strong>DayLightSaving</strong>：指示是否启用了夏令时</p></li></ul><p>​<code>RTC_DAYLIGHTSAVING_SUB1H</code>:夏令时减去 1 小时</p><p>​<code>RTC_DAYLIGHTSAVING_ADD1H</code>:夏令时加上 1 小时</p><p>​<code>RTC_DAYLIGHTSAVING_NONE</code>:不使用夏令时</p><ul><li><strong>StoreOperation</strong>：是否在某些操作中存储 RTC 时间</li></ul><p>​<code>RTC_STOREOPERATION_RESET</code>:重置 RTC 存储操作</p><p>​<code>RTC_STOREOPERATION_SET</code>:设置 RTC 存储操作</p><h3 id="1-4-2-HAL-RTC-SetTime-设置时间"><a href="#1-4-2-HAL-RTC-SetTime-设置时间" class="headerlink" title="1.4.2 HAL_RTC_SetTime()设置时间"></a>1.4.2 HAL_RTC_SetTime()设置时间</h3><p>HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)</p><ul><li><p><strong>hrtc</strong>:指向 <code>RTC_HandleTypeDef</code> 结构体的指针</p></li><li><p><strong>sTime</strong>:1.4.1配置的结构体</p></li><li><p><strong>Format</strong>：RTC 日期和时间格式</p></li></ul><p>​<code>RTC_FORMAT_BIN </code>:二进制格式<br>​<code>RTC_FORMAT_BCD</code>:BCD 格式</p><h3 id="1-4-3-RTC-DateTypeDef"><a href="#1-4-3-RTC-DateTypeDef" class="headerlink" title="1.4.3 RTC_DateTypeDef"></a>1.4.3 RTC_DateTypeDef</h3><ul><li><strong>WeekDay</strong>：当前日期是星期几</li><li><strong>Month</strong>：当前日期的月份</li><li><strong>Date</strong>：当前月份中的日期</li><li><strong>Year</strong>：当前年份（2023年为23）</li></ul><h3 id="1-4-4-HAL-RTC-SetDate-设置日期"><a href="#1-4-4-HAL-RTC-SetDate-设置日期" class="headerlink" title="1.4.4 HAL_RTC_SetDate()设置日期"></a>1.4.4 HAL_RTC_SetDate()设置日期</h3><p>HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)</p><ul><li><p><strong>hrtc</strong>:指向 <code>RTC_HandleTypeDef</code> 结构体的指针</p></li><li><p><strong>sTime</strong>:1.4.3配置的结构体</p></li><li><p><strong>Format</strong>：RTC 日期和时间格式</p></li></ul><p>​<code>RTC_FORMAT_BIN </code>: 二进制格式<br>​<code>RTC_FORMAT_BCD</code>:BCD 格式</p><h2 id="1-5-设置闹钟"><a href="#1-5-设置闹钟" class="headerlink" title="1.5 设置闹钟"></a>1.5 设置闹钟</h2><h3 id="1-5-1-RTC-AlarmTypeDef"><a href="#1-5-1-RTC-AlarmTypeDef" class="headerlink" title="1.5.1 RTC_AlarmTypeDef"></a>1.5.1 RTC_AlarmTypeDef</h3><ul><li><strong>AlarmTime</strong>：指定 RTC 闹钟的时间部分</li><li><strong>AlarmMask</strong>：设置 RTC 闹钟触发时应忽略哪些时间部分</li></ul><p>​<code>RTC_ALARMMASK_NONE</code>:不忽略任何字段</p><p>​<code>RTC_ALARMMASK_DATEWEEKDAY</code>:忽略日期和星期字段</p><p>​<code>RTC_ALARMMASK_HOURS</code>:忽略小时字段</p><p>​<code>RTC_ALARMMASK_MINUTES</code>:忽略分钟字段</p><p>​<code>RTC_ALARMMASK_SECONDS</code>:忽略秒字段</p><p>​<code>RTC_ALARMMASK_ALL</code>:忽略所有字段</p><ul><li><strong>AlarmSubSecondMask</strong>：设置 RTC 闹钟触发时应忽略的子秒部分</li><li><strong>AlarmDateWeekDaySel</strong>：选择闹钟基于<strong>日期</strong>还是<strong>星期几</strong>触发</li></ul><p>​<code>RTC_ALARMDATEWEEKDAYSEL_DATE</code>:选择<strong>日期</strong>触发闹钟</p><p>​<code>RTC_ALARMDATEWEEKDAYSEL_WEEKDAY</code>:选择<strong>星期几</strong>触发闹钟</p><ul><li><strong>AlarmDateWeekDay</strong>：<ul><li>如果选择了日期触发，则此字段指定具体的日期（1 到 31）</li><li>如果选择了星期触发，则此字段指定星期几（如 <code>RTC_WEEKDAY_MONDAY</code> 表示星期一）</li></ul></li><li><strong>Alarm</strong>：指定闹钟的类型或其他相关配置</li></ul><p>​<code>RTC_ALARM_A</code>:闹钟A</p><p>​<code>RTC_ALARM_B</code>:闹钟B</p><h3 id="1-5-2-RTC-TimeTypeDef"><a href="#1-5-2-RTC-TimeTypeDef" class="headerlink" title="1.5.2 RTC_TimeTypeDef"></a>1.5.2 RTC_TimeTypeDef</h3><p>同1.2配置</p><h2 id="1-6-HAL-RTC-SetAlarm-IT"><a href="#1-6-HAL-RTC-SetAlarm-IT" class="headerlink" title="1.6 HAL_RTC_SetAlarm_IT()"></a>1.6 HAL_RTC_SetAlarm_IT()</h2><p>HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)</p><p>设定1.5.2的配置</p><ul><li><p><strong>hrtc</strong>:指向 <code>RTC_HandleTypeDef</code> 结构体的指针</p></li><li><p><strong>sAlarm</strong>:指向<code>RTC_AlarmTypeDef</code> 结构体的指针</p></li><li><p><strong>Format</strong>:指时间格式</p></li></ul><p>调用此函数初始化1.5中的配置</p><h2 id="1-7-唤醒定时器"><a href="#1-7-唤醒定时器" class="headerlink" title="1.7 唤醒定时器"></a>1.7 唤醒定时器</h2><p>HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)</p><ul><li><strong>hrtc</strong>：指向 RTC 句柄的指针</li><li><strong>WakeUpCounter</strong>：设置唤醒定时器的计数器值</li><li><strong>WakeUpClock</strong>：唤醒定时器的时钟源</li></ul><p>​<code>RTC_WAKEUPCLOCK_RTCCLK_DIV16</code>:分频为 <strong>16</strong></p><p>​<code>RTC_WAKEUPCLOCK_RTCCLK_DIV8</code>:分频为 <strong>8</strong></p><p>​<code>RTC_WAKEUPCLOCK_RTCCLK_DIV4</code>:分频为 <strong>4</strong></p><p>​<code>RTC_WAKEUPCLOCK_RTCCLK_DIV2</code>:分频为 <strong>2</strong></p><p>​<code>RTC_WAKEUPCLOCK_CK_SPRE_16BITS</code>: 16 位的分频时钟作为唤醒时钟源</p><p>​<code>RTC_WAKEUPCLOCK_CK_SPRE_17BITS</code>:选择 17 位的分频时钟作为唤醒时钟源</p><h1 id="二、唤醒中断"><a href="#二、唤醒中断" class="headerlink" title="二、唤醒中断"></a>二、唤醒中断</h1><h2 id="2-1-RTC-WKUP-IRQHandler"><a href="#2-1-RTC-WKUP-IRQHandler" class="headerlink" title="2.1 RTC_WKUP_IRQHandler()"></a>2.1 RTC_WKUP_IRQHandler()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RTC_WKUP_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_RTCEx_WakeUpTimerIRQHandler(&amp;hrtc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-回调函数"><a href="#2-2-回调函数" class="headerlink" title="2.2 回调函数"></a>2.2 回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_RTCEx_WakeUpTimerEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br></pre></td></tr></table></figure><h1 id="三、闹钟时间中断"><a href="#三、闹钟时间中断" class="headerlink" title="三、闹钟时间中断"></a>三、闹钟时间中断</h1><h2 id="3-1-RTC-Alarm-IRQHandler"><a href="#3-1-RTC-Alarm-IRQHandler" class="headerlink" title="3.1 RTC_Alarm_IRQHandler()"></a>3.1 RTC_Alarm_IRQHandler()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RTC_Alarm_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_RTC_AlarmIRQHandler(&amp;hrtc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-闹钟回调函数"><a href="#3-2-闹钟回调函数" class="headerlink" title="3.2 闹钟回调函数"></a>3.2 闹钟回调函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_RTC_AlarmAEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//闹钟A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_RTCEx_AlarmBEventCallback</span><span class="params">(RTC_HandleTypeDef *hrtc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//闹钟B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    RTC_TimeTypeDef nowTime;</span></span><br><span class="line"><span class="comment">//    RTC_DateTypeDef nowData;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(HAL_RTC_GetTime(hrtc,&amp;nowTime,RTC_FORMAT_BCD) == HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        HAL_RTC_GetDate(hrtc,&amp;nowData,RTC_FORMAT_BCD);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IT：日期 %d/%d/%d 时间：%d:%d:%d\r\n&quot;</span>,nowData.Year+<span class="number">2000</span>,nowData.Month,nowData.Date,nowTime.Hours,nowTime.Minutes,nowTime.Seconds);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通讯协议 </tag>
            
            <tag> I2C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I2C通信协议</title>
      <link href="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/"/>
      <url>/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1SatHeBEVG?spm_id_from=333.788.player.switch&vd_source=daf1db3c953df56f74e76077dfa61ab4&p=16">第16节 第二步模拟IIC之——PP推免和OD开漏模式对比_哔哩哔哩_bilibili</a></p><h1 id="一、I2C协议简介"><a href="#一、I2C协议简介" class="headerlink" title="一、I2C协议简介"></a>一、I2C协议简介</h1><p>实验板：蓝桥杯嵌入式，STM32G4RBT6</p><ul><li>I2C是一种简单的<u>双向两线制</u>总线协议标准，支持<u>同步串行半双工</u>通讯。</li><li>SDA:双向串行数据总线，只能一位一位的发送数据。</li><li>SCL:串行时钟线，用于数据收发同步</li><li>半双工通信：可以实现双向的通信，但不能在两个方向上同时进行，必须交替进行，</li></ul><h1 id="二、I2C物理层"><a href="#二、I2C物理层" class="headerlink" title="二、I2C物理层"></a>二、I2C物理层</h1><h2 id="设备间的常用连接方式"><a href="#设备间的常用连接方式" class="headerlink" title="设备间的常用连接方式"></a>设备间的常用连接方式</h2><ul><li><strong>在一个I2C通信总线中，可以连接多个I2C通讯设备。支持多个通讯主机和多个通信从机。</strong></li></ul><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/1.png" alt="image-20240920153511997"></p><h1 id="三、I2C协议层"><a href="#三、I2C协议层" class="headerlink" title="三、I2C协议层"></a>三、I2C协议层</h1><p><strong><u>主机写数据到从机</u></strong></p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/2.png" alt="image-20240920154403849"><ul><li><strong>在I2C总线上，<u>每个设备的地址都是唯一的</u>，当主机广播的地址与某个设备地址相同时，设备会自动匹配，匹配成功后，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。</strong></li><li><strong>主机发送完数据，从机应答了，主机照样可以直接发送停止信号终止通讯。</strong></li><li><strong>从机地址可以是<u>7位</u>或者<u>10位</u>，在地址位之后，是读写的权限的选择位，0表示写权限，1表示读权限。</strong></li><li><strong>I2C规定，通信时的时钟，起始信号，停止信号<u>只能</u>由主机产生。</strong></li></ul><p><u><strong>主机从从机读取数据</strong></u></p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/3.png" alt="image-20240920160821303"><ul><li><strong>在接受到任何数据时，无论时主机还是从机，都要做出应答信号（我还要数据）或非应答信号（我不要数据了）</strong></li></ul><p><strong><u>读写数据混合格式</u></strong></p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/4.png" alt="8d6a0670-ca9e-473b-b625-d6da0fab7cee"><ul><li><strong>第一次通讯是确定读写从机设备内部寄存器或存储器的地址</strong></li><li><strong>第二次则是<u>读或写</u>上一次确定内部寄存器或存储器的地址上面的数据。</strong></li></ul><h2 id="3-1-空闲状态"><a href="#3-1-空闲状态" class="headerlink" title="3.1 空闲状态"></a>3.1 空闲状态</h2><p><strong>I2C总线的SDA和SCL两条信号线<u>同时处于高电平</u>时，则为总线空闲状态，所有挂载在总线上的设备都输出高阻态（相当于断开与总线的连接），两条总线被上拉电阻的把电平拉高。</strong></p><h2 id="3-2-起始信号与停止信号"><a href="#3-2-起始信号与停止信号" class="headerlink" title="3.2 起始信号与停止信号"></a>3.2 起始信号与停止信号</h2><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/5.png" alt="image-20240920180358340" style="zoom:80%;"><p><strong>起始信号：当<u>SCL线在高电平</u>期间 SDA 线<u>由高电平向低电平切换</u></strong><br><strong>停止信号：当<u>SCL线在高电平</u>期间 SDA 线<u>由低电平向高电平切换</u></strong></p><p><strong>传输数据：<u>当SCL线在高电平</u>期间SDA 线<u>电平状态保持不变</u>，否则会误判为起始或停止</strong></p><p><u><em><strong>起始信号和停止信号只能由主机产生</strong></em></u></p><h2 id="3-3-数据有效性"><a href="#3-3-数据有效性" class="headerlink" title="3.3 数据有效性"></a>3.3 数据有效性</h2><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/6.png" alt="021ca9d7-3767-4b9b-a25b-8905ab64172e" style="zoom:80%;"><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/7.png" alt="image-20240920182422762" style="zoom:80%;"><ul><li><strong>SDA数据线在SCL的每个时钟周期（时钟脉冲）传输一位数据</strong></li><li><strong>SCL为高电平期间：SDA表示数据有效，此时SDA的电平要稳定，SDA的高低电平代表数据1或0</strong></li><li><strong>SCL为低电平时：SDA的数据无效，一般在这个时候SDA进行电平转化，为下次数据传输做准备</strong></li><li><strong>数据和地址进行传输时，&#x3D;&#x3D;先传输高位&#x3D;&#x3D;，每次传输的字节不受限制</strong></li></ul><h2 id="3-4-地址及数据方向"><a href="#3-4-地址及数据方向" class="headerlink" title="3.4 地址及数据方向"></a>3.4 地址及数据方向</h2><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/8.png" alt="image-20240920190314548"><ul><li><strong>读数据方向时，主机会&#x3D;&#x3D;释放对 SDA 信号线的控制&#x3D;&#x3D;，由&#x3D;&#x3D;从机控制 SDA 信号线&#x3D;&#x3D;（向主机发送数据），主机接收信号</strong></li><li><strong>写数据方向时，SDA 由主机控制（向从机发送数据），从机接收信号</strong></li></ul><h2 id="3-5-应答和非应答信号"><a href="#3-5-应答和非应答信号" class="headerlink" title="3.5 应答和非应答信号"></a>3.5 应答和非应答信号</h2><p><strong>I2C 的数据和地址传输都带响应当数据接收端(无论主从机)接收到 I2C 传输的一个字节数据或地址后：</strong></p><ul><li><p><strong>若希望对方继续发送数据，则向对方发送“应答(ACK)”信号(低电平)</strong></p></li><li><p><strong>若希望对方结束数据传输，则向对方发送“非应答(NACK)”信号(高电平)发送方接收到该信号后会产生一个停止信号，结束信号传输。</strong></p></li><li><p><strong>在一个字节传输的8个时钟后的第9个时钟期间，接收器必须回送一个应答位(ACK)或者是非应答位(NACK)给发送器  。</strong></p></li><li><p><strong>在第 9 个时钟时，数据发送端会<u>释放 SDA 的控制权</u>，由<u>数据接收端控制 SDA</u>，给发送端传输应答或非应答信号</strong></p></li></ul><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/9.png" alt="5a15817b-bf12-4c4d-b3cd-c0ad501b5e5e"><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/15.png" alt="image-20240920222354354"></p><h2 id="3-6-写入一个字节时序"><a href="#3-6-写入一个字节时序" class="headerlink" title="3.6 写入一个字节时序"></a>3.6 写入一个字节时序</h2><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/10.png" alt="image-20240920222442639"></p><h2 id="3-7-读出一个字节时序"><a href="#3-7-读出一个字节时序" class="headerlink" title="3.7 读出一个字节时序"></a>3.7 读出一个字节时序</h2><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/11.png" alt="image-20240920222451423"></p><h2 id="3-8-单次写入多个字节时序"><a href="#3-8-单次写入多个字节时序" class="headerlink" title="3.8 单次写入多个字节时序"></a>3.8 单次写入多个字节时序</h2><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/12.png" alt="image-20240920222600643"></p><h2 id="3-9-单次读出多个字节时序"><a href="#3-9-单次读出多个字节时序" class="headerlink" title="3.9 单次读出多个字节时序"></a>3.9 单次读出多个字节时序</h2><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/13.png" alt="image-20240920222553835"></p><h1 id="四、软件IIC"><a href="#四、软件IIC" class="headerlink" title="四、软件IIC"></a>四、软件IIC</h1><h2 id="4-1-开始停止信号"><a href="#4-1-开始停止信号" class="headerlink" title="4.1 开始停止信号"></a>4.1 开始停止信号</h2><h1 id="五、硬件IIC"><a href="#五、硬件IIC" class="headerlink" title="五、硬件IIC"></a>五、硬件IIC</h1><h1 id="六、-实验"><a href="#六、-实验" class="headerlink" title="六、 实验"></a>六、 实验</h1><p><strong>实验：使用STM32F407作实验平台,将数据写入AT24C0，并读取出来</strong></p><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/image-20250427144311918.png" alt="image-20250427144311918"></p><p><strong>ACK</strong>后面<strong>SDA变高</strong>，是从机<strong>停止发出低电平</strong>，<strong>SDA</strong>线出现<strong>短暂高电平</strong></p><h2 id="1-Driver-i2c-h"><a href="#1-Driver-i2c-h" class="headerlink" title="1. Driver_i2c.h"></a>1. Driver_i2c.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DRIVER_IIC_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DRIVER_IIC_H </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NACK 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_HIGH (GPIOB-&gt;ODR |= GPIO_ODR_ODR10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_LOW  (GPIOB-&gt;ODR &amp;= ~GPIO_ODR_ODR10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_HIGH (GPIOB-&gt;ODR |= GPIO_ODR_ODR11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_LOW (GPIOB-&gt;ODR &amp;= ~GPIO_ODR_ODR11)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_SDA (GPIOB-&gt;IDR &amp; GPIO_IDR_IDR11)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 引脚初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_Start</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C2_Stop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 应答信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_Ack</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 非应答信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_NAck</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待接收方的应答 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Driver_I2C2_WaitAck</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送一个字节的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接收一个字节的数据 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Driver_I2C_ReadByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-Driver-i2c-c"><a href="#2-Driver-i2c-c" class="headerlink" title="2. Driver_i2c.c"></a>2. Driver_i2c.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-main-c"><a href="#3-main-c" class="headerlink" title="3. main.c"></a>3. main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/14.png" alt="image-20240921013215257"></p><p><img src="/2024/09/21/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/I2C/15.png" alt="image-20240921013424465"></p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
          <category> 通信协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 通讯协议 </tag>
            
            <tag> I2C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
