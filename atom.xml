<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The personal blog of 洒水水</title>
  
  <subtitle>姚道文</subtitle>
  <link href="https://ydw-item.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://ydw-item.github.io.git/"/>
  <updated>2025-02-25T06:38:49.000Z</updated>
  <id>https://ydw-item.github.io.git/</id>
  
  <author>
    <name>洒水水</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-单链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>     //定义一个结点的数据结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;   Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                                <span class="comment">//创建链表头</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//开辟空间</span></span><br><span class="line">    <span class="built_in">list</span> -&gt;data = <span class="number">0</span>;                            <span class="comment">//头结点值为0</span></span><br><span class="line">    <span class="built_in">list</span> -&gt;next = <span class="literal">NULL</span>;                         <span class="comment">//头结点 指向 NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span>          <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//开辟空间   </span></span><br><span class="line">    node -&gt; data = data;                       <span class="comment">//给新结点赋值</span></span><br><span class="line">    node -&gt; next = <span class="built_in">list</span> -&gt; next;               <span class="comment">//新结点的指针 指向 下一个结点</span></span><br><span class="line">    <span class="built_in">list</span> -&gt; next = node;                       <span class="comment">//头结点的指针 指向 新结点</span></span><br><span class="line">    <span class="built_in">list</span> -&gt; data++;                            <span class="comment">//头结点数据++，代表链表中的结点增多</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点赋值给node</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L -&gt; data; i++)          <span class="comment">//遍历原来的尾结点，i&lt;非头结点的结点数量</span></span><br><span class="line">    &#123;       </span><br><span class="line">        node = node-&gt;next;                      <span class="comment">//两个非头结点移一次，</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//给新结点开辟内存空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//给新结点赋值</span></span><br><span class="line">    n -&gt; next = <span class="literal">NULL</span>;                           <span class="comment">//将新结点指向NULL</span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//原来的为节点node指向 新的尾结点n</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点的值++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                    <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* preNode = L;                            <span class="comment">//将头结点赋值给preNode</span></span><br><span class="line">    Node* node = L -&gt; next;                       <span class="comment">//将头结点的指向的地址赋给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node)                                   <span class="comment">//当node的地址不为空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)                  <span class="comment">//判断node的值是否等于要删除的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;    <span class="comment">//将目标结点指向的地址 赋值给 上一个结点的指针</span></span><br><span class="line">            <span class="built_in">free</span>(node);                           <span class="comment">//释放空间</span></span><br><span class="line">            L -&gt; data--;                          <span class="comment">//链表个数--</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        </span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;                          <span class="comment">//不等于,头节点等于node</span></span><br><span class="line">        node = node -&gt; next;                     <span class="comment">//不等于，node等于node指向的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                          <span class="comment">//打印链表中的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                      <span class="comment">//将头节点指向的结点赋值给node</span></span><br><span class="line">    <span class="keyword">while</span>(node)                                  <span class="comment">//当node不是尾结点时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;node = %d \n&quot;</span>,node -&gt; data);     <span class="comment">//打印node的值</span></span><br><span class="line">        node = node -&gt; next;                     <span class="comment">//更新node的结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    Node* <span class="built_in">list</span> = initList();</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">6</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">7</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">8</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">9</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">10</span>);</span><br><span class="line">    printList(<span class="built_in">list</span>);</span><br><span class="line">    delete(<span class="built_in">list</span>,<span class="number">9</span>);</span><br><span class="line">    printList(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-单循环链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义结点结构体</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>      <span class="comment">//结构体指针，指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化结构体，创建头结点 </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//开辟口结点空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化data数据</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化指针，指向自己</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//开辟结点空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将数据赋值给data</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的的next 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//新结点的地址 赋值给 头结点的node</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* n = L;                                <span class="comment">//将头结点 赋值给 n</span></span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将data 赋值给 新结点的data</span></span><br><span class="line">    <span class="keyword">while</span>(n -&gt; next != L)                       <span class="comment">//使用遍历，判断n的next 是否 指向 头结点，找到最后一个结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        n = n -&gt; next;                          <span class="comment">//不是则更新n</span></span><br><span class="line">    &#125;</span><br><span class="line">    node -&gt; next = L;                           <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    n -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* preNode = L;                          <span class="comment">//将头结点的地址 赋值给 preNode</span></span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next存储的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node的 地址 是否等于 头结点的地址</span></span><br><span class="line">    &#123;               </span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)                <span class="comment">//判断node的data 是否等于 目标值</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next值 赋值给 前一个结点的next</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放目标结点 动态内存空间</span></span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点的数据--</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;                         <span class="comment">//更新preNode</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到目标结点，返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否等于 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node -&gt; data);           <span class="comment">//打应node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//单循环链表，最后一个结点的next应指向头结点，此处代码错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();       <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);           <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);           <span class="comment">//头插 2 </span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);           <span class="comment">//头插 3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);           <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);           <span class="comment">//头插 5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);           <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);           <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">4</span>);               <span class="comment">//删除 4</span></span><br><span class="line">    delete(L, <span class="number">7</span>);               <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-二叉树</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的创建与遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>             //定义二叉树结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createTree</span><span class="params">(TreeNode** T, <span class="type">char</span>* data, <span class="type">int</span>* index)</span>   <span class="comment">//初始化树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = data[*index];                                   </span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时为空节点</span></span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时不为空</span></span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T) -&gt; data = ch;</span><br><span class="line">        <span class="comment">// 创建左子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;lchild), data, index);</span><br><span class="line">        <span class="comment">// 创建右子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;rchild), data, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        preOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        preOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        inOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 中办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        inOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode* T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        postOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        postOrder(T-&gt;rchild);</span><br><span class="line">        <span class="comment">// 后办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* T;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    createTree(&amp;T, argv[<span class="number">1</span>], &amp;index);</span><br><span class="line">    preOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    inOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    postOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-双链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>             //创建结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;   Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//创建链表头结点，分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化链表结点数</span></span><br><span class="line">    L -&gt; pre = <span class="literal">NULL</span>;                        <span class="comment">//初始化pre</span></span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;                       <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> L;                               <span class="comment">//返沪Node类型的指针L</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>           <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//开辟结点动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                     <span class="comment">//结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                <span class="comment">//将头结点next指向的结点地址 赋值给 新的结点</span></span><br><span class="line">    node -&gt; pre = L;                         <span class="comment">//新结点的pre指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L -&gt; next)                           <span class="comment">//判断头结点的next是否是NULL</span></span><br><span class="line">    &#123;                                        <span class="comment">//如果不为空</span></span><br><span class="line">        L -&gt; next -&gt; pre = node;             <span class="comment">//将新结点的地址 赋值给 头结点下一个结点的 pre</span></span><br><span class="line">        L -&gt; next = node;                    <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                     <span class="comment">//当链表中只有头结点时</span></span><br><span class="line">    &#123; </span><br><span class="line">        L -&gt; next = node;                       <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    <span class="keyword">while</span> (node -&gt; next)                        <span class="comment">//遍历到链表最后一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;                                           <span class="comment">//node此时为尾结点</span></span><br><span class="line">    n -&gt; next = node -&gt; next;                   <span class="comment">//将尾结点next指向的地址 赋值给 新结点的next     </span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将尾结点的next指向n   </span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将新结点的pre指向原来的尾结点</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;                                  </span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点next指向的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//如果node不为空结点</span></span><br><span class="line">    &#123;                             </span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)               <span class="comment">//如果node是目标结点 </span></span><br><span class="line">        &#123;     </span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next; <span class="comment">//将node的next 赋值给 node上一个结点的next</span></span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next)                   <span class="comment">//如果node不是尾结点</span></span><br><span class="line">            &#123;                                       </span><br><span class="line">                node -&gt; next -&gt; pre = node -&gt; pre;  <span class="comment">//将node的pre 赋值给 node下一结点的pre</span></span><br><span class="line">            &#125;</span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点数据 --</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放node的空间</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//找到目标值，删除成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//node更新为下一结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到值，删除失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点指向的结点 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//当node不为空时， </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);         <span class="comment">//打印node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node为下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//当node为空结点时打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();                       <span class="comment">//创建链表，初始化头结点</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);                           <span class="comment">//头插1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);                           <span class="comment">//头插2</span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);                           <span class="comment">//头插3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);                           <span class="comment">//头插4</span></span><br><span class="line">    tailInsert(L, <span class="number">5</span>);                           <span class="comment">//尾插5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);                           <span class="comment">//尾插6</span></span><br><span class="line">    printList(L);                               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">6</span>);                               <span class="comment">//删除6</span></span><br><span class="line">    printList(L);                               <span class="comment">//删除链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-双循环链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化头结点，创建链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化头结点的data</span></span><br><span class="line">    L -&gt; pre = L;                           <span class="comment">//初始化头结点的pre，指向自己</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化头结点的next，指向next</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//为新结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    node -&gt; pre = L;                            <span class="comment">//将头头结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    L -&gt; next -&gt; pre = node;                    <span class="comment">//将新结点的地址 赋值给 原来头结点的下一个结点的pre</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 头结点的next </span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L)                     <span class="comment">//判断node是否是最后一个结点</span></span><br><span class="line">    &#123;                                           <span class="comment">//如果不是</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将原来最后一个结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    n -&gt; next = L;                              <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; pre = n;                               <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                       <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                         <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != L)                               <span class="comment">//判断node 是否是 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)                   <span class="comment">//判断node是否是目标结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next的值 赋值给 目标结点的pre指向的结点的next</span></span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;      <span class="comment">//将目标结点的pre的值  赋值给 目标结点的next指向的结点的pre</span></span><br><span class="line">            <span class="built_in">free</span>(node);                             <span class="comment">//释放目标结点的动态内存空间</span></span><br><span class="line">            L -&gt; data --;                           <span class="comment">//头结点的data--</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;                               <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                        <span class="comment">//如果不是目标结点，更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否是 目标结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);           <span class="comment">//打印node的值</span></span><br><span class="line">        node = node-&gt;next;                      <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">///打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();           <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);               <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);               <span class="comment">//头插 2</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);               <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);               <span class="comment">//头插 5</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);               <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);               <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">7</span>);                   <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-队列</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="comment">//往头结点前面入队 ，从头结点后面出队</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义队列的结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initQueue</span><span class="params">()</span>                               <span class="comment">//初始化队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为头结点分配动态内春空间</span></span><br><span class="line">    Q-&gt;data = <span class="number">0</span>;                </span><br><span class="line">    Q-&gt;pre = Q;                                 <span class="comment">//初始化pre</span></span><br><span class="line">    Q-&gt;next = Q;                                <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Node* Q, <span class="type">int</span> data)</span>                         <span class="comment">//入队       </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));           <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                                  <span class="comment">//为新结点赋值</span></span><br><span class="line">    node-&gt;next = Q;                                     <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    node-&gt;pre = Q-&gt;pre;                                 <span class="comment">//将头结点的pre的值 赋值给 新结点的pre</span></span><br><span class="line">    Q-&gt;pre-&gt;next = node;                                <span class="comment">//将新结点的地址 赋值给 头结点的pre指向的结点的next</span></span><br><span class="line">    Q-&gt;pre = node;                                      <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    Q-&gt;data++;                                          <span class="comment">//头结点的data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node* Q)</span>                                    <span class="comment">//判队列是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;data == <span class="number">0</span> || Q-&gt;next == Q)                   <span class="comment">//如果头结点的data == 0，或者头结点的next == 自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                       <span class="comment">//返回 1，代表队列为空</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0，代表队列不为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Node* Q)</span>                                    <span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q))                                     <span class="comment">//判断队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//为空则返回 0</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;                                          </span><br><span class="line">        Node* node = Q-&gt;next;                           <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next;                        <span class="comment">//将头结点的next指向的结点的next的值 赋值给 头结点的next</span></span><br><span class="line">        Q-&gt;next-&gt;pre = Q;                               <span class="comment">//将头结点的地址 赋值给 头结点的next指向的结点的pre</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;data;                              <span class="comment">//返回出队结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Node* Q)</span>                                <span class="comment">//打印队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = Q -&gt; next;                             <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != Q)                                   <span class="comment">//判断node 是否是头结点的地址       </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);                 <span class="comment">//打印node的data</span></span><br><span class="line">        node = node -&gt; next;                            <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = initQueue();                      <span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(Q, <span class="number">1</span>);                              <span class="comment">//1 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">2</span>);                              <span class="comment">//2 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">3</span>);                              <span class="comment">//3 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">4</span>);                              <span class="comment">//4 入队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-栈</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义栈结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">initStack</span><span class="params">()</span>                               <span class="comment">//初始化栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));     <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L-&gt;data = <span class="number">0</span>;                                <span class="comment">//data初始化</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                             <span class="comment">//头结点next指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> L;                                   <span class="comment">//返回头结点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Node *L, <span class="type">int</span> data)</span>                    <span class="comment">//入栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                          <span class="comment">//为data赋值</span></span><br><span class="line">    node-&gt;next = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    L-&gt;next = node;                             <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    L-&gt;data++;                                  <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Node *L)</span>                            <span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span>)                       <span class="comment">//判断栈是否为空栈 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//是空栈则返回 1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Node *node = L-&gt;next;               <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        <span class="type">int</span> data = node-&gt;data;              <span class="comment">//将头结点的下一结点的data 赋值给 data</span></span><br><span class="line">        L-&gt;next = node-&gt;next;               <span class="comment">//将头结点的下一结点的next 赋值给头结点的next</span></span><br><span class="line">        <span class="built_in">free</span>(node);                         <span class="comment">//释放头结点的下一结点的动态内存空间</span></span><br><span class="line">        L-&gt;data--;                          <span class="comment">//将头结点的data--</span></span><br><span class="line">        <span class="keyword">return</span> data;                        <span class="comment">//返回取出的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node *L)</span>                        <span class="comment">//判断是否为空栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span> || L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的data == 0 或者 头结点的next的值为NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">//返回 1，代表此栈为空栈</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//返回 0，代表此栈不是空栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Node *<span class="built_in">stack</span>)</span>            <span class="comment">//打印栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = <span class="built_in">stack</span>-&gt;next;           <span class="comment">//将头结点的next的值 赋值给node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                        <span class="comment">//判断node是否为NULL</span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);   <span class="comment">//打印node的data</span></span><br><span class="line">        node = node-&gt;next;              <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node *<span class="built_in">stack</span> = initStack();          <span class="comment">//创建栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">1</span>);                     <span class="comment">//1 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">2</span>);                     <span class="comment">//2 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">3</span>);                     <span class="comment">//3 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">4</span>);                     <span class="comment">//4 入栈</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pop = %d\n&quot;</span>, pop(<span class="built_in">stack</span>));   <span class="comment">//出战</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-循环队列</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要知道队列当前有多少个元素</span></span><br><span class="line">    <span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">    <span class="type">int</span> index = Q-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, Q-&gt;data[index]);</span><br><span class="line">        index = (index + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(Queue* Q, <span class="type">int</span> data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = data;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data = Q-&gt;data[Q-&gt;front];</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-暴力匹配</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span>       //定义字符串结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125; String;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String* <span class="title function_">initString</span><span class="params">()</span>                                <span class="comment">//初始化字符串 </span></span><br><span class="line">&#123;</span><br><span class="line">    String* s = (String*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(String));    <span class="comment">//为字符串开辟动态内存空间</span></span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>;                                 <span class="comment">//为</span></span><br><span class="line">    s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringAssign</span><span class="params">(String* s, <span class="type">char</span>* data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;data) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* temp = data;</span><br><span class="line">    <span class="keyword">while</span> (*temp) </span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        temp = data;</span><br><span class="line">        s-&gt;len = len;</span><br><span class="line">        s-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++, temp++) </span><br><span class="line">        &#123;</span><br><span class="line">            s-&gt;data[i] = *temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printString</span><span class="params">(String* s)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s-&gt;len; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(i == <span class="number">0</span> ? <span class="string">&quot;%c &quot;</span> : <span class="string">&quot;-&gt; %c &quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceMatch</span><span class="params">(String* master, String* sub)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp; j &lt; sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;data[i] == sub-&gt;data[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match success.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match fail.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    String* s = initString();</span><br><span class="line">    String* s1 = initString();</span><br><span class="line">    stringAssign(s, argv[<span class="number">1</span>]);</span><br><span class="line">    stringAssign(s1, argv[<span class="number">2</span>]);</span><br><span class="line">    printString(s);</span><br><span class="line">    printString(s1);</span><br><span class="line">    forceMatch(s, s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ADC</title>
    <link href="https://ydw-item.github.io.git/2025/02/24/ADC/"/>
    <id>https://ydw-item.github.io.git/2025/02/24/ADC/</id>
    <published>2025-02-24T11:18:30.000Z</published>
    <updated>2025-02-24T11:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HAL-ADC-Init"><a href="#HAL-ADC-Init" class="headerlink" title="HAL_ADC_Init()"></a>HAL_ADC_Init()</h1><p><code>HAL_ADC_Init()</code> 是 STM32 HAL 库中的一个函数，用于初始化 ADC 外设。通过此函数，你可以配置 ADC 的基本参数，如分辨率、数据对齐方式、扫描模式等。它是使用 ADC 外设之前必需的初始化步骤。</p><h1 id="HAL-ADC-DeInit"><a href="#HAL-ADC-DeInit" class="headerlink" title="HAL_ADC_DeInit()"></a>HAL_ADC_DeInit()</h1><p><code>HAL_ADC_DeInit()</code> 用于反初始化 ADC 外设，将其恢复到默认的初始状态。这通常用于在不再需要 ADC 时禁用其工作，或者在配置 ADC 的其他工作模式之前调用，以清除之前的配置。</p><h1 id="HAL-ADC-MspInit"><a href="#HAL-ADC-MspInit" class="headerlink" title="HAL_ADC_MspInit()"></a>HAL_ADC_MspInit()</h1><p><code>HAL_ADC_MspInit()</code> 是一个与底层硬件相关的函数，用于初始化 ADC 外设所需的硬件资源。这通常包括启用外设时钟、配置 GPIO 引脚（如果需要）、配置中断、DMA 设置等。此函数通常在 <code>HAL_ADC_Init()</code> 调用时自动执行。</p><h1 id="HAL-ADC-MspDeInit"><a href="#HAL-ADC-MspDeInit" class="headerlink" title="HAL_ADC_MspDeInit()"></a>HAL_ADC_MspDeInit()</h1><p><code>HAL_ADC_MspDeInit()</code> 是与底层硬件相关的反初始化函数，用于恢复 ADC 外设的硬件资源，通常是在 <code>HAL_ADC_DeInit()</code> 调用时自动执行。此函数会禁用 ADC 外设所需的硬件资源，如时钟、GPIO 配置、中断等。</p><h1 id="HAL-ADC-Start"><a href="#HAL-ADC-Start" class="headerlink" title="HAL_ADC_Start()"></a>HAL_ADC_Start()</h1><p><code>HAL_ADC_Start()</code> 是 STM32 HAL 库中的一个函数，用于启动 ADC 外设的转换过程。它启动一个单次的 ADC 转换，或者在连续模式下，启动 ADC 并开始定期转换。</p><h1 id="HAL-ADC-Stop"><a href="#HAL-ADC-Stop" class="headerlink" title="HAL_ADC_Stop()"></a>HAL_ADC_Stop()</h1><p><code>HAL_ADC_Stop()</code> 用于停止 ADC 转换。调用此函数后，ADC 将停止转换过程，不再进行数据采样。</p><h1 id="HAL-ADC-PollForConversion"><a href="#HAL-ADC-PollForConversion" class="headerlink" title="HAL_ADC_PollForConversion()"></a>HAL_ADC_PollForConversion()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_PollForConversion</span><span class="params">(ADC_HandleTypeDef* hadc, <span class="type">uint32_t</span> Timeout)</span>;</span><br></pre></td></tr></table></figure><p><code>HAL_ADC_PollForConversion()</code> 是 STM32 HAL 库中的一个函数，用于在<strong>轮询模式</strong>下<strong>等待 ADC 转换完成</strong>。该函数会在<strong>指定的超时时间内不断检查 ADC 转换是否完成</strong>，如果完成则返回成功，否则会在超时后返回失败。</p><h1 id="HAL-ADC-PollForEvent"><a href="#HAL-ADC-PollForEvent" class="headerlink" title="HAL_ADC_PollForEvent()"></a>HAL_ADC_PollForEvent()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_ADC_PollForEvent</span><span class="params">(ADC_HandleTypeDef* hadc, <span class="type">uint32_t</span> EventType, <span class="type">uint32_t</span> Timeout)</span>;</span><br></pre></td></tr></table></figure><p><code>HAL_ADC_PollForEvent()</code> 是 STM32 HAL 库中的一个函数，用于在<strong>轮询模式</strong>下<strong>等待 ADC 事件的发生</strong>。这可以让你检测 ADC 是否发生了特定的事件，比如转换完成、错误、模拟看门狗报警等。与 <code>HAL_ADC_PollForConversion()</code> 相似，<code>HAL_ADC_PollForEvent()</code> 允许你在指定的超时时间内轮询等待事件发生。</p><ul><li><code>ADC_AWD_EVENT</code> 是 <strong>模拟看门狗事件</strong>（Analog Watchdog Event）</li><li><code>ADC_OVR_EVENT</code>  是<strong>ADC 溢出事件</strong>（ADC Overrun Event）</li></ul><h1 id="HAL-ADC-Start-IT"><a href="#HAL-ADC-Start-IT" class="headerlink" title="HAL_ADC_Start_IT()"></a>HAL_ADC_Start_IT()</h1><p><code>HAL_ADC_Start_IT()</code> 函数<strong>启动 ADC 转换</strong>并<strong>启用 ADC 中断</strong>。调用此函数后，ADC 开始转换，并在转换完成后会触发中断，进入中断服务程序（ISR）进行处理。适用于那些需要通过中断来处理 ADC 转换结果的应用。</p><h1 id="HAL-ADC-Stop-IT"><a href="#HAL-ADC-Stop-IT" class="headerlink" title="HAL_ADC_Stop_IT()"></a>HAL_ADC_Stop_IT()</h1><p><code>HAL_ADC_Stop_IT()</code> 函数<strong>停止 ADC 转换</strong>并<strong>禁用 ADC 中断</strong>。调用此函数后，ADC 将停止转换，并且 ADC 中断被禁用。适用于那些不再需要 ADC 转换时，或者需要手动停止转换并清除中断时。</p><h1 id="HAL-ADC-IRQHandler"><a href="#HAL-ADC-IRQHandler" class="headerlink" title="HAL_ADC_IRQHandler()"></a>HAL_ADC_IRQHandler()</h1><p><code>HAL_ADC_IRQHandler()</code> 是 STM32 HAL 库中的一个函数，用于处理 ADC 的中断请求。当 ADC 发生中断时，这个函数会被自动调用，它会检查 ADC 的状态并执行相应的中断服务程序（ISR）。</p><h1 id="HAL-ADC-Start-DMA"><a href="#HAL-ADC-Start-DMA" class="headerlink" title="HAL_ADC_Start_DMA()"></a>HAL_ADC_Start_DMA()</h1><p><code>HAL_ADC_Start_DMA()</code> 函数用于启动 ADC 并通过 DMA 将 ADC 转换的结果直接传输到内存。DMA 可以直接将 ADC 转换的结果写入到预定义的内存数组中，避免了 CPU 的参与。</p><h1 id="HAL-ADC-Stop-DMA"><a href="#HAL-ADC-Stop-DMA" class="headerlink" title="HAL_ADC_Stop_DMA()"></a>HAL_ADC_Stop_DMA()</h1><p><code>HAL_ADC_Stop_DMA()</code> 函数用于停止正在进行的 ADC DMA 操作。调用此函数后，DMA 会停止传输数据，ADC 也会停止转换。</p><h1 id="HAL-ADC-GetValue"><a href="#HAL-ADC-GetValue" class="headerlink" title="HAL_ADC_GetValue()"></a>HAL_ADC_GetValue()</h1><p><code>HAL_ADC_GetValue()</code> 是 STM32 HAL 库中的一个函数，用于<strong>获取 ADC 转换的结果</strong>。该函数可以在 ADC 转换完成后调用，返回当前 ADC 数据寄存器中的转换结果。</p><h1 id="HAL-ADC-ConvCpltCallback"><a href="#HAL-ADC-ConvCpltCallback" class="headerlink" title="HAL_ADC_ConvCpltCallback()"></a>HAL_ADC_ConvCpltCallback()</h1><p><code>HAL_ADC_ConvCpltCallback()</code> 是一个回调函数，当 <strong>ADC 转换完成</strong>并且所有<strong>数据都已转换时</strong>调用。这通常用于处理 ADC 转换结果，特别是在使用 DMA 模式时，当所有的转换数据已经被传输到内存后触发此回调。</p><h1 id="HAL-ADC-ConvHalfCpltCallback"><a href="#HAL-ADC-ConvHalfCpltCallback" class="headerlink" title="HAL_ADC_ConvHalfCpltCallback()"></a>HAL_ADC_ConvHalfCpltCallback()</h1><p><code>HAL_ADC_ConvHalfCpltCallback()</code> 是一个回调函数，当 <strong>ADC 转换完成的一半</strong>数据被传输到内存时触发。这通<strong>常与 DMA 模式结合</strong>使用，特别是在进行批量转换时。这个回调可以在数据的一半完成时执行某些操作，比如处理已经转换的前半部分数据。</p><h1 id="HAL-ADC-LevelOutOfWindowCallback"><a href="#HAL-ADC-LevelOutOfWindowCallback" class="headerlink" title="HAL_ADC_LevelOutOfWindowCallback()"></a>HAL_ADC_LevelOutOfWindowCallback()</h1><p><code>HAL_ADC_LevelOutOfWindowCallback()</code> 是一个回调函数，当 ADC 转换结果超出了模拟看门狗的设置窗口时调用。模拟看门狗（Analog Watchdog，简称 AWD）功能可以用来监测 ADC 输入信号是否超出了预设的上限或下限。当 ADC 转换结果落在这个“窗口”之外时，触发此回调。</p><h1 id="HAL-ADC-ErrorCallback"><a href="#HAL-ADC-ErrorCallback" class="headerlink" title="HAL_ADC_ErrorCallback()"></a>HAL_ADC_ErrorCallback()</h1><p><code>HAL_ADC_ErrorCallback()</code> 是一个回调函数，当 <strong>ADC 出现错误时调用</strong>。常见的错误包括 ADC 过载、硬件故障等。此回调函数可以帮助你在 ADC 发生错误时进行适当的错误处理，如重启 ADC、输出错误信息或执行错误恢复操作。</p><h1 id="HAL-ADC-ConfigChannel"><a href="#HAL-ADC-ConfigChannel" class="headerlink" title="HAL_ADC_ConfigChannel()"></a>HAL_ADC_ConfigChannel()</h1><p><code>HAL_ADC_ConfigChannel()</code> 用于配置 ADC 的通道。每个 ADC 通道代表一个输入源，例如模拟信号、温度传感器或外部引脚输入。通过此函数，你可以配置 ADC 将采样的信号从哪一个通道获取，并指定该通道的其他参数。</p><h1 id="HAL-ADC-AnalogWDGConfig"><a href="#HAL-ADC-AnalogWDGConfig" class="headerlink" title="HAL_ADC_AnalogWDGConfig()"></a>HAL_ADC_AnalogWDGConfig()</h1><p><code>HAL_ADC_AnalogWDGConfig()</code> 用于配置 ADC 的模拟看门狗（Analog Watchdog，AWD）功能。模拟看门狗功能用于检测 ADC 输入信号是否超出设定的预定范围。通过此功能，可以监测输入信号是否超出了允许的最大值或最小值，并在超出时触发报警事件。</p><h1 id="HAL-ADC-GetState"><a href="#HAL-ADC-GetState" class="headerlink" title="HAL_ADC_GetState()"></a>HAL_ADC_GetState()</h1><p><code>HAL_ADC_GetState()</code> 用于获取当前 ADC 外设的状态。这些状态可以帮助你了解 ADC 的工作进程，并确定是否可以开始下一次转换或是否存在其他问题。</p><h1 id="HAL-ADC-GetError"><a href="#HAL-ADC-GetError" class="headerlink" title="HAL_ADC_GetError()"></a>HAL_ADC_GetError()</h1><p><code>HAL_ADC_GetError()</code> 用于获取当前 ADC 外设的错误状态。当 ADC 操作失败时，调用此函数可以帮助你诊断问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HAL-ADC-Init&quot;&gt;&lt;a href=&quot;#HAL-ADC-Init&quot; class=&quot;headerlink&quot; title=&quot;HAL_ADC_Init()&quot;&gt;&lt;/a&gt;HAL_ADC_Init()&lt;/h1&gt;&lt;p&gt;&lt;code&gt;HAL_ADC_Init()&lt;/code</summary>
      
    
    
    
    <category term="外设" scheme="https://ydw-item.github.io.git/categories/%E5%A4%96%E8%AE%BE/"/>
    
    
    <category term="外设" scheme="https://ydw-item.github.io.git/tags/%E5%A4%96%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>SPI通信协议&amp;&amp;1.44寸TFT-LCD（ST7735S）</title>
    <link href="https://ydw-item.github.io.git/2025/02/22/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&amp;&amp;1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/"/>
    <id>https://ydw-item.github.io.git/2025/02/22/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&amp;&amp;1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/</id>
    <published>2025-02-22T11:03:49.000Z</published>
    <updated>2025-02-22T11:03:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、SPI"><a href="#一、SPI" class="headerlink" title="一、SPI"></a>一、SPI</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>SPI，英文全称Serial Peripheral Interface，即串行外围设备接口，是一种高速、<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%8F%8C%E5%B7%A5&spm=1001.2101.3001.7020">全双工</a>、同步的串行通信总线。</p><h2 id="1-2-信号线"><a href="#1-2-信号线" class="headerlink" title="1.2 信号线"></a>1.2 信号线</h2><ul><li><strong>SCK</strong>（Serial Clock）：串行<strong>时钟线</strong>，由主设备产生，用于同步数据传输。</li><li><strong>MOSI</strong>（Master Output Slave Input）：<strong>主机输出</strong>从机输入线，主设备通过这条线发送数据给从设备。</li><li>MISO（Master Input Slave Output）：<strong>主机输入</strong>从机输出线，主设备通过这条线接收从设备发送的数据。</li><li><strong>SS</strong>（Slave Select）：<strong>从机选择线</strong>（每个从机一根选择线），用于选择与主设备进行通信的从设备。通常情况下，SS线为低电平有效，即当SS线为低电平时，选中对应的从设备进行通信。</li></ul><h2 id="1-3-开始与结束"><a href="#1-3-开始与结束" class="headerlink" title="1.3 开始与结束"></a>1.3 开始与结束</h2><p>当SS从高电平拉低到低电平，这个算是起始的一个时序。而SS从低电平拉高到高电平，就算是结束的时序。</p><p><img src="/2025/02/22/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/1.png" alt="img"></p><h2 id="1-4-发送和接收字节"><a href="#1-4-发送和接收字节" class="headerlink" title="1.4 发送和接收字节"></a>1.4 发送和接收字节</h2><p>发送接收字节看似是两个时序，但是在SPI中却是<strong>同一个时序</strong>，因为SPI的机制是我们发送一个字节，并且接收一个字节（<strong>哪怕我们并不需要接收数据</strong>）。反过来看也可以是我们接收一个字节，并且发送一个字节（<strong>哪怕这个字节是无用的数据</strong>）。</p><p><img src="/2025/02/22/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/2.png" alt="img"></p><h2 id="交换bit"><a href="#交换bit" class="headerlink" title="交换bit"></a>交换bit</h2><p><img src="/2025/02/22/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/3.png" alt="img"></p><p><strong>在SCK上升沿的时候，移出MOSI的数据，在SCK下降沿的时候读取MISO的数据。</strong></p><p><strong>需要在SCK上升沿之前把需要发送的数据位放置在MOSI线上</strong></p><p><strong>SCK下降沿的时候马上读取MISO线上的数据位</strong></p><p><strong>（实际上下降沿和读取应该是同时的，但是我们软件模拟没法同时，但是效果是一样的）</strong></p><h1 id="二、TFT-LCD"><a href="#二、TFT-LCD" class="headerlink" title="二、TFT-LCD"></a>二、TFT-LCD</h1><p><img src="/2025/02/22/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/4.png" alt="705A80E97488A8ADBF31C36755A03C23"></p><table><thead><tr><th>引脚</th><th>功能</th></tr></thead><tbody><tr><td>GND</td><td>接地</td></tr><tr><td>VCC</td><td>供电（3.3V-5V）</td></tr><tr><td>SCL</td><td>时钟信号</td></tr><tr><td>SDA</td><td>数据信号（MOSI）</td></tr><tr><td>RES</td><td>低电平TFT复位</td></tr><tr><td>DC</td><td>区分接受的是数据还是命令（低电平命令，高电平数据）</td></tr><tr><td>CS</td><td>片选信号，低电平使能</td></tr><tr><td>BLK</td><td>背光（可常接3.3V）</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、SPI&quot;&gt;&lt;a href=&quot;#一、SPI&quot; class=&quot;headerlink&quot; title=&quot;一、SPI&quot;&gt;&lt;/a&gt;一、SPI&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="通信协议" scheme="https://ydw-item.github.io.git/categories/STM32/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="外设" scheme="https://ydw-item.github.io.git/categories/STM32/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%A4%96%E8%AE%BE/"/>
    
    
    <category term="通讯协议" scheme="https://ydw-item.github.io.git/tags/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="SPI" scheme="https://ydw-item.github.io.git/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-PIN</title>
    <link href="https://ydw-item.github.io.git/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/"/>
    <id>https://ydw-item.github.io.git/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/</id>
    <published>2025-02-19T06:22:05.000Z</published>
    <updated>2025-02-19T06:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设置引脚模式-rt-pin-mode"><a href="#1-设置引脚模式-rt-pin-mode" class="headerlink" title="1. 设置引脚模式 rt_pin_mode()"></a>1. 设置引脚模式 rt_pin_mode()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/1.png" alt="image-20250219155159103"> </p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">PIN_MODE_OUTPUT</td><td align="center">输出</td></tr><tr><td align="center">PIN_MODE_INPUT</td><td align="center">输入</td></tr><tr><td align="center">PIN_MODE_INPUT_PULLUP</td><td align="center">上拉输入</td></tr><tr><td align="center">PIN_MODE_INPUT_PULLDOWN</td><td align="center">下拉输入</td></tr><tr><td align="center">PIN_MODE_OUTPUT_OD</td><td align="center">开漏输出</td></tr></tbody></table><h2 id="2-设置引脚电平-rt-pin-write"><a href="#2-设置引脚电平-rt-pin-write" class="headerlink" title="2. 设置引脚电平 rt_pin_write()"></a>2. 设置引脚电平 rt_pin_write()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/2.png" alt="image-20250219155633545"></p><h2 id="3-读取引脚电平-rt-pin-read"><a href="#3-读取引脚电平-rt-pin-read" class="headerlink" title="3. 读取引脚电平 rt_pin_read ()"></a>3. 读取引脚电平 rt_pin_read ()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/image-20250219161129046.png" alt="image-20250219161129046"></p><h2 id="4-绑定引脚中断回调函数-rt-pin-attach-irq"><a href="#4-绑定引脚中断回调函数-rt-pin-attach-irq" class="headerlink" title="4. 绑定引脚中断回调函数 rt_pin_attach_irq ()"></a>4. 绑定引脚中断回调函数 rt_pin_attach_irq ()</h2><h2 id="5-脱离引脚中断回调函数-rt-pin-detach-irq"><a href="#5-脱离引脚中断回调函数-rt-pin-detach-irq" class="headerlink" title="5.脱离引脚中断回调函数 rt_pin_detach_irq ()"></a>5.脱离引脚中断回调函数 rt_pin_detach_irq ()</h2><h2 id="6-使能-屏蔽引脚中断-rt-pin-irq-enable"><a href="#6-使能-屏蔽引脚中断-rt-pin-irq-enable" class="headerlink" title="6. 使能 &#x2F; 屏蔽引脚中断 rt_pin_irq_enable ()"></a>6. 使能 &#x2F; 屏蔽引脚中断 rt_pin_irq_enable ()</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-设置引脚模式-rt-pin-mode&quot;&gt;&lt;a href=&quot;#1-设置引脚模式-rt-pin-mode&quot; class=&quot;headerlink&quot; title=&quot;1. 设置引脚模式 rt_pin_mode()&quot;&gt;&lt;/a&gt;1. 设置引脚模式 rt_pin_mode()</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-IO</title>
    <link href="https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/"/>
    <id>https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/</id>
    <published>2025-02-17T09:44:05.000Z</published>
    <updated>2025-02-17T09:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、drv-gpio-c"><a href="#一、drv-gpio-c" class="headerlink" title="一、drv_gpio.c"></a>一、drv_gpio.c</h1><h1 id="1-1在drv-common-c中调用rt-hw-pin-init-函数"><a href="#1-1在drv-common-c中调用rt-hw-pin-init-函数" class="headerlink" title="1.1在drv_common,c中调用rt_hw_pin_init()函数"></a>1.1在drv_common,c中调用rt_hw_pin_init()函数</h1><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/1.png" alt="image-20250217174741243"></p><h2 id="1-2-rt-hw-pin-init"><a href="#1-2-rt-hw-pin-init" class="headerlink" title="1.2 rt_hw_pin_init()"></a>1.2 rt_hw_pin_init()</h2><p>启用 STM32 微控制器中 <strong>GPIOA</strong> 外设的时钟</p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/2.png" alt="image-20250217175841655"></p><h1 id="1-3-pins"><a href="#1-3-pins" class="headerlink" title="1.3 pins[]"></a>1.3 pins[]</h1><p><strong>为每个pin定义编号</strong></p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/3.png" alt="image-20250217181636459"></p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/4.png" alt="image-20250217181926120"></p><p>这个宏会创建一个结构体，结构体中包含了三个成员：</p><ul><li><code>index</code>：通常是一个标识符或索引，用于标识该引脚的具体位置。</li><li><code>GPIO##gpio</code>：指定了 GPIO 端口（如 <code>GPIOA</code>、<code>GPIOB</code> 等）。</li><li><code>GPIO_PIN_##gpio_index</code>：指定了具体的引脚（如 <code>GPIO_PIN_0</code>、<code>GPIO_PIN_1</code> 等）。</li></ul><h1 id="stm32-pin-write"><a href="#stm32-pin-write" class="headerlink" title="stm32_pin_write"></a>stm32_pin_write</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stm32_pin_write</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin, <span class="type">rt_base_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_WritePin(index-&gt;gpio, index-&gt;pin, (GPIO_PinState)value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stm32-pin-read"><a href="#stm32-pin-read" class="headerlink" title="stm32_pin_read"></a>stm32_pin_read</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stm32_pin_read</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line"></span><br><span class="line">    value = PIN_LOW;</span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value = HAL_GPIO_ReadPin(index-&gt;gpio, index-&gt;pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stm32-pin-mode"><a href="#stm32-pin-mode" class="headerlink" title="stm32_pin_mode"></a>stm32_pin_mode</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">atic <span class="type">void</span> <span class="title function_">stm32_pin_mode</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin, <span class="type">rt_base_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure GPIO_InitStructure */</span></span><br><span class="line">    GPIO_InitStruct.Pin = index-&gt;pin;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == PIN_MODE_OUTPUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* output setting */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: not pull. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT_PULLUP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: pull up. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT_PULLDOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: pull down. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_PULLDOWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_OUTPUT_OD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* output setting: od. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_Init(index-&gt;gpio, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、drv-gpio-c&quot;&gt;&lt;a href=&quot;#一、drv-gpio-c&quot; class=&quot;headerlink&quot; title=&quot;一、drv_gpio.c&quot;&gt;&lt;/a&gt;一、drv_gpio.c&lt;/h1&gt;&lt;h1 id=&quot;1-1在drv-common-c中调用rt-hw-</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-2-时钟管理</title>
    <link href="https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/</id>
    <published>2025-02-17T08:44:05.000Z</published>
    <updated>2025-02-17T08:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、时钟节拍"><a href="#一、时钟节拍" class="headerlink" title="一、时钟节拍"></a>一、时钟节拍</h1><ul><li><p>时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的实时响应越快，但是系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。</p></li><li><p>时钟节拍的长度可以根据 RT_TICK_PER_SECOND 的定义来调整，等于 1&#x2F;RT_TICK_PER_SECOND 秒。</p><p>  <img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/1.png" alt="image-20250217164837198"></p></li></ul><h1 id="二、时钟节拍的实现方式"><a href="#二、时钟节拍的实现方式" class="headerlink" title="二、时钟节拍的实现方式"></a>二、时钟节拍的实现方式</h1><p>中断触发模式的硬件定时器产生，当中断到来时，将调用一次：void rt_tick_increase(void)，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 进入中断 */</span></span><br><span class="line">    rt_interrupt_enter();</span><br><span class="line">    ……</span><br><span class="line">    rt_tick_increase();</span><br><span class="line">    <span class="comment">/* 退出中断 */</span></span><br><span class="line">    rt_interrupt_leave();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中断函数中调用 rt_tick_increase() 对全局变量 rt_tick 进行自加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_tick_increase</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 全局变量 rt_tick 自加 */</span></span><br><span class="line">    ++ rt_tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查时间片 */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    -- thread-&gt;remaining_tick;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;remaining_tick == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 重新赋初值 */</span></span><br><span class="line">        thread-&gt;remaining_tick = thread-&gt;init_tick;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 线程挂起 */</span></span><br><span class="line">        rt_thread_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查定时器 */</span></span><br><span class="line">    rt_timer_check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rt_tick 的值表示了系统<strong>从启动开始</strong>总共经过的时钟节拍数，即<strong>系统时间</strong></p><p>每经过一个时钟节拍时，都会检查当前线程的时间片是否用完，以及是否有定时器超时。</p><h1 id="三、获取时钟节拍"><a href="#三、获取时钟节拍" class="headerlink" title="三、获取时钟节拍"></a>三、获取时钟节拍</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_tick_t</span> <span class="title function_">rt_tick_get</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="四、定时器管理"><a href="#四、定时器管理" class="headerlink" title="四、定时器管理"></a>四、定时器管理</h1><ul><li><strong>硬件定时器</strong>是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</li><li><strong>软件定时器</strong>是由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</li><li>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍，例如一个 OS Tick 是 10ms，那么上层软件定时器只能是 10ms，20ms，100ms 等，而不能定时为 15ms。RT-Thread 的定时器也基于系统的节拍，提供了基于节拍整数倍的定时能力。</li></ul><h1 id="五、RT-Thread定时器介绍"><a href="#五、RT-Thread定时器介绍" class="headerlink" title="五、RT-Thread定时器介绍"></a>五、RT-Thread定时器介绍</h1><p>RT-Thread 的定时器提供两类定时器机制：</p><ul><li>第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。</li><li>第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止，否则将永远持续执行下去。</li></ul><p>超时函数执行时所处的上下文环境，RT-Thread 的定时器可以分为 HARD_TIMER 模式与 SOFT_TIMER 模式</p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/2.png" alt="定时器上下文环境"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、时钟节拍&quot;&gt;&lt;a href=&quot;#一、时钟节拍&quot; class=&quot;headerlink&quot; title=&quot;一、时钟节拍&quot;&gt;&lt;/a&gt;一、时钟节拍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-1-线程管理</title>
    <link href="https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2025-02-16T07:47:05.000Z</published>
    <updated>2025-02-16T07:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程栈"><a href="#一、线程栈" class="headerlink" title="一、线程栈"></a>一、线程栈</h1><ul><li>RT-Thread 线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复。</li><li>线程栈还用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；函数中局部变量初始时从寄存器中分配（ARM 架构），当这个函数再调用另一个函数时，这些局部变量将放入栈中。</li></ul><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/1.png" alt="线程栈 (ARM)"></p><ul><li>线程栈大小可以这样设定，对于资源相对较大的 MCU，可以适当设计较大的线程栈；也可以在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 <strong>FinSH</strong> 中用 <strong>list_thread</strong> 命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的<strong>最大栈深度</strong>，而后加上适当的余量形成最终的线程栈大小，最后对栈空间大小加以修改。</li></ul><h1 id="二、线程状态"><a href="#二、线程状态" class="headerlink" title="二、线程状态"></a>二、线程状态</h1><table><thead><tr><th>状态</th><th align="center">描述</th></tr></thead><tbody><tr><td>初始状态</td><td align="center">当线程刚开始创建还没开始运行时就处于初始状态；在初始状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td></tr><tr><td>就绪状态</td><td align="center">在就绪状态下，线程按照优先级排队，等待被执行；一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td></tr><tr><td>运行状态</td><td align="center">线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；在多核系统中，可能就不止这一个线程处于运行状态。此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td></tr><tr><td>挂起状态</td><td align="center">也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。在挂起状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td></tr><tr><td>关闭状态</td><td align="center">当线程运行结束时将处于关闭状态。关闭状态的线程不参与线程的调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td></tr></tbody></table><h1 id="三、线程优先级"><a href="#三、线程优先级" class="headerlink" title="三、线程优先级"></a>三、线程优先级</h1><p>RT-Thread 最大支持 256 个线程优先级 (0~255)，<strong>数值越小的优先级越高</strong>，0 为最高优先级。在一些资源比较紧张的系统中，可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置；对于 <strong>ARM Cortex-M</strong> 系列，<strong>普遍采用 32 个优先级</strong>。最低优先级<strong>默认分配给空闲线程</strong>使用，用户一般不使用。在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将<strong>立刻被换出</strong>，高优先级线程抢占处理器运行。(YDW：并不会等到线程此次允许结束)</p><h1 id="四、时间片"><a href="#四、时间片" class="headerlink" title="四、时间片"></a>四、时间片</h1><ul><li><p>每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效</p></li><li><p>时间片起到约束线程单次运行时长的作用，其单位是一个系统节拍（OS Tick）</p></li></ul><h1 id="五、线程的入口函数"><a href="#五、线程的入口函数" class="headerlink" title="五、线程的入口函数"></a>五、线程的入口函数</h1><p><strong>无限循环模式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* paramenter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 等待事件的发生 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对事件进行服务、进行处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-<strong>顺序执行或有限次循环模式：</strong></p><ul><li><strong>在执行完毕后，线程将被系统自动删除。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 处理事务 #1 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #2 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、线程错误码"><a href="#六、线程错误码" class="headerlink" title="六、线程错误码"></a>六、线程错误码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EOK           0 <span class="comment">/* 无错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ERROR         1 <span class="comment">/* 普通错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ETIMEOUT      2 <span class="comment">/* 超时错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EFULL         3 <span class="comment">/* 资源已满     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EEMPTY        4 <span class="comment">/* 无资源     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOMEM        5 <span class="comment">/* 无内存     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOSYS        6 <span class="comment">/* 系统不支持     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EBUSY         7 <span class="comment">/* 系统忙     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EIO           8 <span class="comment">/* IO 错误       */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINTR         9 <span class="comment">/* 中断系统调用   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINVAL       10 <span class="comment">/* 非法参数      */</span></span></span><br></pre></td></tr></table></figure><h1 id="七、线程状态切换"><a href="#七、线程状态切换" class="headerlink" title="七、线程状态切换"></a>七、线程状态切换</h1><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/2.png" alt="线程状态转换图"></p><ul><li>线程通过调用函数 rt_thread_create&#x2F;init() 进入到初始状态（RT_THREAD_INIT）；初始状态的线程通过调用函数 rt_thread_startup() 进入到就绪状态（RT_THREAD_READY）；</li><li>就绪状态的线程被调度器调度后进入运行状态（RT_THREAD_RUNNING）；</li><li>当处于运行状态的线程调用 rt_thread_delay()，rt_sem_take()，rt_mutex_take()，rt_mb_recv() 等函数或者获取不到资源时，将进入到挂起状态（RT_THREAD_SUSPEND）；</li><li>处于挂起状态的线程，如果等待超时依然未能获得资源或由于其他线程释放了资源，那么它将返回到就绪状态。挂起状态的线程，如果调用 rt_thread_delete&#x2F;detach() 函数，将更改为关闭状态（RT_THREAD_CLOSE）；</li><li>而运行状态的线程，如果运行结束，就会在线程的最后部分执行 rt_thread_exit() 函数，将状态更改为关闭状态。</li></ul><h1 id="八、系统线程"><a href="#八、系统线程" class="headerlink" title="八、系统线程"></a>八、系统线程</h1><p><strong>在 RT-Thread 内核中的系统线程有空闲线程和主线程。</strong></p><h1 id="九、空闲线程"><a href="#九、空闲线程" class="headerlink" title="九、空闲线程"></a>九、空闲线程</h1><ul><li>空闲线程状态永远为就绪态，当系统中无其他就绪线程存在时，调度器将调度到空闲线程，它通常是一个<strong>死循环</strong>，且<strong>永远不能被挂起</strong>。</li><li>若某线程运行完毕，系统将<strong>自动删除线程</strong>：自动执行 rt_thread_exit() 函数，先将该线程从系统<strong>就绪队列中删除</strong>，再将该线程的状态更改为<strong>关闭状态</strong>，不再参与系统调度，然后挂入 rt_thread_defunct <strong>僵尸队列</strong>（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</li><li>空闲线程也提供了接口来运行用户设置的<strong>钩子函</strong>数，在空闲线程运行时会调用该钩子函数，适合处理<strong>功耗管理</strong>、看门狗喂狗等工作。空闲线程必须有得到执行的机会，即其他线程不允许一直while(1)死卡，必须调用具有阻塞性质的函数；<strong>否则例如线程删除、回收等操作将无法得到正确执行。</strong></li></ul><h1 id="十、主线程"><a href="#十、主线程" class="headerlink" title="十、主线程"></a>十、主线程</h1><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/3.png" alt="主线程调用过程"></p><h1 id="十一、创建和删除线程"><a href="#十一、创建和删除线程" class="headerlink" title="十一、创建和删除线程"></a>十一、创建和删除线程</h1><ul><li>动态创建</li></ul><p><strong>分配出来的栈空间是按照 rtconfig.h 中配置的 RT_ALIGN_SIZE 方式对齐</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter),</span></span><br><span class="line"><span class="params">                            <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint8_t</span> priority,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>thread</td><td>线程创建成功，返回线程句柄</td></tr><tr><td>RT_NULL</td><td>线程创建失败</td></tr></tbody></table><ul><li>删除</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delete</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li>用 rt_thread_delete() 函数删除线程接口，仅仅是把相应的线程状态更改为 RT_THREAD_CLOSE 状态，然后放入到 rt_thread_defunct 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作</li></ul><p><strong>仅在使能了系统动态堆时才有效</strong></p><h1 id="十二、初始化和脱离线程"><a href="#十二、初始化和脱离线程" class="headerlink" title="十二、初始化和脱离线程"></a>十二、初始化和脱离线程</h1><ul><li>静态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_init</span><span class="params">(<span class="keyword">struct</span> rt_thread* thread,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter), <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>* stack_start, <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span> priority, <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td></tr><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_start</td><td>线程栈起始地址</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程创建成功</td></tr><tr><td>-RT_ERROR</td><td>线程创建失败</td></tr></tbody></table><ul><li>脱离</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_detach</span> <span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p><strong>线程本身不应调用这个接口脱离线程本身</strong></p><h1 id="十三、启动线程"><a href="#十三、启动线程" class="headerlink" title="十三、启动线程"></a>十三、启动线程</h1><p><strong>创建（初始化）的线程状态处于初始状态，并未进入就绪线程的调度队列，我们可以在线程初始化 &#x2F; 创建成功后调用下面的函数接口让该线程进入就绪态：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_startup</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h1 id="十四、获得当前线程"><a href="#十四、获得当前线程" class="headerlink" title="十四、获得当前线程"></a>十四、获得当前线程</h1><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="十五、使线程让出CUP资源"><a href="#十五、使线程让出CUP资源" class="headerlink" title="十五、使线程让出CUP资源"></a>十五、使线程让出CUP资源</h1><p>当前线程的时间片用完或者该线程主动要求让出处理器资源时，它将不再占有处理器，调度器会选择相同优先级的下一个线程执行。线程调用这个接口后，这个线程仍然在就绪队列中。线程让出处理器使用下面的函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="十六、线程睡眠"><a href="#十六、线程睡眠" class="headerlink" title="十六、线程睡眠"></a>十六、线程睡眠</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_sleep</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delay</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_mdelay</span><span class="params">(<span class="type">rt_int32_t</span> ms)</span>;</span><br></pre></td></tr></table></figure><h1 id="十七、挂起和恢复线程"><a href="#十七、挂起和恢复线程" class="headerlink" title="十七、挂起和恢复线程"></a>十七、挂起和恢复线程</h1><h1 id="十八、控制线程"><a href="#十八、控制线程" class="headerlink" title="十八、控制线程"></a>十八、控制线程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_control</span><span class="params">(<span class="type">rt_thread_t</span> thread, <span class="type">rt_uint8_t</span> cmd, <span class="type">void</span>* arg)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td>cmd</td><td>指示控制命令</td></tr><tr><td>arg</td><td>控制参数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>控制执行正确</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><ul><li>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</li><li>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</li><li>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 或 rt_thread_detach() 函数调用。</li></ul><h1 id="十九、设置和删除空闲钩子"><a href="#十九、设置和删除空闲钩子" class="headerlink" title="十九、设置和删除空闲钩子"></a>十九、设置和删除空闲钩子</h1><p>可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_delhook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>注：空闲线程是一个线程状态永远为就绪态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，例如 rt_thread_delay()，rt_sem_take() 等可能会导致线程挂起的函数都不能使用。并且，由于 malloc、free 等内存相关的函数内部使用了信号量作为临界区保护，因此在钩子函数内部也不允许调用此类函数！</p><h1 id="二十、设置调度器钩子"><a href="#二十、设置调度器钩子" class="headerlink" title="二十、设置调度器钩子"></a>二十、设置调度器钩子</h1><p>有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_scheduler_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to))</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hook</span><span class="params">(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>from</td><td>表示系统所要切换出的线程控制块指针</td></tr><tr><td>to</td><td>表示系统所要切换到的线程控制块指针</td></tr></tbody></table><p>在这个钩子函数中，基本上不允许调用系统 API</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程栈&quot;&gt;&lt;a href=&quot;#一、线程栈&quot; class=&quot;headerlink&quot; title=&quot;一、线程栈&quot;&gt;&lt;/a&gt;一、线程栈&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;RT-Thread 线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-1-ADC</title>
    <link href="https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/"/>
    <id>https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/</id>
    <published>2025-02-15T16:20:05.000Z</published>
    <updated>2025-02-18T12:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-初始化设备stm32-adc-init"><a href="#一、-初始化设备stm32-adc-init" class="headerlink" title="一、 初始化设备stm32_adc_init()"></a>一、 初始化设备stm32_adc_init()</h1><p>​进行板级初始化</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/1.png" alt="image-20250213213546245"></p><h3 id="1-1定义adc-config数组"><a href="#1-1定义adc-config数组" class="headerlink" title="1.1定义adc_config数组"></a>1.1定义adc_config数组</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/2.png" alt="image-20250213215103492"></p><p>数组中有几个值通过board.h中的宏定义来确定，同时数组中的最后一个元素后面在某些标准下是被允许加逗号的</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/3.png" alt="image-20250213215514039"></p><p>如果打开ADC1和ADC2，那么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc_config[] =&#123;ADC1_CONFIG,ADC3_CONFIG&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-ADC1-CONFIG是什么"><a href="#1-2-ADC1-CONFIG是什么" class="headerlink" title="1.2 ADC1_CONFIG是什么"></a>1.2 ADC1_CONFIG是什么</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/4.png" alt="image-20250213215847418"></p><h3 id="1-3-ADC-HandleTypeDef是什么类型"><a href="#1-3-ADC-HandleTypeDef是什么类型" class="headerlink" title="1.3 ADC_HandleTypeDef是什么类型"></a>1.3 ADC_HandleTypeDef是什么类型</h3><p>是 <strong>STM32 HAL（硬件抽象层）库</strong> 中的一个结构体，用于表示 <strong>ADC（模拟到数字转换器）</strong> 外设的配置和状态</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/5.png" alt="image-20250213221307498"></p><p><strong><code>Instance</code></strong></p><ul><li>类型：<code>ADC_TypeDef *</code></li><li><strong>描述</strong>：指向 ADC 模块寄存器的指针。不同的 STM32 微控制器有多个 ADC 模块（如 <code>ADC1</code>, <code>ADC2</code>, <code>ADC3</code> 等），<code>Instance</code> 用于标识当前操作的是哪个 ADC 模块。</li></ul><p><strong><code>Init</code></strong></p><ul><li><p>类型：<code>ADC_InitTypeDef</code></p></li><li><p>描述</p><p>  ：包含 ADC 初始化配置的结构体。它包含了多个配置选项，如 ADC 时钟、分辨率、数据对齐方式等。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef</span><br></pre></td></tr></table></figure><p>   是一个结构体，通常包括以下字段：</p><ul><li><code>ClockPrescaler</code>：ADC 时钟的预分频器。</li><li><code>Resolution</code>：ADC 分辨率（如 12 位、10 位、8 位）。</li><li><code>DataAlign</code>：数据对齐方式（如左对齐或右对齐）。</li><li><code>ScanConvMode</code>：是否启用扫描模式（多个通道转换）。</li><li><code>ContinuousConvMode</code>：是否启用连续转换模式。</li><li><code>ExternalTrigConv</code>：外部触发类型（如软件触发、定时器触发等）。</li></ul></li></ul><p><strong><code>DMA_Handle</code></strong></p><ul><li>类型：<code>DMA_HandleTypeDef *</code></li><li><strong>描述</strong>：指向 DMA（直接存储器访问）句柄的指针。如果使用 DMA 进行 ADC 数据传输，这个字段指向一个 <code>DMA_HandleTypeDef</code> 结构，用于管理 DMA 的配置。</li></ul><p><strong><code>State</code></strong></p><ul><li>类型：<code>__IO uint32_t *</code></li><li><strong>描述</strong>：指向 ADC 状态的指针。这个字段通常用于存储 ADC 的当前状态，如转换进行中、转换完成等状态信息。</li></ul><p><strong><code>ErrorCode</code></strong></p><ul><li>类型：<code>__IO uint32_t</code></li><li><strong>描述</strong>：存储 ADC 操作过程中发生的错误代码。这可以帮助调试和排查问题，比如发生了什么错误，是否由于配置问题导致操作失败等。</li></ul><h3 id="1-4-启用了几个ADC就定义几个stm32-adc-obj-元素"><a href="#1-4-启用了几个ADC就定义几个stm32-adc-obj-元素" class="headerlink" title="1.4 启用了几个ADC就定义几个stm32_adc_obj[]元素"></a>1.4 启用了几个ADC就定义几个stm32_adc_obj[]元素</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/8.png" alt="image-20250213223809186"></p><h3 id="1-5-ADC-Handler和adc-config是一个类型的变量"><a href="#1-5-ADC-Handler和adc-config是一个类型的变量" class="headerlink" title="1.5 ADC_Handler和adc_config是一个类型的变量"></a>1.5 ADC_Handler和adc_config是一个类型的变量</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/7.png" alt="image-20250213224057191"></p><h3 id="1-6-for循环"><a href="#1-6-for循环" class="headerlink" title="1.6 for循环"></a>1.6 for循环</h3><p>用sizeof判断使用了几个ADC，使用了几个ADC就循环几此</p><p>1.把adc_config赋值给ADC_Hander(因为第6小点)</p><p>2.通过stm32f407xx.h判断是否有这个外设</p><p>3.Instance中存放的名字是ADCx，是ADC几就把几赋值给name_buf[3]</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/6.png" alt="image-20250213222200867"></p><h3 id="1-7-HAL-ADC-Init"><a href="#1-7-HAL-ADC-Init" class="headerlink" title="1.7 HAL_ADC_Init()"></a>1.7 HAL_ADC_Init()</h3><p>1.传入ADC_HandleTypeDef类型的值，初始化ADC</p><p>2.如果返回错误，答应init failed</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/9.png" alt="99e47c9c-0550-49aa-992d-62ec87fad64a"></p><h3 id="1-8-rt-hw-adc-register"><a href="#1-8-rt-hw-adc-register" class="headerlink" title="1.8 rt_hw_adc_register()"></a>1.8 rt_hw_adc_register()</h3><p>用于注册硬件 ADC 的函数，它将 ADC 驱动和硬件抽象层（HAL）关联起来,使得 RT-Thread 可以识别和使用指定的 ADC 外设</p><ul><li><strong>初始化硬件 ADC 驱动</strong>：这个函数将硬件 ADC 外设与 RT-Thread 的设备模型进行注册，使得 RT-Thread 可以管理和访问硬件 ADC。</li><li><strong>设备注册</strong>：它会在 RT-Thread 的设备模型中创建一个 ADC 设备对象，从而让系统能够通过统一的接口（例如 <code>read()</code>、<code>write()</code> 等）来操作硬件。</li><li><strong>设备抽象层支持</strong>：通过设备抽象层，用户可以通过设备操作接口（如打开设备、关闭设备、读取数据等）与硬件 ADC 进行交互。</li></ul><h3 id="1-9rt-adc-device-是用于表示一个-ADC-设备-的结构体"><a href="#1-9rt-adc-device-是用于表示一个-ADC-设备-的结构体" class="headerlink" title="1.9rt_adc_device 是用于表示一个 ADC 设备 的结构体"></a>1.9<code>rt_adc_device</code> 是用于表示一个 <strong>ADC 设备</strong> 的结构体</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/10.png" alt="image-20250213230813789"></p><h3 id="1-10-struct-rt-adc-ops"><a href="#1-10-struct-rt-adc-ops" class="headerlink" title="1.10 struct rt_adc_ops"></a>1.10 struct rt_adc_ops</h3><p> RT-Thread 中与 <strong>ADC（模拟到数字转换器）</strong> 设备交互的操作函数结构体，它包含了一组函数指针</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/13.png" alt="image-20250213231324141"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/11.png" alt="image-20250213231110666"></p><h1 id="二、查找ADC设备rt-device-find"><a href="#二、查找ADC设备rt-device-find" class="headerlink" title="二、查找ADC设备rt_device_find()"></a>二、查找ADC设备rt_device_find()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_NAME        <span class="string">&quot;adc1&quot;</span>  <span class="comment">/* ADC 设备名称 */</span></span></span><br><span class="line"><span class="type">rt_adc_device_t</span> adc_dev;            <span class="comment">/* ADC 设备句柄 */</span></span><br><span class="line"><span class="comment">/* 查找设备 */</span></span><br><span class="line">adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br></pre></td></tr></table></figure><h1 id="三、使能ADC通道rt-adc-enable（）"><a href="#三、使能ADC通道rt-adc-enable（）" class="headerlink" title="三、使能ADC通道rt_adc_enable（）"></a>三、使能ADC通道rt_adc_enable（）</h1><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/18.png" alt="image-20250218192237456"></p><h3 id="3-1-stm32-adc-enabled"><a href="#3-1-stm32-adc-enabled" class="headerlink" title="3.1 stm32_adc_enabled"></a>3.1 stm32_adc_enabled</h3><p><strong>rt_adc_enable()<strong>中调用了硬件驱动层函数</strong>stm32_adc_enabled()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/19.png" alt="image-20250218192444206"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/12.png" alt="image-20250218143021553"></p><ul><li>传入<strong>device</strong>和<strong>enabled</strong>参数，此处的<strong>channel</strong>没用到</li></ul><h1 id="四、读取通道值rt-adc-read（）"><a href="#四、读取通道值rt-adc-read（）" class="headerlink" title="四、读取通道值rt_adc_read（）"></a>四、读取通道值rt_adc_read（）</h1><p>获取ADC通道的值，存入<strong>value</strong>变量中</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/23.png" alt="image-20250218193225562"></p><h3 id="4-1-stm32-get-adc-value"><a href="#4-1-stm32-get-adc-value" class="headerlink" title="4.1 stm32_get_adc_value()"></a>4.1 stm32_get_adc_value()</h3><p><strong>rt_adc_read()<strong>中调用了硬件驱动层函数</strong>1stm32_get_adc_value()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/20.png" alt="image-20250218193118064"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/16.png" alt="image-20250218193915303"></p><h3 id="4-2-stm32-adc-get-channel"><a href="#4-2-stm32-adc-get-channel" class="headerlink" title="4.2 stm32_adc_get_channel()"></a>4.2 stm32_adc_get_channel()</h3><p>将通道的数字转换成ADC通道的地址</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/14.png" alt="image-20250218143654896"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/15.png" alt="image-20250218143716406"></p><h1 id="五、-关闭ADC通道rt-adc-disable"><a href="#五、-关闭ADC通道rt-adc-disable" class="headerlink" title="五、 关闭ADC通道rt_adc_disable()"></a>五、 关闭ADC通道rt_adc_disable()</h1><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/21..png" alt="image-20250218194154075"></p><h3 id="5-1-stm32-adc-enabled"><a href="#5-1-stm32-adc-enabled" class="headerlink" title="5.1 stm32_adc_enabled()"></a>5.1 stm32_adc_enabled()</h3><p><strong>rt_adc_disable()<strong>中调用了硬件驱动层函数</strong>stm32_adc_enabled()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/22.png" alt="image-20250218200837908"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_NAME        <span class="string">&quot;adc1&quot;</span>  <span class="comment">/* ADC 设备名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_CHANNEL     5       <span class="comment">/* ADC 通道 */</span></span></span><br><span class="line"><span class="type">rt_adc_device_t</span> adc_dev;            <span class="comment">/* ADC 设备句柄 */</span></span><br><span class="line"><span class="type">rt_uint32_t</span> value；</span><br><span class="line"><span class="comment">/* 查找设备 */</span></span><br><span class="line">adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br><span class="line"><span class="comment">/* 使能设备 */</span></span><br><span class="line">rt_adc_enable(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"><span class="comment">/* 读取采样值 */</span></span><br><span class="line">value = rt_adc_read(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"><span class="comment">/* 转换为对应电压值 */</span></span><br><span class="line">vol = value * REFER_VOLTAGE / CONVERT_BITS;</span><br><span class="line">rt_kprintf(<span class="string">&quot;the voltage is :%d.%02d \n&quot;</span>, vol / <span class="number">100</span>, vol % <span class="number">100</span>);</span><br><span class="line"><span class="comment">/* 关闭通道 */</span></span><br><span class="line">rt_adc_disable(adc_dev, ADC_DEV_CHANNEL);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、-初始化设备stm32-adc-init&quot;&gt;&lt;a href=&quot;#一、-初始化设备stm32-adc-init&quot; class=&quot;headerlink&quot; title=&quot;一、 初始化设备stm32_adc_init()&quot;&gt;&lt;/a&gt;一、 初始化设备stm32_adc_</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-0-启动流程</title>
    <link href="https://ydw-item.github.io.git/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://ydw-item.github.io.git/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2025-02-15T15:57:05.000Z</published>
    <updated>2024-02-15T15:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、startup-stm32f407xx-S"><a href="#一、startup-stm32f407xx-S" class="headerlink" title="一、startup_stm32f407xx.S"></a>一、startup_stm32f407xx.S</h1><p>系统进入汇编文件</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image-20250215165008148"></p><p><strong>RT-Thread使用的是GCC</strong></p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/rtt_startup.png" alt="启动流程"></p><h1 id="二、不同编译器的启动函数"><a href="#二、不同编译器的启动函数" class="headerlink" title="二、不同编译器的启动函数"></a>二、不同编译器的启动函数</h1><p>调用stm32f407_demo3\rt-thread\src\components.c中的$Sub$$main()</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image-20250215223923007"></p><h1 id="三、调用rtthread-startup-void"><a href="#三、调用rtthread-startup-void" class="headerlink" title="三、调用rtthread_startup(void)"></a>三、调用rtthread_startup(void)</h1><p>在stm32f407_demo3\rt-thread\src\components.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rtthread_startup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 禁用了所有中断 */</span></span><br><span class="line">    rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* 执行板级支持包（BSP）初始化 </span></span><br><span class="line"><span class="comment">       包括配置硬件、系统时钟、外设初始化等 */</span></span><br><span class="line">    rt_hw_board_init();</span><br><span class="line"> <span class="comment">/* 打印 RT-Thread 操作系统的版本信息 */</span></span><br><span class="line">    rt_show_version();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的定时器子系统 */</span></span><br><span class="line">    rt_system_timer_init();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的调度器 */</span></span><br><span class="line">    rt_system_scheduler_init();</span><br><span class="line"><span class="comment">/* 如果启用了信号系统 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SIGNALS</span></span><br><span class="line">    <span class="comment">/* 初始化信号系统 */</span></span><br><span class="line">    rt_system_signal_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 创建应用任务、初始化外设 */</span></span><br><span class="line">    rt_application_init();</span><br><span class="line">    <span class="comment">/* 初始化定时器线程 */</span></span><br><span class="line">    rt_system_timer_thread_init();</span><br><span class="line">    <span class="comment">/* 初始化空闲线程 */</span></span><br><span class="line">    rt_thread_idle_init();</span><br><span class="line"><span class="comment">/* 如果启用了 SMP（对称多处理） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SMP</span></span><br><span class="line">    <span class="comment">/* 进行多核处理器的初始化和同步 */</span></span><br><span class="line">    rt_hw_spin_lock(&amp;_cpus_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*RT_USING_SMP*/</span></span></span><br><span class="line">    <span class="comment">/* 开始任务调度 */</span></span><br><span class="line">    rt_system_scheduler_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* never reach here */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1rt-hw-board-init和rt-application-init的-外设初始化的不同"><a href="#3-1rt-hw-board-init和rt-application-init的-外设初始化的不同" class="headerlink" title="3.1rt_hw_board_init和rt_application_init的 外设初始化的不同"></a>3.1rt_hw_board_init和rt_application_init的 外设初始化的不同</h2><ul><li><strong>rt_hw_board_init</strong></li></ul><p><strong>硬件初始化</strong>：<em><strong>初始化硬件资源</strong></em>，如 GPIO、串口、SPI、I2C、PWM、ADC、定时器等。</p><p><strong>系统时钟配置</strong>：配置系统时钟、外设时钟以及 PLL（锁相环）等，确保系统和外设运行在合适的频率下。</p><p><strong>内存初始化</strong>：配置堆栈、堆内存和静态内存区域，确保系统资源可用。</p><p><strong>中断配置</strong>：初始化中断控制器，并为特定外设启用中断。</p><p><strong>启动引导程序</strong>：执行系统初始化，如配置时钟源、初始化硬件外设等，通常会包括一个初始化阶段的启动代码。</p><p><strong>设备驱动注册</strong>：为基础硬件外设（如 UART、SPI、I2C 等）注册驱动，使操作系统能够访问这些外设。</p><ul><li><strong>rt_application_init</strong></li></ul><p><strong>创建应用任务</strong>：创建系统中的应用任务，例如数据采集任务、处理任务等。</p><p><strong>初始化外设</strong>：在 <strong>应用层</strong> 对外设进行更高层次的初始化。例如，在硬件初始化后，可能会初始化一些<em><strong>外设的具体参数</strong></em>，如设置 ADC 采样周期、配置传感器等。</p><p><strong>启动应用程序逻辑</strong>：进行传感器数据采集、通信协议的初始化、数据处理等应用相关的工作。</p><p><strong>任务调度和资源管理</strong>：创建并调度多个任务，管理应用程序层的资源。</p><h2 id="3-2rt-hw-board-init"><a href="#3-2rt-hw-board-init" class="headerlink" title="3.2rt_hw_board_init()"></a>3.2rt_hw_board_init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RT_WEAK <span class="type">void</span> <span class="title function_">rt_hw_board_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Heap initialization */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_HEAP)</span></span><br><span class="line">    rt_system_heap_init((<span class="type">void</span> *) HEAP_BEGIN, (<span class="type">void</span> *) HEAP_END);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 时钟源初始化，配置 MCU 的时钟系统，设置系统时钟、外设时钟 */</span></span><br><span class="line">    hw_board_init(BSP_CLOCK_SOURCE, BSP_CLOCK_SOURCE_FREQ_MHZ, BSP_CLOCK_SYSTEM_FREQ_MHZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置控制台设备。通常，这意味着将输出通过串口或其他通信接口进行调试输出。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_DEVICE) &amp;&amp; defined(RT_USING_CONSOLE)</span></span><br><span class="line">    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 始化板级硬件组件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_COMPONENTS_INIT</span></span><br><span class="line">    rt_components_board_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1hw-board-init"><a href="#3-2-1hw-board-init" class="headerlink" title="3.2.1hw_board_init()"></a>3.2.1hw_board_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">oid <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rt_hw_systick_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clk_init</span><span class="params">(<span class="type">char</span> *clk_source, <span class="type">int</span> source_freq, <span class="type">int</span> target_freq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableICache</span></span><br><span class="line">    <span class="comment">/* 开启指令缓存，用于加速程序的指令获取。*/</span></span><br><span class="line">    SCB_EnableICache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableDCache</span></span><br><span class="line">    <span class="comment">/* 开启数据缓存，用于加速数据存取。*/</span></span><br><span class="line">    SCB_EnableDCache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 HAL 库需要的硬件资源，例如时钟配置、外设初始化等 */</span></span><br><span class="line">    HAL_Init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器清零，开启全局中断 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 初始化系统时钟 */</span></span><br><span class="line">    clk_init(clock_src, clock_src_freq, clock_target_freq);</span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器设置为 1，禁止全局中断。确保时钟配置的过程中不会受到中断的干扰 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 初始化 SysTick 定时器 */</span></span><br><span class="line">    rt_hw_systick_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化与硬件引脚相关的驱动（如 GPIO 控制）。 </span></span><br><span class="line"><span class="comment">       初始化所有的通用输入输出引脚，设置引脚模式、方向、输出类型等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_PIN</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_pin_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_pin_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 USART 驱动 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SERIAL</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_usart_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image-20250215174007724"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 计算定义了几个串口，通过串口配置结构体的总大小/每个结构体的大小来计算*/</span></span><br><span class="line">    <span class="type">rt_size_t</span> obj_num = <span class="keyword">sizeof</span>(uart_obj) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stm32_uart);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_configure</span> <span class="title">config</span> =</span> RT_SERIAL_CONFIG_DEFAULT;</span><br><span class="line">    <span class="type">rt_err_t</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stm32_uart_get_dma_config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_obj[i].config = &amp;uart_config[i];</span><br><span class="line">        uart_obj[i].serial.ops    = &amp;stm32_uart_ops;</span><br><span class="line">        uart_obj[i].serial.config = config;</span><br><span class="line">        <span class="comment">/* 用于注册串口设备，将串口设备与操作系统的设备管理系统连接起来，使得串口设备能够被操作系统识别和管理</span></span><br><span class="line"><span class="comment">        register ----  注册*/</span></span><br><span class="line">        result = rt_hw_serial_register(&amp;uart_obj[i].serial, uart_obj[i].config-&gt;name,</span><br><span class="line">                                       RT_DEVICE_FLAG_RDWR</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_RX</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_TX</span><br><span class="line">                                       | uart_obj[i].uart_dma_flag</span><br><span class="line">                                       , <span class="literal">NULL</span>);</span><br><span class="line">        RT_ASSERT(result == RT_EOK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image-20250215174346247"></p><h2 id="3-3-rt-show-version-void"><a href="#3-3-rt-show-version-void" class="headerlink" title="3.3 rt_show_version(void)"></a>3.3 rt_show_version(void)</h2><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image-20250215224815579"></p><h2 id="3-4-rt-application-init"><a href="#3-4-rt-application-init" class="headerlink" title="3.4 rt_application_init()"></a>3.4 rt_application_init()</h2><p>创建main()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image-20250215230134023"></p><h2 id="3-5-rt-system-timer-thread-init"><a href="#3-5-rt-system-timer-thread-init" class="headerlink" title="3.5 rt_system_timer_thread_init()"></a>3.5 rt_system_timer_thread_init()</h2><p>创建rt_thread_timer_entry()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image-20250215230248093"></p><h3 id="3-5-1rt-thread-timer-entry"><a href="#3-5-1rt-thread-timer-entry" class="headerlink" title="3.5.1rt_thread_timer_entry()"></a>3.5.1rt_thread_timer_entry()</h3><p>专门用于处理软件定时器的线程函数,定期检查并触发到期的定时器回调。当没有定时器超时时，当前线程会被挂起，直到下一个定时器到期为止。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image-20250215231635484"></p><ul><li>它首先通过 <code>rt_timer_list_next_timeout</code> 获取下一个定时器的超时时间。</li><li>如果没有定时器超时，它会挂起当前线程，直到有定时器超时。</li><li>如果有定时器将要超时，函数会计算剩余时间，并使线程在该时间段内休眠，直到定时器超时。</li><li>每次循环结束时，<code>rt_soft_timer_check()</code> 会检查所有的软件定时器，触发到期的定时器回调。</li></ul><h2 id="3-6-rt-thread-idle-init"><a href="#3-6-rt-thread-idle-init" class="headerlink" title="3.6 rt_thread_idle_init()"></a>3.6 rt_thread_idle_init()</h2><p>初始化 <strong>空闲线程</strong>,是操作系统中的一个特殊线程，它在所有其他任务都没有运行时执行。通常，空闲线程用来降低系统功耗，或者执行一些后台清理任务。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image-20250215232409967"></p><h1 id="四、宏定义函数执行顺序"><a href="#四、宏定义函数执行顺序" class="headerlink" title="四、宏定义函数执行顺序"></a>四、宏定义函数执行顺序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 负责硬件平台的初始化，如时钟配置、外设初始化等。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, <span class="string">&quot;1&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化一些软件模块，可能包括设置一些内核参数、初始化操作系统调度器等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_PREV_EXPORT(fn)            INIT_EXPORT(fn, <span class="string">&quot;2&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化系统中的外设，如串口、GPIO、I2C、SPI 等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, <span class="string">&quot;3&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 包括文件系统（如 FatFS）、网络协议栈（如 lwIP）和其他应用组件的初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, <span class="string">&quot;4&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 涉及外部设备的挂载、环境配置、磁盘挂载等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_ENV_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;5&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 与应用程序级别的初始化相关，如图形界面（rtgui）、应用任务初始化等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;6&quot;</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、startup-stm32f407xx-S&quot;&gt;&lt;a href=&quot;#一、startup-stm32f407xx-S&quot; class=&quot;headerlink&quot; title=&quot;一、startup_stm32f407xx.S&quot;&gt;&lt;/a&gt;一、startup_stm32f4</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>USART通信</title>
    <link href="https://ydw-item.github.io.git/2024/12/23/USART/"/>
    <id>https://ydw-item.github.io.git/2024/12/23/USART/</id>
    <published>2024-12-22T16:18:30.000Z</published>
    <updated>2024-12-22T16:18:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、&quot;&gt;&lt;a href=&quot;#一、&quot; class=&quot;headerlink&quot; title=&quot;一、&quot;&gt;&lt;/a&gt;一、&lt;/h1&gt;</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="通信协议" scheme="https://ydw-item.github.io.git/categories/STM32/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="通讯协议" scheme="https://ydw-item.github.io.git/tags/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="USART" scheme="https://ydw-item.github.io.git/tags/USART/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯嵌入式模块使用指北</title>
    <link href="https://ydw-item.github.io.git/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>https://ydw-item.github.io.git/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</id>
    <published>2024-12-01T04:34:05.000Z</published>
    <updated>2025-01-31T17:26:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><center>本文不涉及原理，只涉及模块的使用<center>南京工业大学浦江学院 22级自动化 姚道文<p>[TOC]</p><h1 id="零、项目新建和LCD底层移植"><a href="#零、项目新建和LCD底层移植" class="headerlink" title="零、项目新建和LCD底层移植"></a>零、项目新建和LCD底层移植</h1><p><strong>链接： <a href="https://www.bilibili.com/video/BV18F4m1K7Ji/?share_source=copy_web&vd_source=63b2bec79fe7e44c34a744e91284ebb2">项目新建和LCD底层移植</a></strong></p><h1 id="一、Systick系统滴答定时器"><a href="#一、Systick系统滴答定时器" class="headerlink" title="一、Systick系统滴答定时器"></a>一、Systick系统滴答定时器</h1><blockquote><p>24位向下递减计数器，0~16,777,216</p><p>CubeMAX会自动将Systick配置成1ms中断的定时器，并将变量uwTick每1ms增加1</p><p>精确延时：HAL_Delay()函数,但会阻塞程序，在while中应控制在10s以内</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序每1ms进入1次该函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_IncTick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、KEY模块"><a href="#二、KEY模块" class="headerlink" title="二、KEY模块"></a><strong>二、KEY模块</strong></h1><h2 id="1-KEY模块CubeMX设置"><a href="#1-KEY模块CubeMX设置" class="headerlink" title="1.KEY模块CubeMX设置"></a>1.KEY模块CubeMX设置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/1.png" alt="img"></p><h2 id="2-KEY模块代码"><a href="#2-KEY模块代码" class="headerlink" title="2.KEY模块代码"></a>2.KEY模块代码</h2><h3 id="1-main-c文件"><a href="#1-main-c文件" class="headerlink" title="1.main.c文件"></a>1.main.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&quot;key.h&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-key-c文件"><a href="#2-key-c文件" class="headerlink" title="2.key.c文件"></a>2.key.c文件</h3><p><strong>宏定义的括号不可省略，想想#define KB1  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)和</strong></p><p><strong>KB1 &#x3D; HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)；有什么区别！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="comment">//没有按下是高电平，按下时低电平</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB1  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)    <span class="comment">//读取KB1电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB2  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1)    <span class="comment">//读取KB2电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB3  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2)    <span class="comment">//读取KB3电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB4  HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)    <span class="comment">//读取KB4电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPORT  KB1 | (KB2&lt;&lt;1) | (KB3&lt;&lt;2) | (KB4&lt;&lt;3) | 0xf0    <span class="comment">//读取的电平数据整合</span></span></span><br><span class="line">                                   </span><br><span class="line">u8 Trg;  <span class="comment">// 全局变量，单次触发</span></span><br><span class="line">u8 Cont;  <span class="comment">// 全局变量，长按</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ReadData = (KEYPORT)^<span class="number">0xff</span>;   <span class="comment">//将读取的电平数据转变成按下数据，按下之后对应位的数据变1</span></span><br><span class="line">  <span class="comment">//u8 ReadData = ~（KEYPORT）;                  //可替代上行代码</span></span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);      <span class="comment">//</span></span><br><span class="line">    Cont = ReadData;                         <span class="comment">//储存这次的按下数据，用于下次的比较</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*   代码解释</span></span><br><span class="line"><span class="comment">u8 ReadData = (KEYPORT)^0xff; //相当于取反操作，将读取的电平数据转变成亮灭数据</span></span><br><span class="line"><span class="comment">    (ReadData ^ Cont)         //将本次读数的按键与上次做对比，位不同则改位为1</span></span><br><span class="line"><span class="comment">    ReadData &amp; (ReadData ^ Cont)//将按下数据与改变情况做对比，位相同为1</span></span><br><span class="line"><span class="comment">*/</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//Example:</span></span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x01</span>)     <span class="comment">//单词触发</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Cont &amp; <span class="number">0x01</span>)    <span class="comment">//长按</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_cnt++;</span><br><span class="line">        <span class="keyword">if</span>(key_cnt == <span class="number">100</span>)    <span class="comment">//每10ms读取一次，此处判断是否长按1s</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt_key = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//do</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u32 keyTick;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(uwTick - keyTick &lt; <span class="number">20</span>) <span class="keyword">return</span>;     <span class="comment">//当小于20ms时，return出函数</span></span><br><span class="line">    keyTick = uwTick;</span><br><span class="line">    Key_Read();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x01</span>)    <span class="comment">//B2单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x02</span>)   <span class="comment">//B2单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x04</span>)   <span class="comment">//B3单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp;<span class="number">0x08</span>)    <span class="comment">//B4单次</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg == <span class="number">0x0C</span>)   <span class="comment">//B3和B4同时按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-key-h文件"><a href="#3-key-h文件" class="headerlink" title="3.key.h文件"></a>3.key.h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span>    <span class="comment">//包含后可使用u8</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 Trg;  <span class="comment">// 全局变量，单次触发</span></span><br><span class="line"><span class="keyword">extern</span> u8 Cont;  <span class="comment">// 全局变量，长按</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//最后必须留一空行</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、LED模块"><a href="#三、LED模块" class="headerlink" title="三、LED模块"></a>三、LED模块</h1><h2 id="1-LED模块CubeMX设置"><a href="#1-LED模块CubeMX设置" class="headerlink" title="1.LED模块CubeMX设置"></a>1.LED模块CubeMX设置</h2><p><strong>LED和LCD引脚冲突，PD2为LED的锁存器</strong></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/2.png" alt="img"></p><h2 id="2-LED模块代码"><a href="#2-LED模块代码" class="headerlink" title="2.LED模块代码"></a>2.LED模块代码</h2><h3 id="1-main-c文件-1"><a href="#1-main-c文件-1" class="headerlink" title="1.main.c文件"></a>1.main.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 LED_DATA ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LED_DATA |= <span class="number">0x01</span>;        <span class="comment">//开灯LED1 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LED_DATA &amp;= ~<span class="number">0x02</span>;       <span class="comment">//灭灯LED2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LED_Control(LED_DATA );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="2-led-c文件（led驱动文件）"><a href="#2-led-c文件（led驱动文件）" class="headerlink" title="2.led.c文件（led驱动文件）"></a>2.led.c文件（led驱动文件）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Control</span><span class="params">(u8 led_ctrl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先熄灭所有LED灯</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOC,<span class="number">0xff00</span>,GPIO_PIN_SET);       <span class="comment">//关闭所有灯，PC8~PC15为8个LED的引脚</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);   <span class="comment">//打开锁存器</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); <span class="comment">//打开锁存器</span></span><br><span class="line">    </span><br><span class="line">    HAL_GPIO_WritePin(GPIOC,led_ctrl &lt;&lt; <span class="number">8</span>,GPIO_PIN_RESET);<span class="comment">//开灯   </span></span><br><span class="line">    <span class="comment">//上一行是：0x01&lt;&lt;8变为0x0100,拉低PC8引脚，LED1点亮</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);   <span class="comment">//打开锁存器</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); <span class="comment">//打开锁存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-led-h文件"><a href="#3-led-h文件" class="headerlink" title="3.led.h文件"></a>3.led.h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span>                     <span class="comment">//包含后可使用u8</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Control</span><span class="params">(u8 led_ctrl)</span>;        <span class="comment">//声明函数</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="comment">//最后必须有一空行</span></span><br></pre></td></tr></table></figure><hr><h1 id="四、LCD模块"><a href="#四、LCD模块" class="headerlink" title="四、LCD模块"></a>四、LCD模块</h1><h3 id="1-LCD模块CubeMX设置"><a href="#1-LCD模块CubeMX设置" class="headerlink" title="1.LCD模块CubeMX设置"></a>1.LCD模块CubeMX设置</h3><p>配置见第<strong>零</strong>章</p><h3 id="2-LCD模块代码"><a href="#2-LCD模块代码" class="headerlink" title="2.LCD模块代码"></a>2.LCD模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏幕大小为20*10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>            <span class="comment">//sprintf需包含此头文件</span></span></span><br><span class="line"></span><br><span class="line">u32 lcdTick;                         <span class="comment">//读取计数器值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(uwTick - lcdTick &lt; <span class="number">200</span>) <span class="keyword">return</span>;   <span class="comment">//LCD每200ms刷新一次</span></span><br><span class="line">    uwTick = lcdTick;</span><br><span class="line"></span><br><span class="line">    u8 display_buf[<span class="number">20</span>];               <span class="comment">//定义缓冲区数组存储数据</span></span><br><span class="line"></span><br><span class="line">    LCD_DisplayStringLine(Line1,(u8*)<span class="string">&quot;        DATA&quot;</span>);   </span><br><span class="line">  <span class="comment">//sprintf函数作用，第二2.3参数与print函数使用相同，第一个参数是printf打印出的值</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   VR37:%4.2fV&quot;</span>,VR37);      </span><br><span class="line">    LCD_DisplayStringLine(Line3,(u8*)display_buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   VR38:%4.2fV&quot;</span>,VR38);</span><br><span class="line">    LCD_DisplayStringLine(Line4,(u8*)display_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   FR39:%05dHZ&quot;</span>,FR39);</span><br><span class="line">    LCD_DisplayStringLine(Line5,(u8*)display_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   FR40:%05dHZ&quot;</span>,FR40);</span><br><span class="line">    LCD_DisplayStringLine(Line6,(u8*)display_buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main（<span class="type">void</span>）</span><br><span class="line">&#123;    </span><br><span class="line">    LCD_Clear(Blue);           <span class="comment">//设置背景颜色</span></span><br><span class="line">    LCD_SetBackColor(Blue);    <span class="comment">//设置字体背景颜色</span></span><br><span class="line">    LCD_SetTextColor(White);   <span class="comment">//设置字体颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                     &#x3D;&#x3D;<strong>以上部分为嵌入式必考模块，务必熟练！！！</strong>&#x3D;&#x3D;</p><p>​                                                                           &#x3D;&#x3D;<strong>以下部分为嵌入式选考模块！！！</strong>&#x3D;&#x3D;</p><hr><h1 id="五、ADC模块"><a href="#五、ADC模块" class="headerlink" title="五、ADC模块"></a>五、ADC模块</h1><h3 id="1-ADC模块CubeMX设置"><a href="#1-ADC模块CubeMX设置" class="headerlink" title="1.ADC模块CubeMX设置"></a>1.ADC模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/3.png" alt="3cd136daad534bd48907ecb751b3fcf9.png"></p><ul><li>设置引脚</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/4.png" alt="efd7f43d3f52414fb7ca6ca3e0aabc63.png"></p><ul><li>设置ADC1</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/5.png" alt="d77692ab112c499eb5fac08be9c285a1.png"></p><ul><li>设置ADC2</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/6.png" alt="e3527d1a94d44343ba5274224aee9663.png"></p><h3 id="2-ADC多路采集模块代码"><a href="#2-ADC多路采集模块代码" class="headerlink" title="2.ADC多路采集模块代码"></a>2.ADC多路采集模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> VR37,VR38,VMCP;      <span class="comment">//定义电压变量</span></span><br><span class="line"><span class="type">float</span> val_R37,val_R38,val_MCP;<span class="comment">//0-4095</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span>                          </span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);                  <span class="comment">//开启adc1_ch5</span></span><br><span class="line">    val_MCP = HAL_ADC_GetValue(&amp;hadc1);     <span class="comment">//获取adc1_ch5的值</span></span><br><span class="line">    VMCP= val_MCP / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VMCP的值</span></span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);                  <span class="comment">//开启adc1_ch11</span></span><br><span class="line">    val_R38 = HAL_ADC_GetValue(&amp;hadc1);     <span class="comment">//获取adc1_ch11的值</span></span><br><span class="line">    VR38= val_R38 / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VR38的值</span></span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc2);                  <span class="comment">//开启adc2</span></span><br><span class="line">    val_R37 = HAL_ADC_GetValue(&amp;hadc2);     <span class="comment">//获取adc2的值</span></span><br><span class="line">    VR37 = val_R37 / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VR37的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ADC数字滤波代码（题目不要求，不用滤波）"><a href="#3-ADC数字滤波代码（题目不要求，不用滤波）" class="headerlink" title="3.ADC数字滤波代码（题目不要求，不用滤波）"></a>3.ADC数字滤波代码（题目不要求，不用滤波）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数字滤波*/</span></span><br><span class="line"><span class="type">float</span> VR37;        <span class="comment">//定义R37电压变量</span></span><br><span class="line">u32 sum_val_R37;   <span class="comment">//电压和变量</span></span><br><span class="line">u8 val_37_buf;     <span class="comment">//每次读出的值</span></span><br><span class="line">u8 adc_cnt = <span class="number">0</span>;    <span class="comment">//计数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    val_37_buf = HAL_ADC_GetValue(&amp;hadc2); <span class="comment">//获取值</span></span><br><span class="line">    sum_val_R37 += VR37;        <span class="comment">//和</span></span><br><span class="line">    adc_cnt++;                  <span class="comment">//次数加</span></span><br><span class="line">    <span class="keyword">if</span>(adc_cnt == <span class="number">10</span>)           <span class="comment">//判断否已经读取10次</span></span><br><span class="line">    &#123;</span><br><span class="line">        VR37 = sum_val_R37 / <span class="number">10.0f</span> / <span class="number">4095.0f</span> * <span class="number">3.3f</span>; <span class="comment">//求电压平均值</span></span><br><span class="line">        sum_val_R37 = <span class="number">0</span>;                             <span class="comment">//求和清零</span></span><br><span class="line">        adc_cnt = <span class="number">0</span>;                                 <span class="comment">//计数清零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历刷新数组中最老的值，求数组的平均值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc2);</span><br><span class="line">    adc2_val = HAL_ADC_GetValue(&amp;hadc2);</span><br><span class="line">    </span><br><span class="line">    ADC_buf[ADC_cnt] = adc2_val / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;      <span class="comment">//储存电压</span></span><br><span class="line">    <span class="keyword">for</span>(cnt=<span class="number">0</span> ;cnt &lt; <span class="number">10</span>;cnt++)                <span class="comment">//电压求和</span></span><br><span class="line">    &#123;</span><br><span class="line">        ADC_sum = ADC_sum + ADC_buf[cnt];    </span><br><span class="line">    &#125;    </span><br><span class="line">        VR37 = ADC_sum / <span class="number">10.0f</span>;              <span class="comment">//电压平均值</span></span><br><span class="line">        ADC_sum = <span class="number">0</span>;                        <span class="comment">//求和清零</span></span><br><span class="line">        ADC_cnt++;                          <span class="comment">//数组下标++</span></span><br><span class="line">    <span class="keyword">if</span>(ADC_cnt == <span class="number">9</span>)                        <span class="comment">//下标范围判断</span></span><br><span class="line">        ADC_cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>学自此可做第十届省赛真题：此届只涉及到了ADC外设。<br>链接:<a href="https://pan.baidu.com/s/1EFhwaQNt6CUTW5c5j0Eaxg">百度网盘：第十届省赛真题</a>  提取码: 6666 </p><h1 id="六、DAC输出模块"><a href="#六、DAC输出模块" class="headerlink" title="六、DAC输出模块"></a>六、DAC输出模块</h1><h2 id="1-DAC双路输出模块CubeMX设置"><a href="#1-DAC双路输出模块CubeMX设置" class="headerlink" title="1.DAC双路输出模块CubeMX设置"></a>1.DAC双路输出模块CubeMX设置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/7.png" alt="bdf317270b204cecb17134591f7d3799.png"></p><p>设置引脚</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/8.png" alt="{3b89c9117fbf41ac8e0bfc75f1446a68.png}"></p><p>DAC1设置</p><h2 id="2-DAC双路输出模块代码"><a href="#2-DAC双路输出模块代码" class="headerlink" title="2.DAC双路输出模块代码"></a>2.DAC双路输出模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">u16 dac_ch1_val,dac_ch2_val;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DAC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    dac_ch1_val = (<span class="number">1.1f</span>/<span class="number">3.3f</span>)*<span class="number">4095.0f</span>;  <span class="comment">//CH1输出1.1V</span></span><br><span class="line">    dac_ch2_val = (<span class="number">2.3f</span>/<span class="number">3.3f</span>)*<span class="number">4095.0f</span>;  <span class="comment">//CH2输出2.3V</span></span><br><span class="line">    </span><br><span class="line">    HAL_DAC_SetValue(&amp;hdac1,DAC_CHANNEL_1,DAC_ALIGN_12B_R,dac_ch1_val);<span class="comment">//设置DAC1，CH1的值</span></span><br><span class="line">    HAL_DAC_Start(&amp;hdac1,DAC_CHANNEL_1);            <span class="comment">//打开DAC1,CH1</span></span><br><span class="line">    </span><br><span class="line">    HAL_DAC_SetValue(&amp;hdac1,DAC_CHANNEL_2,DAC_ALIGN_12B_R,dac_ch2_val);<span class="comment">//设置DAC1，CH2的值</span></span><br><span class="line">    HAL_DAC_Start(&amp;hdac1,DAC_CHANNEL_2);            <span class="comment">//打开DAC1,CH2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="七、PWM捕获模块"><a href="#七、PWM捕获模块" class="headerlink" title="七、PWM捕获模块"></a>七、PWM捕获模块</h1><h3 id="1-PWM双路捕获模块CubeMX设置"><a href="#1-PWM双路捕获模块CubeMX设置" class="headerlink" title="1.PWM双路捕获模块CubeMX设置"></a>1.PWM双路捕获模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/9.png" alt="228e9d0e491a42d5a14bbf9698c3b860.png"></p><p><strong>设置引脚</strong></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/10.png" alt="0dbd4b9828e04a32b829f1d03cadc0df.png"></p><p>设置TIM2</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/11.png" alt="075bf965a7bc46fcaabe7bc08f3720e2.png"></p><p>设置TIM3</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/12.png" alt="ecb7f96fc5fd4cbda32ab62e34ef15e0.png"></p><p>打开TIM中断</p><h3 id="2-PWM双路捕获模块代码"><a href="#2-PWM双路捕获模块代码" class="headerlink" title="2.PWM双路捕获模块代码"></a>2.PWM双路捕获模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> VR37,VR38;      <span class="comment">//定义电压变量</span></span><br><span class="line">u16 FR39,FR40;        <span class="comment">//定义频率变量</span></span><br><span class="line"><span class="type">float</span> DR40,DR39;      <span class="comment">//占空比变量</span></span><br><span class="line"><span class="type">float</span> val_R37,val_R38;<span class="comment">//0-4095</span></span><br><span class="line">u8 PWM_R40_state =<span class="number">0</span>,PWM_R39_state;<span class="comment">//状态改变变量</span></span><br><span class="line">u16 R40_cnt1 = <span class="number">0</span>,R40_cnt2 = <span class="number">0</span>,R39_cnt1 = <span class="number">0</span>,R39_cnt2 = <span class="number">0</span>;    <span class="comment">//存储中断发生时间变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>    <span class="comment">//PWM捕获回调函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)      <span class="comment">//判断TIM2，R40</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(PWM_R40_state == <span class="number">0</span>)      <span class="comment">//第一个上升沿产生</span></span><br><span class="line">        &#123;   </span><br><span class="line">            TIM2-&gt;CNT = <span class="number">0</span>;          <span class="comment">//计数器清零</span></span><br><span class="line">            TIM2-&gt;CCER |= <span class="number">0x02</span>;  <span class="comment">//改为下降沿中断，CCER寄存器的第二位的值控制CH1的上下沿捕获</span></span><br><span class="line">            PWM_R40_state = <span class="number">1</span>;      <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R40_state == <span class="number">1</span>)      <span class="comment">//下降沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R40_cnt1 = TIM2-&gt;CNT;        <span class="comment">//获取计数(高电平时间)</span></span><br><span class="line">            TIM2-&gt;CCER &amp;= ~<span class="number">0x02</span>;         <span class="comment">//改为上升沿中断</span></span><br><span class="line">            PWM_R40_state = <span class="number">2</span>;           <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R40_state == <span class="number">2</span>)              <span class="comment">//第二个上升沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R40_cnt2 = TIM2-&gt;CNT;                <span class="comment">//获取计数（周期）</span></span><br><span class="line">            FR40 = <span class="number">1000000</span> / R40_cnt2;           <span class="comment">//计算频率</span></span><br><span class="line">            DR40 = R40_cnt1 *<span class="number">100.0f</span> / R40_cnt2 ; <span class="comment">//计算占空比</span></span><br><span class="line">            PWM_R40_state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_TIM_IC_Start_IT(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//重新打开中断</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim3)      <span class="comment">//判断TIM3，R39</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(PWM_R39_state == <span class="number">0</span>)      <span class="comment">//第一个上升沿产生</span></span><br><span class="line">        &#123;   </span><br><span class="line">            TIM3-&gt;CNT = <span class="number">0</span>;          <span class="comment">//计数器清零</span></span><br><span class="line">            TIM3-&gt;CCER |= <span class="number">0x02</span>;     <span class="comment">//改为下降沿中断</span></span><br><span class="line">            PWM_R39_state = <span class="number">1</span>;      <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R39_state == <span class="number">1</span>)      <span class="comment">//下降沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R39_cnt1 = TIM3-&gt;CNT;       <span class="comment">//获取计数(高电平时间)</span></span><br><span class="line">            TIM3-&gt;CCER &amp;= ~<span class="number">0x02</span>;        <span class="comment">//改为上升沿中断</span></span><br><span class="line">            PWM_R39_state = <span class="number">2</span>;          <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R39_state == <span class="number">2</span>)      <span class="comment">//第二个上升沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R39_cnt2 = TIM3-&gt;CNT;        <span class="comment">//获取计数（周期）</span></span><br><span class="line">            FR39 = <span class="number">1000000</span> / R39_cnt2;   <span class="comment">//计算频率</span></span><br><span class="line">            DR39 = R39_cnt1  *<span class="number">100.0f</span>/ R39_cnt2;   <span class="comment">//计算占空比</span></span><br><span class="line">            PWM_R39_state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_TIM_IC_Start_IT(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//重新打开中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码在main()中</span></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//开启PWM捕获中断</span></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//开启PWM捕获中断</span></span><br></pre></td></tr></table></figure><hr><h1 id="八、PWM输出模块"><a href="#八、PWM输出模块" class="headerlink" title="八、PWM输出模块"></a>八、PWM输出模块</h1><h3 id="1-PWM输出模块CubeMX设置"><a href="#1-PWM输出模块CubeMX设置" class="headerlink" title="1.PWM输出模块CubeMX设置"></a>1.PWM输出模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/13.png" alt="40f57283c6b34721ba805510e0f9f617.png"></p><p>设置引脚</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/14.png" alt="148c5a4ab14f4796b0f7cea266ac76c4.png"></p><p>TIM16设置</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/15.png" alt="3799c54ca0d74373a4edc908a878fdbb.png"></p><p>TIM17设置</p><h3 id="2-PWM输出模块代码"><a href="#2-PWM输出模块代码" class="headerlink" title="2.PWM输出模块代码"></a>2.PWM输出模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARR自动重装载值，CRR比较寄存器</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim16,TIM_CHANNEL_1);<span class="comment">//启用TIM16，通道1，PWM输出</span></span><br><span class="line">TIM16-&gt;ARR = <span class="number">999</span>;       <span class="comment">//设置频率为1000HZ</span></span><br><span class="line">TIM16-&gt;CCR1 = <span class="number">400</span>;      <span class="comment">//通道1，设置60%占空比</span></span><br><span class="line">    </span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim17,TIM_CHANNEL_1);<span class="comment">//启用TIM17，通道1，PWM输出</span></span><br><span class="line">TIM17-&gt;ARR = <span class="number">1999</span>;      <span class="comment">//设置频率为500HZ</span></span><br><span class="line">TIM17-&gt;CCR1 = <span class="number">100</span>;       <span class="comment">//通道1，设置95%占空比</span></span><br></pre></td></tr></table></figure><hr><h1 id="九、I2C模块"><a href="#九、I2C模块" class="headerlink" title="九、I2C模块"></a>九、I2C模块</h1><p>直接将官方的i2c.c,i2c.h添加到项目中</p><h2 id="1-I2C模块代码"><a href="#1-I2C模块代码" class="headerlink" title="1.I2C模块代码"></a>1.I2C模块代码</h2><h3 id="1-i2c-c文件"><a href="#1-i2c-c文件" class="headerlink" title="1.i2c.c文件"></a>1.i2c.c文件</h3><p>​    在i2c.c后编写    各函数主体9-12-6-7行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写24C02</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(u8 add,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">I2CStart();          <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa0</span>);   <span class="comment">//发送24c02地址，第一位0为写信号</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(add); <span class="comment">//发送填写地址</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(dat);    <span class="comment">//发送要储存的数据</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应 </span></span><br><span class="line"></span><br><span class="line">I2CStop();           <span class="comment">//发送停止信号</span></span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">5</span>);        <span class="comment">//延时，两次写入的间隔要5ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读24C02</span></span><br><span class="line">u8 <span class="title function_">EEPROM_Read</span><span class="params">(u8 add)</span>   </span><br><span class="line">&#123;</span><br><span class="line">I2CStart();          <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa0</span>);   <span class="comment">//发送24c02地址，第一位0为写信号</span></span><br><span class="line">I2CWaitAck();      </span><br><span class="line"></span><br><span class="line">I2CSendByte(add);    <span class="comment">//发送要读取数据的储存地址</span></span><br><span class="line">I2CWaitAck();        </span><br><span class="line"></span><br><span class="line">I2CStart();               <span class="comment">//再次发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa1</span>);        <span class="comment">//发送24c02地址，第一位1为读信号</span></span><br><span class="line">I2CWaitAck();           </span><br><span class="line"></span><br><span class="line">u8 dat = I2CReceiveByte();   <span class="comment">//读取数据</span></span><br><span class="line">I2CSendNotAck();          <span class="comment">//不应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                <span class="comment">//发送停止信号</span></span><br><span class="line"><span class="keyword">return</span>(dat);              <span class="comment">//返回数据接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写MCP4017</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MCP4017_Write</span><span class="params">(u8 val)</span></span><br><span class="line">&#123;   </span><br><span class="line">I2CStart();                <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0x5E</span>);         <span class="comment">//发送器件地址，写信号</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(val);          <span class="comment">//发送数据        //8位数据，但最高位为0</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                 <span class="comment">//发送结束信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读MCP4017</span></span><br><span class="line">u8 <span class="title function_">MCP4017_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">I2CStart();                <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0x5F</span>);         <span class="comment">//发送器件地址，读信号</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">u8 val = I2CReceiveByte();    <span class="comment">//接收数据</span></span><br><span class="line">I2CSendNotAck();           <span class="comment">//不应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                 <span class="comment">//发送停止信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val;                <span class="comment">//返回接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MCP4017数字电位器*/</span></span><br></pre></td></tr></table></figure><h2 id="2-main-c文件"><a href="#2-main-c文件" class="headerlink" title="2.main.c文件"></a>2.main.c文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span>    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2CInit();    <span class="comment">//初始化IO口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Rs * 127 &#x3D; 100k -&gt;Rs &#x3D; 100k &#x2F; 127    Rs是接入电路的每段电阻，共127个</p><p>R &#x3D; 8 *（100 &#x2F; 127）        R是接入电路的电阻</p><p>V &#x3D; 3.3 * R &#x2F; (R + 10)        输出的理论电压</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EEPROM_Write(<span class="number">0x08</span>);</span><br></pre></td></tr></table></figure><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/16.png" alt="aedc1195217f4e1ab2be933a6cc9aea4.png"></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/17.png" alt="91eecd4f6d85424597c59150f1aec333.png"></p><hr><h1 id="十、UART模块"><a href="#十、UART模块" class="headerlink" title="十、UART模块"></a>十、UART模块</h1><h2 id="1-UART模块CubeMX配置"><a href="#1-UART模块CubeMX配置" class="headerlink" title="1.UART模块CubeMX配置"></a>1.UART模块CubeMX配置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/21.png" alt="img"></p><h2 id="2-UART发送模块代码"><a href="#2-UART发送模块代码" class="headerlink" title="2.UART发送模块代码"></a>2.UART发送模块代码</h2><p>查找fputs()的方法</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/18.png" alt="img"></p><p>务必勾选MicroLIB库，否则fputs()重映射无法使用</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/19.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在&quot;usart.h&quot;中声明*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>        <span class="comment">//包含后可使用FILE</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*printf重定向在&quot;usart.c&quot;中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(<span class="type">unsigned</span> <span class="type">char</span>*)&amp;ch,<span class="number">1</span>,<span class="number">50</span>);    <span class="comment">//串口发送函数</span></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在&quot;main.h&quot;中直接使用printf发出数据*/</span></span><br><span class="line">u8 val = <span class="number">123</span>;                     <span class="comment">//定义变量</span></span><br><span class="line">u8 buf[<span class="number">50</span>] = &#123;<span class="string">&quot;lanqiaobei\r\n&quot;</span>&#125;;  <span class="comment">//定义数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!\r\n&quot;</span>);        <span class="comment">//发送字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="number">666</span>);             <span class="comment">//发送数字    </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d\r\n&quot;</span>,&amp;val);        <span class="comment">//发送变量中的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>,buf);             <span class="comment">//发送数组</span></span><br></pre></td></tr></table></figure><h2 id="3-UART接收模块代码"><a href="#3-UART接收模块代码" class="headerlink" title="3.UART接收模块代码"></a>3.UART接收模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>    <span class="comment">//包含后可使用memset()函数</span></span></span><br><span class="line">u8 uart_buf[<span class="number">20</span>];       <span class="comment">//uart接收数组</span></span><br><span class="line">u32 uartTick;          <span class="comment">//uart定时器计数变量</span></span><br><span class="line">u8 rx_cnt;             <span class="comment">//uart数据下表变量</span></span><br><span class="line">u8 rx_buf[<span class="number">10</span>];         <span class="comment">//uart接收缓存数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RxIdle_Process</span><span class="params">()</span>                   <span class="comment">//拓展部分函数，用于清空储存数组中的垃圾值        </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(uwTick - uartTick &lt; <span class="number">50</span>)<span class="keyword">return</span>;           <span class="comment">//50ms执行一次</span></span><br><span class="line">    uartTick = uwTick;</span><br><span class="line"></span><br><span class="line">    rx_cnt = <span class="number">0</span>;                                 <span class="comment">//计数下标清零</span></span><br><span class="line">    <span class="built_in">memset</span>(rx_buf,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(rx_buf));         <span class="comment">//清空rx_buf中的数据，使用要引用&lt;string.h&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>     <span class="comment">//uart接收回调中断</span></span><br><span class="line">&#123;</span><br><span class="line">    uartTick = uwTick;                          <span class="comment">//重新计时50ms</span></span><br><span class="line">    </span><br><span class="line">    rx_buf[rx_cnt++] = uart_buf[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(rx_cnt == <span class="number">3</span>)                    <span class="comment">//此处代码为：当接收到3个值时，执行亮灯操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        rx_cnt = <span class="number">0</span>;</span><br><span class="line">        LED_Control(rx_buf[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,uart_buf,<span class="number">1</span>);    <span class="comment">//重新打开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,uart_buf,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="十一、RTC模块"><a href="#十一、RTC模块" class="headerlink" title="十一、RTC模块"></a>十一、RTC模块</h1><h2 id="1-RTC模块CubeMX配置"><a href="#1-RTC模块CubeMX配置" class="headerlink" title="1.RTC模块CubeMX配置"></a>1.RTC模块CubeMX配置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/20.png" alt="3bd079d3540a45a6aa1f6ab3f3300362.png"></p><p>RTC配置</p><h2 id="2-RTC模块代码"><a href="#2-RTC模块代码" class="headerlink" title="2.RTC模块代码"></a>2.RTC模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTC_TimeTypeDef RTC_time;<span class="comment">//定义时间结构体变量</span></span><br><span class="line">RTC_DateTypeDef RTC_data;<span class="comment">//定义日期结构体变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc,&amp;RTC_time,RTC_FORMAT_BIN);<span class="comment">//获取时间，返回十进制</span></span><br><span class="line">    HAL_RTC_GetDate(&amp;hrtc,&amp;RTC_data,RTC_FORMAT_BIN);<span class="comment">//获取日期，返回十进制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></center></center>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;center&gt;本文不涉及原理，只涉及模块的使用
&lt;center&gt;南京工业大学浦江学院 22级自动化 姚道文

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="蓝桥杯" scheme="https://ydw-item.github.io.git/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="嵌入式" scheme="https://ydw-item.github.io.git/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="蓝桥杯" scheme="https://ydw-item.github.io.git/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="嵌入式" scheme="https://ydw-item.github.io.git/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GPIO基础知识</title>
    <link href="https://ydw-item.github.io.git/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://ydw-item.github.io.git/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-09-27T16:07:09.000Z</published>
    <updated>2024-09-27T16:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GPIO：通用型输入输出，可以<code>控制输入输出</code>的STM32引脚</strong></p><table><thead><tr><th align="center"><strong>浮空输入</strong></th><th align="center"><strong>Input floating</strong></th></tr></thead><tbody><tr><td align="center"><strong>拉上输入</strong></td><td align="center"><strong>Input pull-up</strong></td></tr><tr><td align="center"><strong>下拉输入</strong></td><td align="center"><strong>Input-pull-down</strong></td></tr><tr><td align="center"><strong>模拟输入</strong></td><td align="center"><strong>Anglog</strong></td></tr><tr><td align="center"><strong>开漏输出</strong></td><td align="center"><strong>Output open-drain</strong></td></tr><tr><td align="center"><strong>推挽输出</strong></td><td align="center"><strong>Output push-pull</strong></td></tr><tr><td align="center"><strong>推翻复用</strong></td><td align="center"><strong>Alternate function push-pull</strong></td></tr><tr><td align="center"><strong>开漏复用</strong></td><td align="center"><strong>Alternate function open-drain</strong></td></tr></tbody></table><p><strong>输出模式：<code>控制端口输出高电平低电平</code>，用于驱动LED，蜂鸣器等，若十大功率器件，则要加上驱动器（小电流控制大电流）</strong></p><p><strong>输入模式：<code>读取端口的高低电平</code>，用于读取外接按键，外接模拟信号的输入，ADC电压采集，模拟通信协议接受数据等</strong></p><p><img src="/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240927202349798.png" alt="image-20240927202349798"></p><ul><li><strong>端口位设置&#x2F;清除寄存器(GPIOx_BSRR)(x&#x3D;A…E):低位用于设置ODRy位为1，高位用于设置ODRy位为0</strong></li><li><strong>端口输出数据寄存器(GPIOx_ODR)(x&#x3D;A..E):可以分别地对各个ODR位进行独立的设置&#x2F;清除</strong></li></ul><h1 id="一、推挽输出"><a href="#一、推挽输出" class="headerlink" title="一、推挽输出"></a>一、推挽输出</h1><ul><li><p><strong>当输出控制为1时</strong></p><p>  <strong>P-MOS导通，N-MOS不导通，输出<code>高电平</code></strong></p></li><li><p><strong>当输出控制为0时</strong></p></li></ul><p>​<strong>P-MOS永远不导通，N-MOS导通，输出低电平</strong></p><ul><li><strong>引脚<code>电流流向单片机內部</code>或着<code>从单片机内部流向外部</code></strong></li><li><strong>可以同时从输入寄存器读取引脚状态</strong></li><li><strong>使用场所</strong></li></ul><ol><li><strong>驱动能力需求高的场合</strong></li><li><strong>高速信号传输</strong></li><li><strong>无需共用信号线的场合</strong></li></ol><h1 id="二、开漏输出"><a href="#二、开漏输出" class="headerlink" title="二、开漏输出"></a>二、开漏输出</h1><ul><li><p><strong>输出控制为0</strong></p><p>  <strong>P-MOS永远关闭，N-MOS导通，  输出低电平</strong></p></li><li><p><strong>输出控制为1</strong></p></li></ul><p>​<strong>P-MOS永远不导通,N-MOS也不导通，输出高阻态</strong></p><p>​<strong>此时要想引脚输出高电平或低电平，需要在单片机外部，接上拉或下拉电阻</strong></p><p>​电阻很大–弱上拉     电阻很小–强上拉</p><ul><li><strong>可以同时从输入寄存器读取引脚状态</strong></li><li><strong>使用场所</strong></li></ul><ol><li><p><strong>多个设备共用信号线</strong></p></li><li><p><strong>不同电压系统之间的接口</strong></p></li><li><p><strong>需要外部上拉电阻来确定逻辑高电平的场合</strong></p></li><li><p><strong>工作时，两个MOS管交替工作来驱动负载。</strong></p><p> <strong>输出1时，上部晶体管导通将电流推向负载</strong></p></li></ol><p>​<strong>输出0时，下部集体管导通将电流拉回地线</strong></p><h1 id="三、复用功能"><a href="#三、复用功能" class="headerlink" title="三、复用功能"></a>三、复用功能</h1><p><strong>引脚不作为IO口来使用，用作其它功能</strong></p><h1 id="四、上拉和下拉输入"><a href="#四、上拉和下拉输入" class="headerlink" title="四、上拉和下拉输入"></a>四、上拉和下拉输入</h1><p><strong>读取引脚的电平</strong></p><ul><li><p><strong>当IO输入电压大于VDD，二极管导通，此时VIO &#x3D;&#x3D; VDD，保护芯片</strong></p></li><li><p><strong>当IO输入电压小于VDD，二极管导通，此时VIO &#x3D;&#x3D; VSS，保护芯片</strong>  </p></li><li><p><strong>该模式下输出功能无效</strong></p></li><li><p><strong>施密特触发器作用</strong></p></li></ul><p><img src="/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240928000612157.png" alt="image-20240928000612157"></p><h1 id="五、模拟输入"><a href="#五、模拟输入" class="headerlink" title="五、模拟输入"></a>五、模拟输入</h1><ul><li><p><strong>施密特触发器禁用，输入数据寄存器值为0</strong></p></li><li><p><strong>ADC</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GPIO：通用型输入输出，可以&lt;code&gt;控制输入输出&lt;/code&gt;的STM32引脚&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;浮空输入&lt;/strong&gt;&lt;/th&gt;
&lt;th al</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="外设" scheme="https://ydw-item.github.io.git/categories/STM32/%E5%A4%96%E8%AE%BE/"/>
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/tags/STM32/"/>
    
  </entry>
  
</feed>
