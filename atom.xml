<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The personal blog of 洒水水</title>
  
  <subtitle>姚道文</subtitle>
  <link href="https://ydw-item.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://ydw-item.github.io.git/"/>
  <updated>2025-03-11T08:28:30.000Z</updated>
  <id>https://ydw-item.github.io.git/</id>
  
  <author>
    <name>洒水水</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OV-Watch-11-CST816</title>
    <link href="https://ydw-item.github.io.git/2025/03/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/11.OV-Watch_CST816/"/>
    <id>https://ydw-item.github.io.git/2025/03/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/11.OV-Watch_CST816/</id>
    <published>2025-03-11T08:28:30.000Z</published>
    <updated>2025-03-11T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/m0_60313295/article/details/144648171?ops_request_misc=&request_id=&biz_id=102&utm_term=CST816&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-144648171.142%5Ev101%5Epc_search_result_base5&spm=1018.2226.3001.4187">【模块系列】STM32&amp;1.69TFT屏幕_cst816t-CSDN博客</a></p><p><img src="/2025/03/11/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/11.OV-Watch_CST816/1.png" alt="image-20250302143612984"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_6031</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-10-SPL06</title>
    <link href="https://ydw-item.github.io.git/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/"/>
    <id>https://ydw-item.github.io.git/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/</id>
    <published>2025-03-10T08:28:30.000Z</published>
    <updated>2025-03-10T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/hdhfkfnbru/article/details/134553635?ops_request_misc=%7B%22request_id%22:%226840e66b8131dce8d44a0e2b5d8926ca%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=6840e66b8131dce8d44a0e2b5d8926ca&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-134553635-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=spl06-001&spm=1018.2226.3001.4187">【传感器】SPL06-001（歌尔声学）-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_40598185/article/details/119347845?ops_request_misc=%7B%22request_id%22:%22b1b74e98a2848eda046f0182781c7856%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=b1b74e98a2848eda046f0182781c7856&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119347845-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=spl06&spm=1018.2226.3001.4187">SPL06电容式压力传感器数据读取与处理(基于STM32)-CSDN博客</a></p><p><img src="/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/1.png" alt="image-20250302142603950"></p><p><img src="/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/2.png" alt="image-20250302142619225"></p><p><img src="/2025/03/10/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/10.OV-Watch_SPL06/3.png" alt="image-20250302142709827"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hdhfkfn</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-9-POWER</title>
    <link href="https://ydw-item.github.io.git/2025/03/09/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/9.OV-Watch_POWER/"/>
    <id>https://ydw-item.github.io.git/2025/03/09/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/9.OV-Watch_POWER/</id>
    <published>2025-03-09T08:28:30.000Z</published>
    <updated>2025-03-09T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/weixin_45829708/article/details/124892787">【电源芯片】TPS63020升降压芯片-电池放电-CSDN博客</a></p><p><img src="/2025/03/09/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/9.OV-Watch_POWER/1.png" alt="image-20250302141655183"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-8-OWDG</title>
    <link href="https://ydw-item.github.io.git/2025/03/08/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/8.OV-Watch_OWDG/"/>
    <id>https://ydw-item.github.io.git/2025/03/08/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/8.OV-Watch_OWDG/</id>
    <published>2025-03-08T08:28:30.000Z</published>
    <updated>2025-03-08T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/zhuoqingjoking97298/article/details/121437976?ops_request_misc=%7B%22request_id%22:%229a230254f870292e2dfc70e4cb11001b%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=9a230254f870292e2dfc70e4cb11001b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-121437976-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=BL1551B&spm=1018.2226.3001.4187">BL1551模拟开关，封装SC70-6_bl1551中文资料-CSDN博客</a></p><p><a href="https://blog.csdn.net/gutie_bartholomew/article/details/88878248?ops_request_misc=%7B%22request_id%22:%22d68738496a6e2d51c751a092b86908fa%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=d68738496a6e2d51c751a092b86908fa&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88878248-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=TPS3823&spm=1018.2226.3001.4187">看门狗定时器实测-CSDN博客</a></p><p><img src="/2025/03/08/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/8.OV-Watch_OWDG/1.png" alt="image-20250302141027190"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhuoqin</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-7-MPU6050</title>
    <link href="https://ydw-item.github.io.git/2025/03/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/7.OV-Watch_MPU6050/"/>
    <id>https://ydw-item.github.io.git/2025/03/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/7.OV-Watch_MPU6050/</id>
    <published>2025-03-06T08:28:30.000Z</published>
    <updated>2025-03-06T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/weixin_44788542/article/details/129328712?ops_request_misc=%7B%22request_id%22:%225dc026da3d39d8006490552a9c75352b%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=5dc026da3d39d8006490552a9c75352b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129328712-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=MPU6050&spm=1018.2226.3001.4187">六轴传感器基础知识学习：MPU6050特性，四元数，姿态解算，卡尔曼滤波_mpu6050卡尔曼滤波姿态解算-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_45217381/article/details/134302880?ops_request_misc=%7B%22request_id%22:%225dc026da3d39d8006490552a9c75352b%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=5dc026da3d39d8006490552a9c75352b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-134302880-null-null.142%5Ev101%5Epc_search_result_base5&utm_term=MPU6050&spm=1018.2226.3001.4187">STM32外设系列—MPU6050角度传感器-CSDN博客</a></p><p><img src="/2025/03/06/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/7.OV-Watch_MPU6050/1.png" alt="image-20250302140809926"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-6-LSM303DLH</title>
    <link href="https://ydw-item.github.io.git/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/"/>
    <id>https://ydw-item.github.io.git/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/</id>
    <published>2025-03-05T08:28:30.000Z</published>
    <updated>2025-03-05T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/xiaolong1126626497/article/details/134456723">基于单片机设计的电子指南针(LSM303DLH模块(三轴磁场 + 三轴加速度)_lsm303dlh电子指南针-CSDN博客</a></p><p><img src="/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/1.png" alt="image-20250302134955498"></p><p><code>LSM_DRDY</code>,<code>LSM_INT2</code>,<code>LSM_INT1</code>没有连接引脚</p><p><img src="/2025/03/05/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/6.OV-Watch_LSM303DLH/2.png" alt="image-20250302135027564"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/xiaolon</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-5-EM7028</title>
    <link href="https://ydw-item.github.io.git/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/"/>
    <id>https://ydw-item.github.io.git/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/</id>
    <published>2025-03-04T08:28:30.000Z</published>
    <updated>2025-03-04T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/Graceful_scenery/article/details/144164078">STM2F411智能手环设计-CSDN博客</a></p><p><a href="https://wenku.csdn.net/column/1qfak96893">【心率信号处理】：EM7028数据采集、采样与滤波技术 - CSDN文库</a></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/1.png" alt="image-20250302125516606"></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/2.png" alt="image-20250302125540196"></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/3.png" alt="image-20250302125553257"></p><p><img src="/2025/03/04/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/5.OV-Watch_EM7028/image-20250302125623426.png" alt="image-20250302125623426"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Gracefu</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-4-BL24C02</title>
    <link href="https://ydw-item.github.io.git/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/"/>
    <id>https://ydw-item.github.io.git/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/</id>
    <published>2025-03-03T08:28:30.000Z</published>
    <updated>2025-03-03T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/kiss_youi/article/details/115468415">BL24Cxx系列EEPROM测试总结-CSDN博客</a></p><p><a href="https://blog.csdn.net/2401_85236922/article/details/141247699">BL24C02P芯片的使用说明&#x2F;i2c数据存储芯片-CSDN博客</a></p><p><img src="/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/1.png" alt="image-20250302124825002"></p><p><img src="/2025/03/03/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/4.OV-Watch_BL24C02/2.png" alt="image-20250302124752744"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kiss_yo</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-3-AHT21</title>
    <link href="https://ydw-item.github.io.git/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/"/>
    <id>https://ydw-item.github.io.git/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/</id>
    <published>2025-03-02T08:28:30.000Z</published>
    <updated>2025-03-02T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><a href="https://blog.csdn.net/weixin_45189628/article/details/111110465">关于基于I2C使用AHT21B模块及stm32核心板进行温湿度采集-CSDN博客</a></p><p><img src="/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/1.png" alt="image-20250302123509556"></p><p><img src="/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/2.png" alt="image-20250302123647037"></p><p><img src="/2025/03/02/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/3.OV-Watch_AHT21/3.png" alt="image-20250302123741051"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-1-Blue</title>
    <link href="https://ydw-item.github.io.git/2025/02/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/1.OV-Watch_blue/"/>
    <id>https://ydw-item.github.io.git/2025/02/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/1.OV-Watch_blue/</id>
    <published>2025-02-28T08:28:30.000Z</published>
    <updated>2025-02-28T08:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、硬件选型和原理图"><a href="#一、硬件选型和原理图" class="headerlink" title="一、硬件选型和原理图"></a>一、硬件选型和原理图</h1><p><img src="/2025/02/28/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/1.OV-Watch_blue/1.png" alt="image-20250228163058430"></p><table><thead><tr><th align="center">原理图引脚</th><th align="center">MCU引脚</th></tr></thead><tbody><tr><td align="center">BLE_TX</td><td align="center">PA9</td></tr><tr><td align="center">BLE_RX</td><td align="center">PA10</td></tr><tr><td align="center">BLE_EN</td><td align="center">PA8</td></tr></tbody></table><h2 id="1-BL1551B"><a href="#1-BL1551B" class="headerlink" title="1.BL1551B"></a>1.BL1551B</h2><p><a href="https://blog.csdn.net/zhuoqingjoking97298/article/details/121437976">BL1551模拟开关，封装SC70-6_bl1551中文资料-CSDN博客</a></p><h2 id="2-KT6328A1"><a href="#2-KT6328A1" class="headerlink" title="2.KT6328A1"></a>2.KT6328A1</h2><p><a href="https://blog.csdn.net/qyvhome/article/details/121592868">KT6368A国产蓝牙BLE芯片驱动程序&amp;硬件注意事项-CSDN博客</a></p><h1 id="二、软件"><a href="#二、软件" class="headerlink" title="二、软件"></a>二、软件</h1><h2 id="2-1-KT6328-h"><a href="#2-1-KT6328-h" class="headerlink" title="2.1 KT6328.h"></a>2.1 KT6328.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BLE_EN_PORT GPIOA<span class="comment">//宏定义引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLE_EN_GPIO GPIO_PIN_8</span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Disable</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="2-2-KT6328-c"><a href="#2-2-KT6328-c" class="headerlink" title="2.2 KT6328.c"></a>2.2 KT6328.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">KT6328_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET); <span class="comment">//确保引脚在初始化过程中保持已知且稳定的状态</span></span><br><span class="line"></span><br><span class="line">  GPIO_InitStruct.Pin = GPIO_PIN_8;</span><br><span class="line">  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">  GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">  HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(BLE_EN_PORT, BLE_EN_GPIO, GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">KT6328_Disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(BLE_EN_PORT, BLE_EN_GPIO, GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-usart-c"><a href="#2-3-usart-c" class="headerlink" title="2.3 usart.c"></a>2.3 usart.c</h2><p><a href="https://blog.csdn.net/weixin_44386927/article/details/112862801?sharetype=blogdetail&shareId=112862801&sharerefer=APP&sharesource=2303_77755415&sharefrom=link">一.在HAL库中使用串口（dma）模式接收发送测试_串口 dma 接收 hal库-CSDN博客</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MX_USART1_UART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_Init 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_Init 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_Init 1 */</span></span><br><span class="line">  huart1.Instance = USART1;</span><br><span class="line">  huart1.Init.BaudRate = <span class="number">115200</span>;</span><br><span class="line">  huart1.Init.WordLength = UART_WORDLENGTH_8B;</span><br><span class="line">  huart1.Init.StopBits = UART_STOPBITS_1;</span><br><span class="line">  huart1.Init.Parity = UART_PARITY_NONE;</span><br><span class="line">  huart1.Init.Mode = UART_MODE_TX_RX;</span><br><span class="line">  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;</span><br><span class="line">  huart1.Init.OverSampling = UART_OVERSAMPLING_16;</span><br><span class="line">  <span class="keyword">if</span> (HAL_UART_Init(&amp;huart1) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_Init 2 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_Init 2 */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_MspInit</span><span class="params">(UART_HandleTypeDef* uartHandle)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>(uartHandle-&gt;Instance==USART1)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_MspInit 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_MspInit 0 */</span></span><br><span class="line">    <span class="comment">/* USART1 clock enable */</span></span><br><span class="line">    __HAL_RCC_USART1_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">    __HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">    <span class="comment">/**USART1 GPIO Configuration</span></span><br><span class="line"><span class="comment">    PA9     ------&gt; USART1_TX</span></span><br><span class="line"><span class="comment">    PA10     ------&gt; USART1_RX</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;</span><br><span class="line">    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USART1 DMA Init */</span></span><br><span class="line">    <span class="comment">/* USART1_RX Init */</span></span><br><span class="line">    hdma_usart1_rx.Instance = DMA2_Stream5;</span><br><span class="line">    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;</span><br><span class="line">    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;</span><br><span class="line">    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_rx.Init.Mode = DMA_NORMAL;</span><br><span class="line">    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;</span><br><span class="line">    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;</span><br><span class="line">    <span class="keyword">if</span> (HAL_DMA_Init(&amp;hdma_usart1_rx) != HAL_OK)<span class="comment">//HAL_UART_Init()中调用了HAL_UART_MspInit()</span></span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart1_rx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USART1_TX Init */</span></span><br><span class="line">    hdma_usart1_tx.Instance = DMA2_Stream7;</span><br><span class="line">    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;</span><br><span class="line">    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;</span><br><span class="line">    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;</span><br><span class="line">    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;</span><br><span class="line">    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;</span><br><span class="line">    hdma_usart1_tx.Init.Mode = DMA_NORMAL;</span><br><span class="line">    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;</span><br><span class="line">    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;</span><br><span class="line">    <span class="keyword">if</span> (HAL_DMA_Init(&amp;hdma_usart1_tx) != HAL_OK)</span><br><span class="line">    &#123;</span><br><span class="line">      Error_Handler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart1_tx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USART1 interrupt Init */</span></span><br><span class="line">    HAL_NVIC_SetPriority(USART1_IRQn, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">    HAL_NVIC_EnableIRQ(USART1_IRQn);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN USART1_MspInit 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END USART1_MspInit 1 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HAL_UART_Init()<strong>中调用了</strong>HAL_UART_MspInit()</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、硬件选型和原理图&quot;&gt;&lt;a href=&quot;#一、硬件选型和原理图&quot; class=&quot;headerlink&quot; title=&quot;一、硬件选型和原理图&quot;&gt;&lt;/a&gt;一、硬件选型和原理图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2025/02/28/%E4%B8%AA%E4%BA%</summary>
      
    
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="个人项目" scheme="https://ydw-item.github.io.git/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="OV-Watch" scheme="https://ydw-item.github.io.git/tags/OV-Watch/"/>
    
  </entry>
  
  <entry>
    <title>SPI通信协议&amp;&amp;1.44寸TFT-LCD（ST7735S）</title>
    <link href="https://ydw-item.github.io.git/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&amp;&amp;1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/"/>
    <id>https://ydw-item.github.io.git/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&amp;&amp;1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/</id>
    <published>2025-02-26T11:03:49.000Z</published>
    <updated>2025-02-26T11:03:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、SPI"><a href="#一、SPI" class="headerlink" title="一、SPI"></a>一、SPI</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>SPI，英文全称Serial Peripheral Interface，即串行外围设备接口，是一种高速、<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%8F%8C%E5%B7%A5&spm=1001.2101.3001.7020">全双工</a>、同步的串行通信总线。</p><h2 id="1-2-信号线"><a href="#1-2-信号线" class="headerlink" title="1.2 信号线"></a>1.2 信号线</h2><ul><li><strong>SCK</strong>（Serial Clock）：串行<strong>时钟线</strong>，由主设备产生，用于同步数据传输。</li><li><strong>MOSI</strong>（Master Output Slave Input）：<strong>主机输出</strong>从机输入线，主设备通过这条线发送数据给从设备。</li><li>MISO（Master Input Slave Output）：<strong>主机输入</strong>从机输出线，主设备通过这条线接收从设备发送的数据。</li><li><strong>SS</strong>（Slave Select）：<strong>从机选择线</strong>（每个从机一根选择线），用于选择与主设备进行通信的从设备。通常情况下，SS线为低电平有效，即当SS线为低电平时，选中对应的从设备进行通信。</li></ul><h2 id="1-3-开始与结束"><a href="#1-3-开始与结束" class="headerlink" title="1.3 开始与结束"></a>1.3 开始与结束</h2><p>当SS从高电平拉低到低电平，这个算是起始的一个时序。而SS从低电平拉高到高电平，就算是结束的时序。</p><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/1.png" alt="img"></p><h2 id="1-4-发送和接收字节"><a href="#1-4-发送和接收字节" class="headerlink" title="1.4 发送和接收字节"></a>1.4 发送和接收字节</h2><p>发送接收字节看似是两个时序，但是在SPI中却是<strong>同一个时序</strong>，因为SPI的机制是我们发送一个字节，并且接收一个字节（<strong>哪怕我们并不需要接收数据</strong>）。反过来看也可以是我们接收一个字节，并且发送一个字节（<strong>哪怕这个字节是无用的数据</strong>）。</p><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/2.png" alt="img"></p><h2 id="交换bit"><a href="#交换bit" class="headerlink" title="交换bit"></a>交换bit</h2><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/3.png" alt="img"></p><p><strong>在SCK上升沿的时候，移出MOSI的数据，在SCK下降沿的时候读取MISO的数据。</strong></p><p><strong>需要在SCK上升沿之前把需要发送的数据位放置在MOSI线上</strong></p><p><strong>SCK下降沿的时候马上读取MISO线上的数据位</strong></p><p><strong>（实际上下降沿和读取应该是同时的，但是我们软件模拟没法同时，但是效果是一样的）</strong></p><h1 id="二、TFT-LCD"><a href="#二、TFT-LCD" class="headerlink" title="二、TFT-LCD"></a>二、TFT-LCD</h1><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/SPI%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE&&1.44%E5%AF%B8TFT-LCD%EF%BC%88ST7735S%EF%BC%89/4.png" alt="705A80E97488A8ADBF31C36755A03C23"></p><table><thead><tr><th>引脚</th><th>功能</th></tr></thead><tbody><tr><td>GND</td><td>接地</td></tr><tr><td>VCC</td><td>供电（3.3V-5V）</td></tr><tr><td>SCL</td><td>时钟信号</td></tr><tr><td>SDA</td><td>数据信号（MOSI）</td></tr><tr><td>RES</td><td>低电平TFT复位</td></tr><tr><td>DC</td><td>区分接受的是数据还是命令（低电平命令，高电平数据）</td></tr><tr><td>CS</td><td>片选信号，低电平使能</td></tr><tr><td>BLK</td><td>背光（可常接3.3V）</td></tr></tbody></table><h2 id="HAL-SPI-Transmit"><a href="#HAL-SPI-Transmit" class="headerlink" title="HAL_SPI_Transmit()"></a>HAL_SPI_Transmit()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_StatusTypeDef <span class="title function_">HAL_SPI_Transmit</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span><br></pre></td></tr></table></figure><p>**<code>SPI_HandleTypeDef \*hspi</code>**：</p><ul><li>指向 <strong>SPI 句柄</strong> 的指针。这个句柄包含了关于 SPI 外设的配置信息，必须在使用之前通过 <code>HAL_SPI_Init()</code> 初始化。</li></ul><p>**<code>uint8_t \*pData</code>**：</p><ul><li>指向要发送的数据的指针。<code>pData</code> 是一个数据缓冲区，包含要通过 SPI 发送的数据。数据以字节的形式存储。</li></ul><p>**<code>uint16_t Size</code>**：</p><ul><li>发送数据的大小，以字节为单位。<code>Size</code> 表示要发送的字节数。</li></ul><p>**<code>uint32_t Timeout</code>**：</p><ul><li>传输操作的超时时间，以毫秒为单位。如果在指定的时间内传输未完成，函数将返回超时错误。</li></ul><h2 id="LCD-GPIO-Init"><a href="#LCD-GPIO-Init" class="headerlink" title="LCD_GPIO_Init()"></a>LCD_GPIO_Init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDef  GPIO_InitStructure = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">__HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line"> __HAL_RCC_GPIOB_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOD_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = BLK_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOA</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOA, BLK_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = RES_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOB</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOB, RES_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = DC_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOC</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOC, DC_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.Pin = CS_PIN; </span><br><span class="line"> GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;  <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<span class="comment">//速度50MHz</span></span><br><span class="line"> HAL_GPIO_Init(GPIOD, &amp;GPIO_InitStructure);  <span class="comment">//初始化GPIOD</span></span><br><span class="line"> HAL_GPIO_WritePin(GPIOD, CS_PIN, GPIO_PIN_SET);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个字节数据-LCD-Writ-Bus"><a href="#写一个字节数据-LCD-Writ-Bus" class="headerlink" title="写一个字节数据 LCD_Writ_Bus()"></a>写一个字节数据 LCD_Writ_Bus()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Writ_Bus</span><span class="params">(u8 dat)</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//hard SPI</span></span><br><span class="line">HAL_SPI_Transmit(&amp;hspi1,&amp;dat,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//soft SPI</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">u8 i;</span></span><br><span class="line"><span class="comment">for(i=0;i&lt;8;i++)</span></span><br><span class="line"><span class="comment">&#123;  </span></span><br><span class="line"><span class="comment">LCD_SCLK_Clr();</span></span><br><span class="line"><span class="comment">if(dat&amp;0x80)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">   LCD_MOSI_Set();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">   LCD_MOSI_Clr();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">LCD_SCLK_Set();</span></span><br><span class="line"><span class="comment">dat&lt;&lt;=1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写两个字节数据-LCD-WR-DATA"><a href="#写两个字节数据-LCD-WR-DATA" class="headerlink" title="写两个字节数据 LCD_WR_DATA()"></a>写两个字节数据 LCD_WR_DATA()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_DATA</span><span class="params">(u16 dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//LCD_Writ_Bus(dat&gt;&gt;8);</span></span><br><span class="line"><span class="comment">//LCD_Writ_Bus(dat);</span></span><br><span class="line"><span class="type">uint8_t</span> temp[<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">0</span>]=(dat&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>;</span><br><span class="line">temp[<span class="number">1</span>]=dat&amp;<span class="number">0xff</span>;</span><br><span class="line">HAL_SPI_Transmit(&amp;hspi1,temp,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写命令-LCD-WR-REG"><a href="#写命令-LCD-WR-REG" class="headerlink" title="写命令 LCD_WR_REG()"></a>写命令 LCD_WR_REG()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_REG</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_DC_Clr();<span class="comment">//写命令</span></span><br><span class="line">LCD_Writ_Bus(dat);</span><br><span class="line">LCD_DC_Set();<span class="comment">//写数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置起始和初始地址-LCD-Address-Set"><a href="#设置起始和初始地址-LCD-Address-Set" class="headerlink" title="设置起始和初始地址 LCD_Address_Set()"></a>设置起始和初始地址 LCD_Address_Set()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Address_Set</span><span class="params">(u16 x1,u16 y1,u16 x2,u16 y2)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_WR_REG(<span class="number">0x2a</span>);<span class="comment">//列地址设置</span></span><br><span class="line">LCD_WR_DATA(x1);</span><br><span class="line">LCD_WR_DATA(x2);</span><br><span class="line">LCD_WR_REG(<span class="number">0x2b</span>);<span class="comment">//行地址设置</span></span><br><span class="line">LCD_WR_DATA(y1);</span><br><span class="line">LCD_WR_DATA(y2);</span><br><span class="line">LCD_WR_REG(<span class="number">0x2c</span>);<span class="comment">//储存器写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置显示区域</strong>：该函数通过设置列地址和行地址，定义了一个矩形区域 <code>(x1, y1)</code> 到 <code>(x2, y2)</code>，然后准备向该区域写入图像数据或颜色。</p><p><strong>显示区域绘制</strong>：在调用 <code>LCD_Address_Set()</code> 后，LCD 屏幕的指定区域就被设置好了，之后可以通过其他函数（例如 <code>LCD_WriteColor()</code> 或类似的函数）向该区域写入具体的颜色或图像数据，从而实现绘制操作。</p><h1 id="LCD常用函数"><a href="#LCD常用函数" class="headerlink" title="LCD常用函数"></a>LCD常用函数</h1><h2 id="1-LCD-Fill-区域颜色填充"><a href="#1-LCD-Fill-区域颜色填充" class="headerlink" title="1.LCD_Fill()区域颜色填充"></a>1.LCD_Fill()区域颜色填充</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_Fill</span><span class="params">(u16 xsta,u16 ysta,u16 xend,u16 yend,u16 color)</span></span><br><span class="line">&#123;          </span><br><span class="line">u16 i,j; </span><br><span class="line">LCD_Address_Set(xsta+OFFSET_X,ysta+OFFSET_Y,xend+OFFSET_X<span class="number">-1</span>,yend<span class="number">-1</span>+OFFSET_Y);<span class="comment">//设置显示范围</span></span><br><span class="line"><span class="keyword">for</span>(i=ysta;i&lt;yend;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=xsta;j&lt;xend;j++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WR_DATA(color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-指定位置画点LCD-DrawPoint"><a href="#2-指定位置画点LCD-DrawPoint" class="headerlink" title="2.指定位置画点LCD_DrawPoint()"></a>2.指定位置画点LCD_DrawPoint()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawPoint</span><span class="params">(u16 x,u16 y,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_Address_Set(x,y,x,y);<span class="comment">//设置光标位置 </span></span><br><span class="line">LCD_WR_DATA(color);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="3-画线LCD-DrawLine"><a href="#3-画线LCD-DrawLine" class="headerlink" title="3.画线LCD_DrawLine()"></a>3.画线LCD_DrawLine()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawLine</span><span class="params">(u16 x1,u16 y1,u16 x2,u16 y2,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line">u16 t; </span><br><span class="line"><span class="type">int</span> xerr=<span class="number">0</span>,yerr=<span class="number">0</span>,delta_x,delta_y,distance;</span><br><span class="line"><span class="type">int</span> incx,incy,uRow,uCol;</span><br><span class="line">delta_x=x2-x1; <span class="comment">//计算坐标增量 </span></span><br><span class="line">delta_y=y2-y1;</span><br><span class="line">uRow=x1;<span class="comment">//画线起点坐标</span></span><br><span class="line">uCol=y1;</span><br><span class="line"><span class="keyword">if</span>(delta_x&gt;<span class="number">0</span>)incx=<span class="number">1</span>; <span class="comment">//设置单步方向 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_x==<span class="number">0</span>)incx=<span class="number">0</span>;<span class="comment">//垂直线 </span></span><br><span class="line"><span class="keyword">else</span> &#123;incx=<span class="number">-1</span>;delta_x=-delta_x;&#125;</span><br><span class="line"><span class="keyword">if</span>(delta_y&gt;<span class="number">0</span>)incy=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (delta_y==<span class="number">0</span>)incy=<span class="number">0</span>;<span class="comment">//水平线 </span></span><br><span class="line"><span class="keyword">else</span> &#123;incy=<span class="number">-1</span>;delta_y=-delta_y;&#125;</span><br><span class="line"><span class="keyword">if</span>(delta_x&gt;delta_y)distance=delta_x; <span class="comment">//选取基本增量坐标轴 </span></span><br><span class="line"><span class="keyword">else</span> distance=delta_y;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;distance+<span class="number">1</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_DrawPoint(uRow,uCol,color);<span class="comment">//画点</span></span><br><span class="line">xerr+=delta_x;</span><br><span class="line">yerr+=delta_y;</span><br><span class="line"><span class="keyword">if</span>(xerr&gt;distance)</span><br><span class="line">&#123;</span><br><span class="line">xerr-=distance;</span><br><span class="line">uRow+=incx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(yerr&gt;distance)</span><br><span class="line">&#123;</span><br><span class="line">yerr-=distance;</span><br><span class="line">uCol+=incy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-画矩形LCD-DrawRectangle"><a href="#4-画矩形LCD-DrawRectangle" class="headerlink" title="4.画矩形LCD_DrawRectangle()"></a>4.画矩形LCD_DrawRectangle()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_DrawRectangle</span><span class="params">(u16 x1, u16 y1, u16 x2, u16 y2,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line">LCD_DrawLine(x1,y1,x2,y1,color);</span><br><span class="line">LCD_DrawLine(x1,y1,x1,y2,color);</span><br><span class="line">LCD_DrawLine(x1,y2,x2,y2,color);</span><br><span class="line">LCD_DrawLine(x2,y1,x2,y2,color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-画圆Draw-Circle"><a href="#5-画圆Draw-Circle" class="headerlink" title="5.画圆Draw_Circle()"></a>5.画圆Draw_Circle()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Draw_Circle</span><span class="params">(u16 x0,u16 y0,u8 r,u16 color)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a=<span class="number">0</span>;b=r;  </span><br><span class="line"><span class="keyword">while</span>(a&lt;=b)</span><br><span class="line">&#123;</span><br><span class="line">LCD_DrawPoint(x0-b,y0-a,color);             <span class="comment">//3           </span></span><br><span class="line">LCD_DrawPoint(x0+b,y0-a,color);             <span class="comment">//0           </span></span><br><span class="line">LCD_DrawPoint(x0-a,y0+b,color);             <span class="comment">//1                </span></span><br><span class="line">LCD_DrawPoint(x0-a,y0-b,color);             <span class="comment">//2             </span></span><br><span class="line">LCD_DrawPoint(x0+b,y0+a,color);             <span class="comment">//4               </span></span><br><span class="line">LCD_DrawPoint(x0+a,y0-b,color);             <span class="comment">//5</span></span><br><span class="line">LCD_DrawPoint(x0+a,y0+b,color);             <span class="comment">//6 </span></span><br><span class="line">LCD_DrawPoint(x0-b,y0+a,color);             <span class="comment">//7</span></span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">if</span>((a*a+b*b)&gt;(r*r))<span class="comment">//判断要画的点是否过远</span></span><br><span class="line">&#123;</span><br><span class="line">b--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-写汉字LCD-ShowChinese"><a href="#6-写汉字LCD-ShowChinese" class="headerlink" title="6.写汉字LCD_ShowChinese()"></a>6.写汉字LCD_ShowChinese()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChinese</span><span class="params">(u16 x,u16 y,u8 *s,u16 fc,u16 bc,u8 sizey,u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*s!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sizey==<span class="number">12</span>) LCD_ShowChinese12x12(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">16</span>) LCD_ShowChinese16x16(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">24</span>) LCD_ShowChinese24x24(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">32</span>) LCD_ShowChinese32x32(x,y,s,fc,bc,sizey,mode);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">s+=<span class="number">2</span>;</span><br><span class="line">x+=sizey;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   入口数据：x,y显示坐标</p><p>​        *s 要显示的汉字串</p><p>​        fc 字的颜色</p><p>​        bc 字的背景色</p><p>​        sizey 字号 可选 16 24 32</p><p>​        mode:  0非叠加模式  1叠加模式</p><h2 id="7-显示单个字符LCD-ShowChar"><a href="#7-显示单个字符LCD-ShowChar" class="headerlink" title="7.显示单个字符LCD_ShowChar()"></a>7.显示单个字符LCD_ShowChar()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(u16 x,u16 y,u8 num,u16 fc,u16 bc,u8 sizey,u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 temp,sizex,t,m=<span class="number">0</span>;</span><br><span class="line">u16 i,TypefaceNum;<span class="comment">//一个字符所占字节大小</span></span><br><span class="line">u16 x0=x;</span><br><span class="line">sizex=sizey/<span class="number">2</span>;</span><br><span class="line">TypefaceNum=(sizex/<span class="number">8</span>+((sizex%<span class="number">8</span>)?<span class="number">1</span>:<span class="number">0</span>))*sizey;</span><br><span class="line">num=num-<span class="string">&#x27; &#x27;</span>;    <span class="comment">//得到偏移后的值</span></span><br><span class="line">LCD_Address_Set(x,y,x+sizex<span class="number">-1</span>,y+sizey<span class="number">-1</span>);  <span class="comment">//设置光标位置 </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;TypefaceNum;i++)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(sizey==<span class="number">12</span>)temp=ascii_1206[num][i];       <span class="comment">//调用6x12字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">16</span>)temp=ascii_1608[num][i]; <span class="comment">//调用8x16字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">24</span>)temp=ascii_2412[num][i]; <span class="comment">//调用12x24字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sizey==<span class="number">32</span>)temp=ascii_3216[num][i]; <span class="comment">//调用16x32字体</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!mode)<span class="comment">//非叠加模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;(<span class="number">0x01</span>&lt;&lt;t))LCD_WR_DATA(fc);</span><br><span class="line"><span class="keyword">else</span> LCD_WR_DATA(bc);</span><br><span class="line">m++;</span><br><span class="line"><span class="keyword">if</span>(m%sizex==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//叠加模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&amp;(<span class="number">0x01</span>&lt;&lt;t))LCD_DrawPoint(x,y,fc);<span class="comment">//画一个点</span></span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span>((x-x0)==sizex)</span><br><span class="line">&#123;</span><br><span class="line">x=x0;</span><br><span class="line">y++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-显示字符串LCD-ShowString"><a href="#8-显示字符串LCD-ShowString" class="headerlink" title="8.显示字符串LCD_ShowString()"></a>8.显示字符串LCD_ShowString()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(u16 x,u16 y,<span class="type">const</span> u8 *p,u16 fc,u16 bc,u8 sizey,u8 mode)</span></span><br><span class="line">&#123;         </span><br><span class="line"><span class="keyword">while</span>(*p!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;       </span><br><span class="line">LCD_ShowChar(x,y,*p,fc,bc,sizey,mode);</span><br><span class="line">x+=sizey/<span class="number">2</span>;</span><br><span class="line">p++;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-显示数字mypow"><a href="#9-显示数字mypow" class="headerlink" title="9.显示数字mypow()"></a>9.显示数字mypow()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">u32 <span class="title function_">mypow</span><span class="params">(u8 m,u8 n)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 result=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span>(n--)result*=m;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-显示整数变量LCD-ShowIntNum"><a href="#10-显示整数变量LCD-ShowIntNum" class="headerlink" title="10.显示整数变量LCD_ShowIntNum()"></a>10.显示整数变量LCD_ShowIntNum()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowIntNum</span><span class="params">(u16 x,u16 y,u16 num,u8 len,u16 fc,u16 bc,u8 sizey)</span></span><br><span class="line">&#123;         </span><br><span class="line">u8 t,temp;</span><br><span class="line">u8 enshow=<span class="number">0</span>;</span><br><span class="line">u8 sizex=sizey/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num/mypow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(enshow==<span class="number">0</span>&amp;&amp;t&lt;(len<span class="number">-1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowChar(x+t*sizex,y,<span class="string">&#x27; &#x27;</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> enshow=<span class="number">1</span>; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"> LCD_ShowChar(x+t*sizex,y,temp+<span class="number">48</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="11-显示两位小数变量LCD-ShowFloatNum1"><a href="#11-显示两位小数变量LCD-ShowFloatNum1" class="headerlink" title="11.显示两位小数变量LCD_ShowFloatNum1()"></a>11.显示两位小数变量LCD_ShowFloatNum1()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowFloatNum1</span><span class="params">(u16 x,u16 y,<span class="type">float</span> num,u8 len,u16 fc,u16 bc,u8 sizey)</span></span><br><span class="line">&#123;         </span><br><span class="line">u8 t,temp,sizex;</span><br><span class="line">u16 num1;</span><br><span class="line">sizex=sizey/<span class="number">2</span>;</span><br><span class="line">num1=num*<span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;len;t++)</span><br><span class="line">&#123;</span><br><span class="line">temp=(num1/mypow(<span class="number">10</span>,len-t<span class="number">-1</span>))%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(t==(len<span class="number">-2</span>))</span><br><span class="line">&#123;</span><br><span class="line">LCD_ShowChar(x+(len<span class="number">-2</span>)*sizex,y,<span class="string">&#x27;.&#x27;</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line">t++;</span><br><span class="line">len+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> LCD_ShowChar(x+t*sizex,y,temp+<span class="number">48</span>,fc,bc,sizey,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-显示图片LCD-ShowPicture"><a href="#12-显示图片LCD-ShowPicture" class="headerlink" title="12.显示图片LCD_ShowPicture()"></a>12.显示图片LCD_ShowPicture()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowPicture</span><span class="params">(u16 x,u16 y,u16 length,u16 width,<span class="type">const</span> u8 pic[])</span></span><br><span class="line">&#123;</span><br><span class="line">u16 i,j;</span><br><span class="line">u32 k=<span class="number">0</span>;</span><br><span class="line">LCD_Address_Set(x,y,x+length<span class="number">-1</span>,y+width<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;width;j++)</span><br><span class="line">&#123;</span><br><span class="line">LCD_WR_DATA8(pic[k*<span class="number">2</span>]);</span><br><span class="line">LCD_WR_DATA8(pic[k*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、SPI&quot;&gt;&lt;a href=&quot;#一、SPI&quot; class=&quot;headerlink&quot; title=&quot;一、SPI&quot;&gt;&lt;/a&gt;一、SPI&lt;/h1&gt;&lt;h2 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="通信协议" scheme="https://ydw-item.github.io.git/categories/STM32/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="外设" scheme="https://ydw-item.github.io.git/categories/STM32/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/%E5%A4%96%E8%AE%BE/"/>
    
    
    <category term="通讯协议" scheme="https://ydw-item.github.io.git/tags/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="SPI" scheme="https://ydw-item.github.io.git/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>OV-Watch-2-系统滴答定时器</title>
    <link href="https://ydw-item.github.io.git/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2025-02-26T05:48:30.000Z</published>
    <updated>2025-02-26T05:48:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SysTick-Type结构体"><a href="#SysTick-Type结构体" class="headerlink" title="SysTick_Type结构体"></a>SysTick_Type结构体</h1><p><img src="/2025/02/26/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/OV-Watch/2.OV-Watch_%E7%B3%BB%E7%BB%9F%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image-20250226144449751"></p><ol><li><p><strong><code>CTRL</code>（SysTick 控制与状态寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x000</code></li><li><strong>类型</strong>: <code>__IOM uint32_t</code>（读写寄存器）</li><li><strong>描述</strong>: 该寄存器用于控制和查看 SysTick 定时器的状态。通过设置不同的控制位，能够启动、停止定时器，配置中断等。</li></ul><p> <strong>常见控制位：</strong></p><ul><li><strong>ENABLE (位 0)</strong>: 启动或停止 SysTick 定时器。</li><li><strong>TICKINT (位 1)</strong>: 启用或禁用 SysTick 溢出中断。</li><li><strong>CLKSOURCE (位 2)</strong>: 选择 SysTick 定时器的时钟源（HCLK 或外部时钟）。</li><li><strong>COUNTFLAG (位 16)</strong>: 当计数器溢出时，设置为 1。</li></ul></li><li><p><strong><code>LOAD</code>（SysTick 重载值寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x004</code></li><li><strong>类型</strong>: <code>__IOM uint32_t</code>（读写寄存器）</li><li><strong>描述</strong>: 该寄存器用于设置定时器的重载值。SysTick 定时器每当计数器减至零时，会根据 <code>LOAD</code> 寄存器的值重新加载并开始新的计数。</li></ul><p> <strong>用途</strong>: 通过设置该寄存器的值来控制定时器的溢出周期。例如，如果你想让定时器每 1 毫秒溢出一次，你可以设置该寄存器的值为 <code>SystemCoreClock / 1000</code>。</p></li><li><p><strong><code>VAL</code>（SysTick 当前值寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x008</code></li><li><strong>类型</strong>: <code>__IOM uint32_t</code>（读写寄存器）</li><li><strong>描述</strong>: 该寄存器保存当前 SysTick 定时器的计数值。每当计数器从 <code>LOAD</code> 的值开始计数，直到它到达零时，<code>VAL</code> 会自动重载为 <code>LOAD</code> 的值，并且会触发中断（如果启用了中断）。</li></ul><p> <strong>用途</strong>: 读取此寄存器可以获取当前定时器的剩余计数值。它可用于计算经过的时间或检查定时器的状态。</p></li><li><p><strong><code>CALIB</code>（SysTick 校准寄存器）：</strong></p><ul><li><strong>偏移量</strong>: <code>0x00C</code></li><li><strong>类型</strong>: <code>__IM uint32_t</code>（只读寄存器）</li><li><strong>描述</strong>: 该寄存器提供关于系统时钟的校准信息，包括 SysTick 定时器的校准值。它通常用于获取定时器的精度和所使用的时钟的频率。</li></ul><p> <strong>用途</strong>: 这个寄存器通常用于调试和校准目的，帮助开发者了解系统时钟的频率和定时器的精度。</p></li></ol><h1 id="一、系统滴答定时器用于延时函数"><a href="#一、系统滴答定时器用于延时函数" class="headerlink" title="一、系统滴答定时器用于延时函数"></a>一、系统滴答定时器用于延时函数</h1><h2 id="1-1delay-init"><a href="#1-1delay-init" class="headerlink" title="1.1delay_init()"></a>1.1delay_init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);<span class="comment">//设置 SysTick 时钟源为 HCLK，即系统时钟。</span></span><br><span class="line">    HAL_SYSTICK_Config(SystemCoreClock / (<span class="number">1000U</span> / uwTickFreq));<span class="comment">//配置 SysTick 定时器的重载值，使其每 1 毫秒触发一次中断。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-delay-us"><a href="#1-2-delay-us" class="headerlink" title="1.2 delay_us()"></a>1.2 delay_us()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> OS_SUPPORT        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 nus)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 ticks;</span><br><span class="line">    u32 told,tnow,tcnt=<span class="number">0</span>;</span><br><span class="line">    u32 reload=SysTick-&gt;LOAD;<span class="comment">// 记录当前定时器的重载值寄存器的值    </span></span><br><span class="line">    ticks=nus*SYS_CLK;  </span><br><span class="line">    delay_osschedlock();</span><br><span class="line">    told=SysTick-&gt;VAL;        <span class="comment">// 记录当前定时器的计数值</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnow=SysTick-&gt;VAL;</span><br><span class="line">        <span class="keyword">if</span>(tnow!=told)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">if</span>(tnow&lt;told) tcnt+=told-tnow;  <span class="comment">// 递减计数器</span></span><br><span class="line">            <span class="keyword">else</span> tcnt+=reload-tnow+told;    <span class="comment">// 处理计数器溢出</span></span><br><span class="line">            told=tnow;</span><br><span class="line">            <span class="keyword">if</span>(tcnt&gt;=ticks) <span class="keyword">break</span>;  <span class="comment">// 达到预定的时钟周期数时退出</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    delay_osschedunlock();    </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(u32 nus)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 ticks;</span><br><span class="line">    u32 told,tnow,tcnt=<span class="number">0</span>;</span><br><span class="line">    u32 reload=SysTick-&gt;LOAD; <span class="comment">// 记录当前定时器的重载值寄存器的值     </span></span><br><span class="line">    ticks=nus*SYS_CLK;  <span class="comment">// 计算所需的时钟周期数，nus 为延迟的微秒数 #define SYS_CLK 100</span></span><br><span class="line">    told=SysTick-&gt;VAL;     <span class="comment">// 记录当前定时器的计数值, SysTick-&gt;VAL 是递减计数器</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnow=SysTick-&gt;VAL;</span><br><span class="line">        <span class="keyword">if</span>(tnow!=told)</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="keyword">if</span>(tnow&lt;told) tcnt+=told-tnow;   <span class="comment">// 递减计数器。如果当前值小于之前值，将两数之和累加进tcnt</span></span><br><span class="line">            <span class="keyword">else</span> tcnt+=reload-tnow+told;     <span class="comment">// 处理计数器溢出。如果当前值大于之前的值，将重载值</span></span><br><span class="line">            told=tnow; <span class="comment">// 将当前时间赋值给told</span></span><br><span class="line">                <span class="keyword">if</span>(tcnt&gt;=ticks) <span class="keyword">break</span>;   <span class="comment">// 达到预定的时钟周期数时退出</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3-delay-ms"><a href="#1-3-delay-ms" class="headerlink" title="1.3 delay_ms()"></a>1.3 delay_ms()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> OS_SUPPORT        </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 nms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(delay_osrunning&amp;&amp;delay_osintnesting==<span class="number">0</span>)    </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>(nms&gt;=fac_ms)</span><br><span class="line">&#123; </span><br><span class="line">   delay_ostimedly(nms/fac_ms);</span><br><span class="line">&#125;</span><br><span class="line">nms%=fac_ms; </span><br><span class="line">&#125;</span><br><span class="line">delay_us((u32)(nms*<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 nms)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nms;i++) delay_us(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SysTick-Type结构体&quot;&gt;&lt;a href=&quot;#SysTick-Type结构体&quot; class=&quot;headerlink&quot; title=&quot;SysTick_Type结构体&quot;&gt;&lt;/a&gt;SysTick_Type结构体&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2025/02</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="外设" scheme="https://ydw-item.github.io.git/categories/STM32/%E5%A4%96%E8%AE%BE/"/>
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/tags/STM32/"/>
    
    <category term="外设" scheme="https://ydw-item.github.io.git/tags/%E5%A4%96%E8%AE%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-9-二叉树</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-02-25T06:39:49.000Z</published>
    <updated>2025-02-25T06:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的创建与遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>             //定义二叉树结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createTree</span><span class="params">(TreeNode** T, <span class="type">char</span>* data, <span class="type">int</span>* index)</span>   <span class="comment">//初始化树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = data[*index];                                   </span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时为空节点</span></span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时不为空</span></span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T) -&gt; data = ch;</span><br><span class="line">        <span class="comment">// 创建左子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;lchild), data, index);</span><br><span class="line">        <span class="comment">// 创建右子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;rchild), data, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        preOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        preOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        inOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 中办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        inOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode* T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        postOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        postOrder(T-&gt;rchild);</span><br><span class="line">        <span class="comment">// 后办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* T;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    createTree(&amp;T, argv[<span class="number">1</span>], &amp;index);</span><br><span class="line">    preOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    inOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    postOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-8-暴力匹配</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span>       //定义字符串结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125; String;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String* <span class="title function_">initString</span><span class="params">()</span>                                <span class="comment">//初始化字符串 </span></span><br><span class="line">&#123;</span><br><span class="line">    String* s = (String*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(String));    <span class="comment">//为字符串开辟动态内存空间</span></span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>;                                 <span class="comment">//为</span></span><br><span class="line">    s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringAssign</span><span class="params">(String* s, <span class="type">char</span>* data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;data) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* temp = data;</span><br><span class="line">    <span class="keyword">while</span> (*temp) </span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        temp = data;</span><br><span class="line">        s-&gt;len = len;</span><br><span class="line">        s-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++, temp++) </span><br><span class="line">        &#123;</span><br><span class="line">            s-&gt;data[i] = *temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printString</span><span class="params">(String* s)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s-&gt;len; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(i == <span class="number">0</span> ? <span class="string">&quot;%c &quot;</span> : <span class="string">&quot;-&gt; %c &quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceMatch</span><span class="params">(String* master, String* sub)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp; j &lt; sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;data[i] == sub-&gt;data[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match success.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match fail.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    String* s = initString();</span><br><span class="line">    String* s1 = initString();</span><br><span class="line">    stringAssign(s, argv[<span class="number">1</span>]);</span><br><span class="line">    stringAssign(s1, argv[<span class="number">2</span>]);</span><br><span class="line">    printString(s);</span><br><span class="line">    printString(s1);</span><br><span class="line">    forceMatch(s, s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-7-循环队列</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</id>
    <published>2025-02-25T06:37:49.000Z</published>
    <updated>2025-02-25T06:37:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要知道队列当前有多少个元素</span></span><br><span class="line">    <span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">    <span class="type">int</span> index = Q-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, Q-&gt;data[index]);</span><br><span class="line">        index = (index + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(Queue* Q, <span class="type">int</span> data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = data;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data = Q-&gt;data[Q-&gt;front];</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-6-栈</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</id>
    <published>2025-02-25T06:36:49.000Z</published>
    <updated>2025-02-25T06:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义栈结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">initStack</span><span class="params">()</span>                               <span class="comment">//初始化栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));     <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L-&gt;data = <span class="number">0</span>;                                <span class="comment">//data初始化</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                             <span class="comment">//头结点next指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> L;                                   <span class="comment">//返回头结点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Node *L, <span class="type">int</span> data)</span>                    <span class="comment">//入栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                          <span class="comment">//为data赋值</span></span><br><span class="line">    node-&gt;next = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    L-&gt;next = node;                             <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    L-&gt;data++;                                  <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Node *L)</span>                            <span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span>)                       <span class="comment">//判断栈是否为空栈 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//是空栈则返回 1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Node *node = L-&gt;next;               <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        <span class="type">int</span> data = node-&gt;data;              <span class="comment">//将头结点的下一结点的data 赋值给 data</span></span><br><span class="line">        L-&gt;next = node-&gt;next;               <span class="comment">//将头结点的下一结点的next 赋值给头结点的next</span></span><br><span class="line">        <span class="built_in">free</span>(node);                         <span class="comment">//释放头结点的下一结点的动态内存空间</span></span><br><span class="line">        L-&gt;data--;                          <span class="comment">//将头结点的data--</span></span><br><span class="line">        <span class="keyword">return</span> data;                        <span class="comment">//返回取出的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node *L)</span>                        <span class="comment">//判断是否为空栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span> || L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的data == 0 或者 头结点的next的值为NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">//返回 1，代表此栈为空栈</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//返回 0，代表此栈不是空栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Node *<span class="built_in">stack</span>)</span>            <span class="comment">//打印栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = <span class="built_in">stack</span>-&gt;next;           <span class="comment">//将头结点的next的值 赋值给node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                        <span class="comment">//判断node是否为NULL</span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);   <span class="comment">//打印node的data</span></span><br><span class="line">        node = node-&gt;next;              <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node *<span class="built_in">stack</span> = initStack();          <span class="comment">//创建栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">1</span>);                     <span class="comment">//1 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">2</span>);                     <span class="comment">//2 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">3</span>);                     <span class="comment">//3 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">4</span>);                     <span class="comment">//4 入栈</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pop = %d\n&quot;</span>, pop(<span class="built_in">stack</span>));   <span class="comment">//出战</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-5-队列</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</id>
    <published>2025-02-25T06:35:49.000Z</published>
    <updated>2025-02-25T06:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="comment">//往头结点前面入队 ，从头结点后面出队</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义队列的结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initQueue</span><span class="params">()</span>                               <span class="comment">//初始化队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为头结点分配动态内春空间</span></span><br><span class="line">    Q-&gt;data = <span class="number">0</span>;                </span><br><span class="line">    Q-&gt;pre = Q;                                 <span class="comment">//初始化pre</span></span><br><span class="line">    Q-&gt;next = Q;                                <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Node* Q, <span class="type">int</span> data)</span>                         <span class="comment">//入队       </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));           <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                                  <span class="comment">//为新结点赋值</span></span><br><span class="line">    node-&gt;next = Q;                                     <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    node-&gt;pre = Q-&gt;pre;                                 <span class="comment">//将头结点的pre的值 赋值给 新结点的pre</span></span><br><span class="line">    Q-&gt;pre-&gt;next = node;                                <span class="comment">//将新结点的地址 赋值给 头结点的pre指向的结点的next</span></span><br><span class="line">    Q-&gt;pre = node;                                      <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    Q-&gt;data++;                                          <span class="comment">//头结点的data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node* Q)</span>                                    <span class="comment">//判队列是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;data == <span class="number">0</span> || Q-&gt;next == Q)                   <span class="comment">//如果头结点的data == 0，或者头结点的next == 自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                       <span class="comment">//返回 1，代表队列为空</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0，代表队列不为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Node* Q)</span>                                    <span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q))                                     <span class="comment">//判断队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//为空则返回 0</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;                                          </span><br><span class="line">        Node* node = Q-&gt;next;                           <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next;                        <span class="comment">//将头结点的next指向的结点的next的值 赋值给 头结点的next</span></span><br><span class="line">        Q-&gt;next-&gt;pre = Q;                               <span class="comment">//将头结点的地址 赋值给 头结点的next指向的结点的pre</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;data;                              <span class="comment">//返回出队结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Node* Q)</span>                                <span class="comment">//打印队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = Q -&gt; next;                             <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != Q)                                   <span class="comment">//判断node 是否是头结点的地址       </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);                 <span class="comment">//打印node的data</span></span><br><span class="line">        node = node -&gt; next;                            <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = initQueue();                      <span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(Q, <span class="number">1</span>);                              <span class="comment">//1 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">2</span>);                              <span class="comment">//2 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">3</span>);                              <span class="comment">//3 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">4</span>);                              <span class="comment">//4 入队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-4-双循环链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:34:49.000Z</published>
    <updated>2025-02-25T06:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化头结点，创建链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化头结点的data</span></span><br><span class="line">    L -&gt; pre = L;                           <span class="comment">//初始化头结点的pre，指向自己</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化头结点的next，指向next</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//为新结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    node -&gt; pre = L;                            <span class="comment">//将头头结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    L -&gt; next -&gt; pre = node;                    <span class="comment">//将新结点的地址 赋值给 原来头结点的下一个结点的pre</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 头结点的next </span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L)                     <span class="comment">//判断node是否是最后一个结点</span></span><br><span class="line">    &#123;                                           <span class="comment">//如果不是</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将原来最后一个结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    n -&gt; next = L;                              <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; pre = n;                               <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                       <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                         <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != L)                               <span class="comment">//判断node 是否是 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)                   <span class="comment">//判断node是否是目标结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next的值 赋值给 目标结点的pre指向的结点的next</span></span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;      <span class="comment">//将目标结点的pre的值  赋值给 目标结点的next指向的结点的pre</span></span><br><span class="line">            <span class="built_in">free</span>(node);                             <span class="comment">//释放目标结点的动态内存空间</span></span><br><span class="line">            L -&gt; data --;                           <span class="comment">//头结点的data--</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;                               <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                        <span class="comment">//如果不是目标结点，更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否是 目标结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);           <span class="comment">//打印node的值</span></span><br><span class="line">        node = node-&gt;next;                      <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">///打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();           <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);               <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);               <span class="comment">//头插 2</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);               <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);               <span class="comment">//头插 5</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);               <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);               <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">7</span>);                   <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-3-双链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:32:49.000Z</published>
    <updated>2025-02-25T06:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>             //创建结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;   Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//创建链表头结点，分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化链表结点数</span></span><br><span class="line">    L -&gt; pre = <span class="literal">NULL</span>;                        <span class="comment">//初始化pre</span></span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;                       <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> L;                               <span class="comment">//返沪Node类型的指针L</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>           <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//开辟结点动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                     <span class="comment">//结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                <span class="comment">//将头结点next指向的结点地址 赋值给 新的结点</span></span><br><span class="line">    node -&gt; pre = L;                         <span class="comment">//新结点的pre指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L -&gt; next)                           <span class="comment">//判断头结点的next是否是NULL</span></span><br><span class="line">    &#123;                                        <span class="comment">//如果不为空</span></span><br><span class="line">        L -&gt; next -&gt; pre = node;             <span class="comment">//将新结点的地址 赋值给 头结点下一个结点的 pre</span></span><br><span class="line">        L -&gt; next = node;                    <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                     <span class="comment">//当链表中只有头结点时</span></span><br><span class="line">    &#123; </span><br><span class="line">        L -&gt; next = node;                       <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    <span class="keyword">while</span> (node -&gt; next)                        <span class="comment">//遍历到链表最后一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;                                           <span class="comment">//node此时为尾结点</span></span><br><span class="line">    n -&gt; next = node -&gt; next;                   <span class="comment">//将尾结点next指向的地址 赋值给 新结点的next     </span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将尾结点的next指向n   </span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将新结点的pre指向原来的尾结点</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;                                  </span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点next指向的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//如果node不为空结点</span></span><br><span class="line">    &#123;                             </span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)               <span class="comment">//如果node是目标结点 </span></span><br><span class="line">        &#123;     </span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next; <span class="comment">//将node的next 赋值给 node上一个结点的next</span></span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next)                   <span class="comment">//如果node不是尾结点</span></span><br><span class="line">            &#123;                                       </span><br><span class="line">                node -&gt; next -&gt; pre = node -&gt; pre;  <span class="comment">//将node的pre 赋值给 node下一结点的pre</span></span><br><span class="line">            &#125;</span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点数据 --</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放node的空间</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//找到目标值，删除成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//node更新为下一结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到值，删除失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点指向的结点 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//当node不为空时， </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);         <span class="comment">//打印node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node为下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//当node为空结点时打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();                       <span class="comment">//创建链表，初始化头结点</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);                           <span class="comment">//头插1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);                           <span class="comment">//头插2</span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);                           <span class="comment">//头插3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);                           <span class="comment">//头插4</span></span><br><span class="line">    tailInsert(L, <span class="number">5</span>);                           <span class="comment">//尾插5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);                           <span class="comment">//尾插6</span></span><br><span class="line">    printList(L);                               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">6</span>);                               <span class="comment">//删除6</span></span><br><span class="line">    printList(L);                               <span class="comment">//删除链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-2-单循环链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:31:49.000Z</published>
    <updated>2025-02-25T06:31:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义结点结构体</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>      <span class="comment">//结构体指针，指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化结构体，创建头结点 </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//开辟口结点空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化data数据</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化指针，指向自己</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//开辟结点空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将数据赋值给data</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的的next 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//新结点的地址 赋值给 头结点的node</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* n = L;                                <span class="comment">//将头结点 赋值给 n</span></span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将data 赋值给 新结点的data</span></span><br><span class="line">    <span class="keyword">while</span>(n -&gt; next != L)                       <span class="comment">//使用遍历，判断n的next 是否 指向 头结点，找到最后一个结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        n = n -&gt; next;                          <span class="comment">//不是则更新n</span></span><br><span class="line">    &#125;</span><br><span class="line">    node -&gt; next = L;                           <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    n -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* preNode = L;                          <span class="comment">//将头结点的地址 赋值给 preNode</span></span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next存储的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node的 地址 是否等于 头结点的地址</span></span><br><span class="line">    &#123;               </span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)                <span class="comment">//判断node的data 是否等于 目标值</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next值 赋值给 前一个结点的next</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放目标结点 动态内存空间</span></span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点的数据--</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;                         <span class="comment">//更新preNode</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到目标结点，返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否等于 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node -&gt; data);           <span class="comment">//打应node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//单循环链表，最后一个结点的next应指向头结点，此处代码错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();       <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);           <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);           <span class="comment">//头插 2 </span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);           <span class="comment">//头插 3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);           <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);           <span class="comment">//头插 5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);           <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);           <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">4</span>);               <span class="comment">//删除 4</span></span><br><span class="line">    delete(L, <span class="number">7</span>);               <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
