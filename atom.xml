<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The personal blog of 洒水水</title>
  
  <subtitle>姚道文</subtitle>
  <link href="https://ydw-item.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://ydw-item.github.io.git/"/>
  <updated>2025-02-15T16:20:05.000Z</updated>
  <id>https://ydw-item.github.io.git/</id>
  
  <author>
    <name>洒水水</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RT-Thread-1-ADC</title>
    <link href="https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/"/>
    <id>https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/</id>
    <published>2025-02-15T16:20:05.000Z</published>
    <updated>2025-02-15T16:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、drv-adc-c分析"><a href="#一、drv-adc-c分析" class="headerlink" title="一、drv_adc.c分析"></a>一、drv_adc.c分析</h1><h2 id="1-调用stm32-adc-init"><a href="#1-调用stm32-adc-init" class="headerlink" title="1.调用stm32_adc_init()"></a>1.调用stm32_adc_init()</h2><p>​进行板级初始化</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/1.png" alt="image-20250213213546245"></p><h2 id="2-定义adc-config数组"><a href="#2-定义adc-config数组" class="headerlink" title="2.定义adc_config数组"></a>2.定义adc_config数组</h2><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/2.png" alt="image-20250213215103492"></p><p>数组中有几个值通过board.h中的宏定义来确定，同时数组中的最后一个元素后面在某些标准下是被允许加逗号的</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/3.png" alt="image-20250213215514039"></p><p>如果打开ADC1和ADC2，那么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc_config[] =&#123;ADC1_CONFIG,ADC3_CONFIG&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-ADC1-CONFIG是什么"><a href="#3-ADC1-CONFIG是什么" class="headerlink" title="3.ADC1_CONFIG是什么"></a>3.ADC1_CONFIG是什么</h2><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/4.png" alt="image-20250213215847418"></p><h2 id="4-ADC-HandleTypeDef是什么类型"><a href="#4-ADC-HandleTypeDef是什么类型" class="headerlink" title="4.ADC_HandleTypeDef是什么类型"></a>4.ADC_HandleTypeDef是什么类型</h2><p>是 <strong>STM32 HAL（硬件抽象层）库</strong> 中的一个结构体，用于表示 <strong>ADC（模拟到数字转换器）</strong> 外设的配置和状态</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/5.png" alt="image-20250213221307498"></p><p><strong><code>Instance</code></strong></p><ul><li>类型：<code>ADC_TypeDef *</code></li><li><strong>描述</strong>：指向 ADC 模块寄存器的指针。不同的 STM32 微控制器有多个 ADC 模块（如 <code>ADC1</code>, <code>ADC2</code>, <code>ADC3</code> 等），<code>Instance</code> 用于标识当前操作的是哪个 ADC 模块。</li></ul><p><strong><code>Init</code></strong></p><ul><li><p>类型：<code>ADC_InitTypeDef</code></p></li><li><p>描述</p><p>  ：包含 ADC 初始化配置的结构体。它包含了多个配置选项，如 ADC 时钟、分辨率、数据对齐方式等。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef</span><br></pre></td></tr></table></figure><p>   是一个结构体，通常包括以下字段：</p><ul><li><code>ClockPrescaler</code>：ADC 时钟的预分频器。</li><li><code>Resolution</code>：ADC 分辨率（如 12 位、10 位、8 位）。</li><li><code>DataAlign</code>：数据对齐方式（如左对齐或右对齐）。</li><li><code>ScanConvMode</code>：是否启用扫描模式（多个通道转换）。</li><li><code>ContinuousConvMode</code>：是否启用连续转换模式。</li><li><code>ExternalTrigConv</code>：外部触发类型（如软件触发、定时器触发等）。</li></ul></li></ul><p><strong><code>DMA_Handle</code></strong></p><ul><li>类型：<code>DMA_HandleTypeDef *</code></li><li><strong>描述</strong>：指向 DMA（直接存储器访问）句柄的指针。如果使用 DMA 进行 ADC 数据传输，这个字段指向一个 <code>DMA_HandleTypeDef</code> 结构，用于管理 DMA 的配置。</li></ul><p><strong><code>State</code></strong></p><ul><li>类型：<code>__IO uint32_t *</code></li><li><strong>描述</strong>：指向 ADC 状态的指针。这个字段通常用于存储 ADC 的当前状态，如转换进行中、转换完成等状态信息。</li></ul><p><strong><code>ErrorCode</code></strong></p><ul><li>类型：<code>__IO uint32_t</code></li><li><strong>描述</strong>：存储 ADC 操作过程中发生的错误代码。这可以帮助调试和排查问题，比如发生了什么错误，是否由于配置问题导致操作失败等。</li></ul><h2 id="5-启用了几个ADC就定义几个stm32-adc-obj-元素"><a href="#5-启用了几个ADC就定义几个stm32-adc-obj-元素" class="headerlink" title="5.启用了几个ADC就定义几个stm32_adc_obj[]元素"></a>5.启用了几个ADC就定义几个stm32_adc_obj[]元素</h2><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/8.png" alt="image-20250213223809186"></p><h2 id="6-ADC-Handler和adc-config是一个类型的变量"><a href="#6-ADC-Handler和adc-config是一个类型的变量" class="headerlink" title="6. ADC_Handler和adc_config是一个类型的变量"></a>6. ADC_Handler和adc_config是一个类型的变量</h2><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/7.png" alt="image-20250213224057191"></p><h2 id="5-for循环"><a href="#5-for循环" class="headerlink" title="5. for循环"></a>5. for循环</h2><p>用sizeof判断使用了几个ADC，使用了几个ADC就循环几此</p><p>1.把adc_config赋值给ADC_Hander(因为第6小点)</p><p>2.通过stm32f407xx.h判断是否有这个外设</p><p>3.Instance中存放的名字是ADCx，是ADC几就把几赋值给name_buf[3]</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/6.png" alt="image-20250213222200867"></p><h2 id="7-HAL-ADC-Init"><a href="#7-HAL-ADC-Init" class="headerlink" title="7.HAL_ADC_Init()"></a>7.HAL_ADC_Init()</h2><p>1.传入ADC_HandleTypeDef类型的值，初始化ADC</p><p>2.如果返回错误，答应init failed</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/9.png" alt="99e47c9c-0550-49aa-992d-62ec87fad64a"></p><h2 id="8-rt-hw-adc-register"><a href="#8-rt-hw-adc-register" class="headerlink" title="8.rt_hw_adc_register()"></a>8.rt_hw_adc_register()</h2><p>用于注册硬件 ADC 的函数，它将 ADC 驱动和硬件抽象层（HAL）关联起来,使得 RT-Thread 可以识别和使用指定的 ADC 外设</p><ul><li><strong>初始化硬件 ADC 驱动</strong>：这个函数将硬件 ADC 外设与 RT-Thread 的设备模型进行注册，使得 RT-Thread 可以管理和访问硬件 ADC。</li><li><strong>设备注册</strong>：它会在 RT-Thread 的设备模型中创建一个 ADC 设备对象，从而让系统能够通过统一的接口（例如 <code>read()</code>、<code>write()</code> 等）来操作硬件。</li><li><strong>设备抽象层支持</strong>：通过设备抽象层，用户可以通过设备操作接口（如打开设备、关闭设备、读取数据等）与硬件 ADC 进行交互。</li></ul><h2 id="9-rt-adc-device-是用于表示一个-ADC-设备-的结构体"><a href="#9-rt-adc-device-是用于表示一个-ADC-设备-的结构体" class="headerlink" title="9.rt_adc_device 是用于表示一个 ADC 设备 的结构体"></a>9.<code>rt_adc_device</code> 是用于表示一个 <strong>ADC 设备</strong> 的结构体</h2><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/10.png" alt="image-20250213230813789"></p><h2 id="10-struct-rt-adc-ops"><a href="#10-struct-rt-adc-ops" class="headerlink" title="10.struct rt_adc_ops"></a>10.struct rt_adc_ops</h2><p> RT-Thread 中与 <strong>ADC（模拟到数字转换器）</strong> 设备交互的操作函数结构体，它包含了一组函数指针</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/image-20250213231324141.png" alt="image-20250213231324141"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/11.png" alt="image-20250213231110666"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、drv-adc-c分析&quot;&gt;&lt;a href=&quot;#一、drv-adc-c分析&quot; class=&quot;headerlink&quot; title=&quot;一、drv_adc.c分析&quot;&gt;&lt;/a&gt;一、drv_adc.c分析&lt;/h1&gt;&lt;h2 id=&quot;1-调用stm32-adc-init&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-0-启动流程</title>
    <link href="https://ydw-item.github.io.git/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://ydw-item.github.io.git/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2025-02-15T15:57:05.000Z</published>
    <updated>2024-02-15T15:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、startup-stm32f407xx-S"><a href="#一、startup-stm32f407xx-S" class="headerlink" title="一、startup_stm32f407xx.S"></a>一、startup_stm32f407xx.S</h1><p>系统进入汇编文件</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image-20250215165008148"></p><p><strong>RT-Thread使用的是GCC</strong></p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.jpg" alt="8f1db497d50d7a28f2bcd3922cadab1"></p><h1 id="二、不同编译器的启动函数"><a href="#二、不同编译器的启动函数" class="headerlink" title="二、不同编译器的启动函数"></a>二、不同编译器的启动函数</h1><p>调用stm32f407_demo3\rt-thread\src\components.c中的$Sub$$main()</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image-20250215223923007"></p><h1 id="三、调用rtthread-startup-void"><a href="#三、调用rtthread-startup-void" class="headerlink" title="三、调用rtthread_startup(void)"></a>三、调用rtthread_startup(void)</h1><p>在stm32f407_demo3\rt-thread\src\components.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rtthread_startup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 禁用了所有中断 */</span></span><br><span class="line">    rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* 执行板级支持包（BSP）初始化 </span></span><br><span class="line"><span class="comment">       包括配置硬件、系统时钟、外设初始化等 */</span></span><br><span class="line">    rt_hw_board_init();</span><br><span class="line"> <span class="comment">/* 打印 RT-Thread 操作系统的版本信息 */</span></span><br><span class="line">    rt_show_version();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的定时器子系统 */</span></span><br><span class="line">    rt_system_timer_init();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的调度器 */</span></span><br><span class="line">    rt_system_scheduler_init();</span><br><span class="line"><span class="comment">/* 如果启用了信号系统 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SIGNALS</span></span><br><span class="line">    <span class="comment">/* 初始化信号系统 */</span></span><br><span class="line">    rt_system_signal_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 创建应用任务、初始化外设 */</span></span><br><span class="line">    rt_application_init();</span><br><span class="line">    <span class="comment">/* 初始化定时器线程 */</span></span><br><span class="line">    rt_system_timer_thread_init();</span><br><span class="line">    <span class="comment">/* 初始化空闲线程 */</span></span><br><span class="line">    rt_thread_idle_init();</span><br><span class="line"><span class="comment">/* 如果启用了 SMP（对称多处理） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SMP</span></span><br><span class="line">    <span class="comment">/* 进行多核处理器的初始化和同步 */</span></span><br><span class="line">    rt_hw_spin_lock(&amp;_cpus_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*RT_USING_SMP*/</span></span></span><br><span class="line">    <span class="comment">/* 开始任务调度 */</span></span><br><span class="line">    rt_system_scheduler_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* never reach here */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1rt-hw-board-init和rt-application-init的-外设初始化的不同"><a href="#3-1rt-hw-board-init和rt-application-init的-外设初始化的不同" class="headerlink" title="3.1rt_hw_board_init和rt_application_init的 外设初始化的不同"></a>3.1rt_hw_board_init和rt_application_init的 外设初始化的不同</h2><ul><li><strong>rt_hw_board_init</strong></li></ul><p><strong>硬件初始化</strong>：<em><strong>初始化硬件资源</strong></em>，如 GPIO、串口、SPI、I2C、PWM、ADC、定时器等。</p><p><strong>系统时钟配置</strong>：配置系统时钟、外设时钟以及 PLL（锁相环）等，确保系统和外设运行在合适的频率下。</p><p><strong>内存初始化</strong>：配置堆栈、堆内存和静态内存区域，确保系统资源可用。</p><p><strong>中断配置</strong>：初始化中断控制器，并为特定外设启用中断。</p><p><strong>启动引导程序</strong>：执行系统初始化，如配置时钟源、初始化硬件外设等，通常会包括一个初始化阶段的启动代码。</p><p><strong>设备驱动注册</strong>：为基础硬件外设（如 UART、SPI、I2C 等）注册驱动，使操作系统能够访问这些外设。</p><ul><li><strong>rt_application_init</strong></li></ul><p><strong>创建应用任务</strong>：创建系统中的应用任务，例如数据采集任务、处理任务等。</p><p><strong>初始化外设</strong>：在 <strong>应用层</strong> 对外设进行更高层次的初始化。例如，在硬件初始化后，可能会初始化一些<em><strong>外设的具体参数</strong></em>，如设置 ADC 采样周期、配置传感器等。</p><p><strong>启动应用程序逻辑</strong>：进行传感器数据采集、通信协议的初始化、数据处理等应用相关的工作。</p><p><strong>任务调度和资源管理</strong>：创建并调度多个任务，管理应用程序层的资源。</p><h2 id="3-2rt-hw-board-init"><a href="#3-2rt-hw-board-init" class="headerlink" title="3.2rt_hw_board_init()"></a>3.2rt_hw_board_init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RT_WEAK <span class="type">void</span> <span class="title function_">rt_hw_board_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Heap initialization */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_HEAP)</span></span><br><span class="line">    rt_system_heap_init((<span class="type">void</span> *) HEAP_BEGIN, (<span class="type">void</span> *) HEAP_END);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 时钟源初始化，配置 MCU 的时钟系统，设置系统时钟、外设时钟 */</span></span><br><span class="line">    hw_board_init(BSP_CLOCK_SOURCE, BSP_CLOCK_SOURCE_FREQ_MHZ, BSP_CLOCK_SYSTEM_FREQ_MHZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置控制台设备。通常，这意味着将输出通过串口或其他通信接口进行调试输出。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_DEVICE) &amp;&amp; defined(RT_USING_CONSOLE)</span></span><br><span class="line">    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 始化板级硬件组件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_COMPONENTS_INIT</span></span><br><span class="line">    rt_components_board_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1hw-board-init"><a href="#3-2-1hw-board-init" class="headerlink" title="3.2.1hw_board_init()"></a>3.2.1hw_board_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">oid <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rt_hw_systick_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clk_init</span><span class="params">(<span class="type">char</span> *clk_source, <span class="type">int</span> source_freq, <span class="type">int</span> target_freq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableICache</span></span><br><span class="line">    <span class="comment">/* 开启指令缓存，用于加速程序的指令获取。*/</span></span><br><span class="line">    SCB_EnableICache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableDCache</span></span><br><span class="line">    <span class="comment">/* 开启数据缓存，用于加速数据存取。*/</span></span><br><span class="line">    SCB_EnableDCache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 HAL 库需要的硬件资源，例如时钟配置、外设初始化等 */</span></span><br><span class="line">    HAL_Init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器清零，开启全局中断 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 初始化系统时钟 */</span></span><br><span class="line">    clk_init(clock_src, clock_src_freq, clock_target_freq);</span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器设置为 1，禁止全局中断。确保时钟配置的过程中不会受到中断的干扰 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 初始化 SysTick 定时器 */</span></span><br><span class="line">    rt_hw_systick_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化与硬件引脚相关的驱动（如 GPIO 控制）。 </span></span><br><span class="line"><span class="comment">       初始化所有的通用输入输出引脚，设置引脚模式、方向、输出类型等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_PIN</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_pin_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_pin_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 USART 驱动 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SERIAL</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_usart_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image-20250215174007724"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 计算定义了几个串口，通过串口配置结构体的总大小/每个结构体的大小来计算*/</span></span><br><span class="line">    <span class="type">rt_size_t</span> obj_num = <span class="keyword">sizeof</span>(uart_obj) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stm32_uart);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_configure</span> <span class="title">config</span> =</span> RT_SERIAL_CONFIG_DEFAULT;</span><br><span class="line">    <span class="type">rt_err_t</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stm32_uart_get_dma_config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_obj[i].config = &amp;uart_config[i];</span><br><span class="line">        uart_obj[i].serial.ops    = &amp;stm32_uart_ops;</span><br><span class="line">        uart_obj[i].serial.config = config;</span><br><span class="line">        <span class="comment">/* 用于注册串口设备，将串口设备与操作系统的设备管理系统连接起来，使得串口设备能够被操作系统识别和管理</span></span><br><span class="line"><span class="comment">        register ----  注册*/</span></span><br><span class="line">        result = rt_hw_serial_register(&amp;uart_obj[i].serial, uart_obj[i].config-&gt;name,</span><br><span class="line">                                       RT_DEVICE_FLAG_RDWR</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_RX</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_TX</span><br><span class="line">                                       | uart_obj[i].uart_dma_flag</span><br><span class="line">                                       , <span class="literal">NULL</span>);</span><br><span class="line">        RT_ASSERT(result == RT_EOK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image-20250215174346247"></p><h2 id="3-3-rt-show-version-void"><a href="#3-3-rt-show-version-void" class="headerlink" title="3.3 rt_show_version(void)"></a>3.3 rt_show_version(void)</h2><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image-20250215224815579"></p><h2 id="3-4-rt-application-init"><a href="#3-4-rt-application-init" class="headerlink" title="3.4 rt_application_init()"></a>3.4 rt_application_init()</h2><p>创建main()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image-20250215230134023"></p><h2 id="3-5-rt-system-timer-thread-init"><a href="#3-5-rt-system-timer-thread-init" class="headerlink" title="3.5 rt_system_timer_thread_init()"></a>3.5 rt_system_timer_thread_init()</h2><p>创建rt_thread_timer_entry()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image-20250215230248093"></p><h3 id="3-5-1rt-thread-timer-entry"><a href="#3-5-1rt-thread-timer-entry" class="headerlink" title="3.5.1rt_thread_timer_entry()"></a>3.5.1rt_thread_timer_entry()</h3><p>专门用于处理软件定时器的线程函数,定期检查并触发到期的定时器回调。当没有定时器超时时，当前线程会被挂起，直到下一个定时器到期为止。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image-20250215231635484"></p><ul><li>它首先通过 <code>rt_timer_list_next_timeout</code> 获取下一个定时器的超时时间。</li><li>如果没有定时器超时，它会挂起当前线程，直到有定时器超时。</li><li>如果有定时器将要超时，函数会计算剩余时间，并使线程在该时间段内休眠，直到定时器超时。</li><li>每次循环结束时，<code>rt_soft_timer_check()</code> 会检查所有的软件定时器，触发到期的定时器回调。</li></ul><h2 id="3-6-rt-thread-idle-init"><a href="#3-6-rt-thread-idle-init" class="headerlink" title="3.6 rt_thread_idle_init()"></a>3.6 rt_thread_idle_init()</h2><p>初始化 <strong>空闲线程</strong>,是操作系统中的一个特殊线程，它在所有其他任务都没有运行时执行。通常，空闲线程用来降低系统功耗，或者执行一些后台清理任务。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image-20250215232409967"></p><h1 id="四、宏定义函数执行顺序"><a href="#四、宏定义函数执行顺序" class="headerlink" title="四、宏定义函数执行顺序"></a>四、宏定义函数执行顺序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 负责硬件平台的初始化，如时钟配置、外设初始化等。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, <span class="string">&quot;1&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化一些软件模块，可能包括设置一些内核参数、初始化操作系统调度器等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_PREV_EXPORT(fn)            INIT_EXPORT(fn, <span class="string">&quot;2&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化系统中的外设，如串口、GPIO、I2C、SPI 等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, <span class="string">&quot;3&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 包括文件系统（如 FatFS）、网络协议栈（如 lwIP）和其他应用组件的初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, <span class="string">&quot;4&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 涉及外部设备的挂载、环境配置、磁盘挂载等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_ENV_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;5&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 与应用程序级别的初始化相关，如图形界面（rtgui）、应用任务初始化等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;6&quot;</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、startup-stm32f407xx-S&quot;&gt;&lt;a href=&quot;#一、startup-stm32f407xx-S&quot; class=&quot;headerlink&quot; title=&quot;一、startup_stm32f407xx.S&quot;&gt;&lt;/a&gt;一、startup_stm32f4</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯嵌入式模块使用指北2</title>
    <link href="https://ydw-item.github.io.git/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>https://ydw-item.github.io.git/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/</id>
    <published>2024-12-01T04:34:05.000Z</published>
    <updated>2024-12-01T04:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><center>本文不涉及原理，只涉及模块的使用<center>南京工业大学浦江学院 22级自动化 姚道文<p>[TOC]</p><h1 id="零、项目新建和LCD底层移植"><a href="#零、项目新建和LCD底层移植" class="headerlink" title="零、项目新建和LCD底层移植"></a>零、项目新建和LCD底层移植</h1><p><strong>链接： <a href="https://www.bilibili.com/video/BV18F4m1K7Ji/?share_source=copy_web&vd_source=63b2bec79fe7e44c34a744e91284ebb2">项目新建和LCD底层移植</a></strong></p><h1 id="一、Systick系统滴答定时器"><a href="#一、Systick系统滴答定时器" class="headerlink" title="一、Systick系统滴答定时器"></a>一、Systick系统滴答定时器</h1><blockquote><p>24位向下递减计数器，0~16,777,216</p><p>CubeMAX会自动将Systick配置成1ms中断的定时器，并将变量uwTick每1ms增加1</p><p>精确延时：HAL_Delay()函数,但会阻塞程序，在while中应控制在10s以内</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序每1ms进入1次该函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_IncTick();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、KEY模块"><a href="#二、KEY模块" class="headerlink" title="二、KEY模块"></a><strong>二、KEY模块</strong></h1><h2 id="1-KEY模块CubeMX设置"><a href="#1-KEY模块CubeMX设置" class="headerlink" title="1.KEY模块CubeMX设置"></a>1.KEY模块CubeMX设置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/1.png" alt="img"></p><h2 id="2-KEY模块代码"><a href="#2-KEY模块代码" class="headerlink" title="2.KEY模块代码"></a>2.KEY模块代码</h2><h3 id="1-main-c文件"><a href="#1-main-c文件" class="headerlink" title="1.main.c文件"></a>1.main.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&quot;key.h&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-key-c文件"><a href="#2-key-c文件" class="headerlink" title="2.key.c文件"></a>2.key.c文件</h3><p><strong>宏定义的括号不可省略，想想#define KB1  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)和</strong></p><p><strong>KB1 &#x3D; HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)；有什么区别！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="comment">//没有按下是高电平，按下时低电平</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB1  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)    <span class="comment">//读取KB1电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB2  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1)    <span class="comment">//读取KB2电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB3  HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2)    <span class="comment">//读取KB3电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KB4  HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)    <span class="comment">//读取KB4电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPORT  KB1 | (KB2&lt;&lt;1) | (KB3&lt;&lt;2) | (KB4&lt;&lt;3) | 0xf0    <span class="comment">//读取的电平数据整合</span></span></span><br><span class="line">                                   </span><br><span class="line">u8 Trg;  <span class="comment">// 全局变量，单次触发</span></span><br><span class="line">u8 Cont;  <span class="comment">// 全局变量，长按</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ReadData = (KEYPORT)^<span class="number">0xff</span>;   <span class="comment">//将读取的电平数据转变成按下数据，按下之后对应位的数据变1</span></span><br><span class="line">  <span class="comment">//u8 ReadData = ~（KEYPORT）;                  //可替代上行代码</span></span><br><span class="line">    Trg = ReadData &amp; (ReadData ^ Cont);      <span class="comment">//</span></span><br><span class="line">    Cont = ReadData;                         <span class="comment">//储存这次的按下数据，用于下次的比较</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Key_Process</span><br><span class="line">u8 ReadData = (KEYPORT)^<span class="number">0xff</span>; <span class="comment">//相当于取反操作，将读取的电平数据转变成亮灭数据</span></span><br><span class="line">    (ReadData ^ Cont)         <span class="comment">//将本次读数的按键与上次做对比，位不同则改位为1</span></span><br><span class="line">    ReadData &amp; (ReadData ^ Cont)<span class="comment">//将按下数据与改变情况做对比，位相同为1</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//Example:</span></span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x01</span>)     <span class="comment">//单词触发</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Cont &amp; <span class="number">0x01</span>)    <span class="comment">//长按</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_cnt++;</span><br><span class="line">        <span class="keyword">if</span>(key_cnt == <span class="number">100</span>)    <span class="comment">//每10ms读取一次，此处判断是否长按1s</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt_key = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//do</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u32 keyTick;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(uwTick - keyTick &lt; <span class="number">20</span>) <span class="keyword">return</span>;     <span class="comment">//当小于20ms时，return出函数</span></span><br><span class="line">    keyTick = uwTick;</span><br><span class="line">    Key_Read();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x01</span>)    <span class="comment">//B2单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x02</span>)   <span class="comment">//B2单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp; <span class="number">0x04</span>)   <span class="comment">//B3单次</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg &amp;<span class="number">0x08</span>)    <span class="comment">//B4单次</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Trg == <span class="number">0x0C</span>)   <span class="comment">//B3和B4同时按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-key-h文件"><a href="#3-key-h文件" class="headerlink" title="3.key.h文件"></a>3.key.h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span>    <span class="comment">//包含后可使用u8</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u8 Trg;  <span class="comment">// 全局变量，单次触发</span></span><br><span class="line"><span class="keyword">extern</span> u8 Cont;  <span class="comment">// 全局变量，长按</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Read</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//最后必须留一空行</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、LED模块"><a href="#三、LED模块" class="headerlink" title="三、LED模块"></a>三、LED模块</h1><h2 id="1-LED模块CubeMX设置"><a href="#1-LED模块CubeMX设置" class="headerlink" title="1.LED模块CubeMX设置"></a>1.LED模块CubeMX设置</h2><p><strong>LED和LCD引脚冲突，PD2为LED的锁存器</strong></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/2.png" alt="img"></p><h2 id="2-LED模块代码"><a href="#2-LED模块代码" class="headerlink" title="2.LED模块代码"></a>2.LED模块代码</h2><h3 id="1-main-c文件-1"><a href="#1-main-c文件-1" class="headerlink" title="1.main.c文件"></a>1.main.c文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 LED_DATA ;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LED_DATA |= <span class="number">0x01</span>;        <span class="comment">//开灯LED1 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        LED_DATA &amp;= ~<span class="number">0x02</span>;       <span class="comment">//灭灯LED2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LED_Control(LED_DATA );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="2-led-c文件（led驱动文件）"><a href="#2-led-c文件（led驱动文件）" class="headerlink" title="2.led.c文件（led驱动文件）"></a>2.led.c文件（led驱动文件）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Control</span><span class="params">(u8 led_ctrl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先熄灭所有LED灯</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOC,<span class="number">0xff00</span>,GPIO_PIN_SET);       <span class="comment">//关闭所有灯，PC8~PC15为8个LED的引脚</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);   <span class="comment">//打开锁存器</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); <span class="comment">//打开锁存器</span></span><br><span class="line">    </span><br><span class="line">    HAL_GPIO_WritePin(GPIOC,led_ctrl &lt;&lt; <span class="number">8</span>,GPIO_PIN_RESET);<span class="comment">//开灯   </span></span><br><span class="line">    <span class="comment">//上一行是：0x01&lt;&lt;8变为0x0100,拉低PC8引脚，LED1点亮</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);   <span class="comment">//打开锁存器</span></span><br><span class="line">    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); <span class="comment">//打开锁存器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-led-h文件"><a href="#3-led-h文件" class="headerlink" title="3.led.h文件"></a>3.led.h文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span>                     <span class="comment">//包含后可使用u8</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Control</span><span class="params">(u8 led_ctrl)</span>;        <span class="comment">//声明函数</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="comment">//最后必须有一空行</span></span><br></pre></td></tr></table></figure><hr><h1 id="四、LCD模块"><a href="#四、LCD模块" class="headerlink" title="四、LCD模块"></a>四、LCD模块</h1><h3 id="1-LCD模块CubeMX设置"><a href="#1-LCD模块CubeMX设置" class="headerlink" title="1.LCD模块CubeMX设置"></a>1.LCD模块CubeMX设置</h3><p>配置见第<strong>零</strong>章</p><h3 id="2-LCD模块代码"><a href="#2-LCD模块代码" class="headerlink" title="2.LCD模块代码"></a>2.LCD模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏幕大小为20*10</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>            <span class="comment">//sprintf需包含此头文件</span></span></span><br><span class="line"></span><br><span class="line">u32 lcdTick;                         <span class="comment">//读取计数器值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(uwTick - lcdTick &lt; <span class="number">200</span>) <span class="keyword">return</span>;   <span class="comment">//LCD每200ms刷新一次</span></span><br><span class="line">    uwTick = lcdTick;</span><br><span class="line"></span><br><span class="line">    u8 display_buf[<span class="number">20</span>];               <span class="comment">//定义缓冲区数组存储数据</span></span><br><span class="line"></span><br><span class="line">    LCD_DisplayStringLine(Line1,(u8*)<span class="string">&quot;        DATA&quot;</span>);   </span><br><span class="line">  <span class="comment">//sprintf函数作用，第二2.3参数与print函数使用相同，第一个参数是printf打印出的值</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   VR37:%4.2fV&quot;</span>,VR37);      </span><br><span class="line">    LCD_DisplayStringLine(Line3,(u8*)display_buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   VR38:%4.2fV&quot;</span>,VR38);</span><br><span class="line">    LCD_DisplayStringLine(Line4,(u8*)display_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   FR39:%05dHZ&quot;</span>,FR39);</span><br><span class="line">    LCD_DisplayStringLine(Line5,(u8*)display_buf);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf,<span class="string">&quot;   FR40:%05dHZ&quot;</span>,FR40);</span><br><span class="line">    LCD_DisplayStringLine(Line6,(u8*)display_buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> main（<span class="type">void</span>）</span><br><span class="line">&#123;    </span><br><span class="line">    LCD_Clear(Blue);           <span class="comment">//设置背景颜色</span></span><br><span class="line">    LCD_SetBackColor(Blue);    <span class="comment">//设置字体背景颜色</span></span><br><span class="line">    LCD_SetTextColor(White);   <span class="comment">//设置字体颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                     &#x3D;&#x3D;<strong>以上部分为嵌入式必考模块，务必熟练！！！</strong>&#x3D;&#x3D;</p><p>​                                                                           &#x3D;&#x3D;<strong>以下部分为嵌入式选考模块！！！</strong>&#x3D;&#x3D;</p><hr><h1 id="五、ADC模块"><a href="#五、ADC模块" class="headerlink" title="五、ADC模块"></a>五、ADC模块</h1><h3 id="1-ADC模块CubeMX设置"><a href="#1-ADC模块CubeMX设置" class="headerlink" title="1.ADC模块CubeMX设置"></a>1.ADC模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/3.png" alt="3cd136daad534bd48907ecb751b3fcf9.png"></p><ul><li>设置引脚</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/4.png" alt="efd7f43d3f52414fb7ca6ca3e0aabc63.png"></p><ul><li>设置ADC1</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/5.png" alt="d77692ab112c499eb5fac08be9c285a1.png"></p><ul><li>设置ADC2</li></ul><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/6.png" alt="e3527d1a94d44343ba5274224aee9663.png"></p><h3 id="2-ADC多路采集模块代码"><a href="#2-ADC多路采集模块代码" class="headerlink" title="2.ADC多路采集模块代码"></a>2.ADC多路采集模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> VR37,VR38,VMCP;      <span class="comment">//定义电压变量</span></span><br><span class="line"><span class="type">float</span> val_R37,val_R38,val_MCP;<span class="comment">//0-4095</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span>                          </span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);                  <span class="comment">//开启adc1_ch5</span></span><br><span class="line">    val_MCP = HAL_ADC_GetValue(&amp;hadc1);     <span class="comment">//获取adc1_ch5的值</span></span><br><span class="line">    VMCP= val_MCP / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VMCP的值</span></span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc1);                  <span class="comment">//开启adc1_ch11</span></span><br><span class="line">    val_R38 = HAL_ADC_GetValue(&amp;hadc1);     <span class="comment">//获取adc1_ch11的值</span></span><br><span class="line">    VR38= val_R38 / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VR38的值</span></span><br><span class="line"></span><br><span class="line">    HAL_ADC_Start(&amp;hadc2);                  <span class="comment">//开启adc2</span></span><br><span class="line">    val_R37 = HAL_ADC_GetValue(&amp;hadc2);     <span class="comment">//获取adc2的值</span></span><br><span class="line">    VR37 = val_R37 / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;        <span class="comment">//计算VR37的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ADC数字滤波代码（题目不要求，不用滤波）"><a href="#3-ADC数字滤波代码（题目不要求，不用滤波）" class="headerlink" title="3.ADC数字滤波代码（题目不要求，不用滤波）"></a>3.ADC数字滤波代码（题目不要求，不用滤波）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数字滤波*/</span></span><br><span class="line"><span class="type">float</span> VR37;        <span class="comment">//定义R37电压变量</span></span><br><span class="line">u32 sum_val_R37;   <span class="comment">//电压和变量</span></span><br><span class="line">u8 val_37_buf;     <span class="comment">//每次读出的值</span></span><br><span class="line">u8 adc_cnt = <span class="number">0</span>;    <span class="comment">//计数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    val_37_buf = HAL_ADC_GetValue(&amp;hadc2); <span class="comment">//获取值</span></span><br><span class="line">    sum_val_R37 += VR37;        <span class="comment">//和</span></span><br><span class="line">    adc_cnt++;                  <span class="comment">//次数加</span></span><br><span class="line">    <span class="keyword">if</span>(adc_cnt == <span class="number">10</span>)           <span class="comment">//判断否已经读取10次</span></span><br><span class="line">    &#123;</span><br><span class="line">        VR37 = sum_val_R37 / <span class="number">10.0f</span> / <span class="number">4095.0f</span> * <span class="number">3.3f</span>; <span class="comment">//求电压平均值</span></span><br><span class="line">        sum_val_R37 = <span class="number">0</span>;                             <span class="comment">//求和清零</span></span><br><span class="line">        adc_cnt = <span class="number">0</span>;                                 <span class="comment">//计数清零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历刷新数组中最老的值，求数组的平均值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_ADC_Start(&amp;hadc2);</span><br><span class="line">    adc2_val = HAL_ADC_GetValue(&amp;hadc2);</span><br><span class="line">    </span><br><span class="line">    ADC_buf[ADC_cnt] = adc2_val / <span class="number">4095.0f</span> * <span class="number">3.3f</span>;      <span class="comment">//储存电压</span></span><br><span class="line">    <span class="keyword">for</span>(cnt=<span class="number">0</span> ;cnt &lt; <span class="number">10</span>;cnt++)                <span class="comment">//电压求和</span></span><br><span class="line">    &#123;</span><br><span class="line">        ADC_sum = ADC_sum + ADC_buf[cnt];    </span><br><span class="line">    &#125;    </span><br><span class="line">        VR37 = ADC_sum / <span class="number">10.0f</span>;              <span class="comment">//电压平均值</span></span><br><span class="line">        ADC_sum = <span class="number">0</span>;                        <span class="comment">//求和清零</span></span><br><span class="line">        ADC_cnt++;                          <span class="comment">//数组下标++</span></span><br><span class="line">    <span class="keyword">if</span>(ADC_cnt == <span class="number">9</span>)                        <span class="comment">//下标范围判断</span></span><br><span class="line">        ADC_cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>学自此可做第十届省赛真题：此届只涉及到了ADC外设。<br>链接:<a href="https://pan.baidu.com/s/1EFhwaQNt6CUTW5c5j0Eaxg">百度网盘：第十届省赛真题</a>  提取码: 6666 </p><h1 id="六、DAC输出模块"><a href="#六、DAC输出模块" class="headerlink" title="六、DAC输出模块"></a>六、DAC输出模块</h1><h2 id="1-DAC双路输出模块CubeMX设置"><a href="#1-DAC双路输出模块CubeMX设置" class="headerlink" title="1.DAC双路输出模块CubeMX设置"></a>1.DAC双路输出模块CubeMX设置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/7.png" alt="bdf317270b204cecb17134591f7d3799.png"></p><p>设置引脚</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/8.png" alt="{3b89c9117fbf41ac8e0bfc75f1446a68.png}"></p><p>DAC1设置</p><h2 id="2-DAC双路输出模块代码"><a href="#2-DAC双路输出模块代码" class="headerlink" title="2.DAC双路输出模块代码"></a>2.DAC双路输出模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">u16 dac_ch1_val,dac_ch2_val;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DAC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    dac_ch1_val = (<span class="number">1.1f</span>/<span class="number">3.3f</span>)*<span class="number">4095.0f</span>;  <span class="comment">//CH1输出1.1V</span></span><br><span class="line">    dac_ch2_val = (<span class="number">2.3f</span>/<span class="number">3.3f</span>)*<span class="number">4095.0f</span>;  <span class="comment">//CH2输出2.3V</span></span><br><span class="line">    </span><br><span class="line">    HAL_DAC_SetValue(&amp;hdac1,DAC_CHANNEL_1,DAC_ALIGN_12B_R,dac_ch1_val);<span class="comment">//设置DAC1，CH1的值</span></span><br><span class="line">    HAL_DAC_Start(&amp;hdac1,DAC_CHANNEL_1);            <span class="comment">//打开DAC1,CH1</span></span><br><span class="line">    </span><br><span class="line">    HAL_DAC_SetValue(&amp;hdac1,DAC_CHANNEL_2,DAC_ALIGN_12B_R,dac_ch2_val);<span class="comment">//设置DAC1，CH2的值</span></span><br><span class="line">    HAL_DAC_Start(&amp;hdac1,DAC_CHANNEL_2);            <span class="comment">//打开DAC1,CH2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="七、PWM捕获模块"><a href="#七、PWM捕获模块" class="headerlink" title="七、PWM捕获模块"></a>七、PWM捕获模块</h1><h3 id="1-PWM双路捕获模块CubeMX设置"><a href="#1-PWM双路捕获模块CubeMX设置" class="headerlink" title="1.PWM双路捕获模块CubeMX设置"></a>1.PWM双路捕获模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/9.png" alt="228e9d0e491a42d5a14bbf9698c3b860.png"></p><p><strong>设置引脚</strong></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/10.png" alt="0dbd4b9828e04a32b829f1d03cadc0df.png"></p><p>设置TIM2</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/11.png" alt="075bf965a7bc46fcaabe7bc08f3720e2.png"></p><p>设置TIM3</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/12.png" alt="ecb7f96fc5fd4cbda32ab62e34ef15e0.png"></p><p>打开TIM中断</p><h3 id="2-PWM双路捕获模块代码"><a href="#2-PWM双路捕获模块代码" class="headerlink" title="2.PWM双路捕获模块代码"></a>2.PWM双路捕获模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> VR37,VR38;      <span class="comment">//定义电压变量</span></span><br><span class="line">u16 FR39,FR40;        <span class="comment">//定义频率变量</span></span><br><span class="line"><span class="type">float</span> DR40,DR39;      <span class="comment">//占空比变量</span></span><br><span class="line"><span class="type">float</span> val_R37,val_R38;<span class="comment">//0-4095</span></span><br><span class="line">u8 PWM_R40_state =<span class="number">0</span>,PWM_R39_state;<span class="comment">//状态改变变量</span></span><br><span class="line">u16 R40_cnt1 = <span class="number">0</span>,R40_cnt2 = <span class="number">0</span>,R39_cnt1 = <span class="number">0</span>,R39_cnt2 = <span class="number">0</span>;    <span class="comment">//存储中断发生时间变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_IC_CaptureCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span>    <span class="comment">//PWM捕获回调函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim2)      <span class="comment">//判断TIM2，R40</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(PWM_R40_state == <span class="number">0</span>)      <span class="comment">//第一个上升沿产生</span></span><br><span class="line">        &#123;   </span><br><span class="line">            TIM2-&gt;CNT = <span class="number">0</span>;          <span class="comment">//计数器清零</span></span><br><span class="line">            TIM2-&gt;CCER |= <span class="number">0x02</span>;  <span class="comment">//改为下降沿中断，CCER寄存器的第二位的值控制CH1的上下沿捕获</span></span><br><span class="line">            PWM_R40_state = <span class="number">1</span>;      <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R40_state == <span class="number">1</span>)      <span class="comment">//下降沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R40_cnt1 = TIM2-&gt;CNT;        <span class="comment">//获取计数(高电平时间)</span></span><br><span class="line">            TIM2-&gt;CCER &amp;= ~<span class="number">0x02</span>;         <span class="comment">//改为上升沿中断</span></span><br><span class="line">            PWM_R40_state = <span class="number">2</span>;           <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R40_state == <span class="number">2</span>)              <span class="comment">//第二个上升沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R40_cnt2 = TIM2-&gt;CNT;                <span class="comment">//获取计数（周期）</span></span><br><span class="line">            FR40 = <span class="number">1000000</span> / R40_cnt2;           <span class="comment">//计算频率</span></span><br><span class="line">            DR40 = R40_cnt1 *<span class="number">100.0f</span> / R40_cnt2 ; <span class="comment">//计算占空比</span></span><br><span class="line">            PWM_R40_state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_TIM_IC_Start_IT(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//重新打开中断</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(htim == &amp;htim3)      <span class="comment">//判断TIM3，R39</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(PWM_R39_state == <span class="number">0</span>)      <span class="comment">//第一个上升沿产生</span></span><br><span class="line">        &#123;   </span><br><span class="line">            TIM3-&gt;CNT = <span class="number">0</span>;          <span class="comment">//计数器清零</span></span><br><span class="line">            TIM3-&gt;CCER |= <span class="number">0x02</span>;     <span class="comment">//改为下降沿中断</span></span><br><span class="line">            PWM_R39_state = <span class="number">1</span>;      <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R39_state == <span class="number">1</span>)      <span class="comment">//下降沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R39_cnt1 = TIM3-&gt;CNT;       <span class="comment">//获取计数(高电平时间)</span></span><br><span class="line">            TIM3-&gt;CCER &amp;= ~<span class="number">0x02</span>;        <span class="comment">//改为上升沿中断</span></span><br><span class="line">            PWM_R39_state = <span class="number">2</span>;          <span class="comment">//切换状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(PWM_R39_state == <span class="number">2</span>)      <span class="comment">//第二个上升沿产生</span></span><br><span class="line">        &#123;</span><br><span class="line">            R39_cnt2 = TIM3-&gt;CNT;        <span class="comment">//获取计数（周期）</span></span><br><span class="line">            FR39 = <span class="number">1000000</span> / R39_cnt2;   <span class="comment">//计算频率</span></span><br><span class="line">            DR39 = R39_cnt1  *<span class="number">100.0f</span>/ R39_cnt2;   <span class="comment">//计算占空比</span></span><br><span class="line">            PWM_R39_state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HAL_TIM_IC_Start_IT(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//重新打开中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码在main()中</span></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim2,TIM_CHANNEL_1);<span class="comment">//开启PWM捕获中断</span></span><br><span class="line">HAL_TIM_IC_Start_IT(&amp;htim3,TIM_CHANNEL_1);<span class="comment">//开启PWM捕获中断</span></span><br></pre></td></tr></table></figure><hr><h1 id="八、PWM输出模块"><a href="#八、PWM输出模块" class="headerlink" title="八、PWM输出模块"></a>八、PWM输出模块</h1><h3 id="1-PWM输出模块CubeMX设置"><a href="#1-PWM输出模块CubeMX设置" class="headerlink" title="1.PWM输出模块CubeMX设置"></a>1.PWM输出模块CubeMX设置</h3><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/13.png" alt="40f57283c6b34721ba805510e0f9f617.png"></p><p>设置引脚</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/14.png" alt="148c5a4ab14f4796b0f7cea266ac76c4.png"></p><p>TIM16设置</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/15.png" alt="3799c54ca0d74373a4edc908a878fdbb.png"></p><p>TIM17设置</p><h3 id="2-PWM输出模块代码"><a href="#2-PWM输出模块代码" class="headerlink" title="2.PWM输出模块代码"></a>2.PWM输出模块代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ARR自动重装载值，CRR比较寄存器</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim16,TIM_CHANNEL_1);<span class="comment">//启用TIM16，通道1，PWM输出</span></span><br><span class="line">TIM16-&gt;ARR = <span class="number">999</span>;       <span class="comment">//设置频率为1000HZ</span></span><br><span class="line">TIM16-&gt;CCR1 = <span class="number">400</span>;      <span class="comment">//通道1，设置60%占空比</span></span><br><span class="line">    </span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim17,TIM_CHANNEL_1);<span class="comment">//启用TIM17，通道1，PWM输出</span></span><br><span class="line">TIM17-&gt;ARR = <span class="number">1999</span>;      <span class="comment">//设置频率为500HZ</span></span><br><span class="line">TIM17-&gt;CCR1 = <span class="number">100</span>;       <span class="comment">//通道1，设置95%占空比</span></span><br></pre></td></tr></table></figure><hr><h1 id="九、I2C模块"><a href="#九、I2C模块" class="headerlink" title="九、I2C模块"></a>九、I2C模块</h1><p>直接将官方的i2c.c,i2c.h添加到项目中</p><h2 id="1-I2C模块代码"><a href="#1-I2C模块代码" class="headerlink" title="1.I2C模块代码"></a>1.I2C模块代码</h2><h3 id="1-i2c-c文件"><a href="#1-i2c-c文件" class="headerlink" title="1.i2c.c文件"></a>1.i2c.c文件</h3><p>​    在i2c.c后编写    各函数主体9-12-6-7行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写24C02</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Write</span><span class="params">(u8 add,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">I2CStart();          <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa0</span>);   <span class="comment">//发送24c02地址，第一位0为写信号</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(add); <span class="comment">//发送填写地址</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(dat);    <span class="comment">//发送要储存的数据</span></span><br><span class="line">I2CWaitAck();        <span class="comment">//等待回应 </span></span><br><span class="line"></span><br><span class="line">I2CStop();           <span class="comment">//发送停止信号</span></span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">5</span>);        <span class="comment">//延时，两次写入的间隔要5ms</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读24C02</span></span><br><span class="line">u8 <span class="title function_">EEPROM_Read</span><span class="params">(u8 add)</span>   </span><br><span class="line">&#123;</span><br><span class="line">I2CStart();          <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa0</span>);   <span class="comment">//发送24c02地址，第一位0为写信号</span></span><br><span class="line">I2CWaitAck();      </span><br><span class="line"></span><br><span class="line">I2CSendByte(add);    <span class="comment">//发送要读取数据的储存地址</span></span><br><span class="line">I2CWaitAck();        </span><br><span class="line"></span><br><span class="line">I2CStart();               <span class="comment">//再次发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0xa1</span>);        <span class="comment">//发送24c02地址，第一位1为读信号</span></span><br><span class="line">I2CWaitAck();           </span><br><span class="line"></span><br><span class="line">u8 dat = I2CReceiveByte();   <span class="comment">//读取数据</span></span><br><span class="line">I2CSendNotAck();          <span class="comment">//不应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                <span class="comment">//发送停止信号</span></span><br><span class="line"><span class="keyword">return</span>(dat);              <span class="comment">//返回数据接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写MCP4017</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MCP4017_Write</span><span class="params">(u8 val)</span></span><br><span class="line">&#123;   </span><br><span class="line">I2CStart();                <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0x5E</span>);         <span class="comment">//发送器件地址，写信号</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(val);          <span class="comment">//发送数据        //8位数据，但最高位为0</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                 <span class="comment">//发送结束信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读MCP4017</span></span><br><span class="line">u8 <span class="title function_">MCP4017_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">I2CStart();                <span class="comment">//发送开始信号</span></span><br><span class="line"></span><br><span class="line">I2CSendByte(<span class="number">0x5F</span>);         <span class="comment">//发送器件地址，读信号</span></span><br><span class="line">I2CWaitAck();              <span class="comment">//等待应答</span></span><br><span class="line"></span><br><span class="line">u8 val = I2CReceiveByte();    <span class="comment">//接收数据</span></span><br><span class="line">I2CSendNotAck();           <span class="comment">//不应答</span></span><br><span class="line"></span><br><span class="line">I2CStop();                 <span class="comment">//发送停止信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> val;                <span class="comment">//返回接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*MCP4017数字电位器*/</span></span><br></pre></td></tr></table></figure><h2 id="2-main-c文件"><a href="#2-main-c文件" class="headerlink" title="2.main.c文件"></a>2.main.c文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2c.h&quot;</span>    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2CInit();    <span class="comment">//初始化IO口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Rs * 127 &#x3D; 100k -&gt;Rs &#x3D; 100k &#x2F; 127    Rs是接入电路的每段电阻，共127个</p><p>R &#x3D; 8 *（100 &#x2F; 127）        R是接入电路的电阻</p><p>V &#x3D; 3.3 * R &#x2F; (R + 10)        输出的理论电压</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EEPROM_Write(<span class="number">0x08</span>);</span><br></pre></td></tr></table></figure><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/16.png" alt="aedc1195217f4e1ab2be933a6cc9aea4.png"></p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/17.png" alt="91eecd4f6d85424597c59150f1aec333.png"></p><hr><h1 id="十、UART模块"><a href="#十、UART模块" class="headerlink" title="十、UART模块"></a>十、UART模块</h1><h2 id="1-UART模块CubeMX配置"><a href="#1-UART模块CubeMX配置" class="headerlink" title="1.UART模块CubeMX配置"></a>1.UART模块CubeMX配置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/17.png" alt="img"></p><h2 id="2-UART发送模块代码"><a href="#2-UART发送模块代码" class="headerlink" title="2.UART发送模块代码"></a>2.UART发送模块代码</h2><p>查找fputs()的方法</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/18.png" alt="img"></p><p>务必勾选MicroLIB库，否则fputs()重映射无法使用</p><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/19.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在&quot;usart.h&quot;中声明*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span>        <span class="comment">//包含后可使用FILE</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*printf重定向在&quot;usart.c&quot;中*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(<span class="type">unsigned</span> <span class="type">char</span>*)&amp;ch,<span class="number">1</span>,<span class="number">50</span>);    <span class="comment">//串口发送函数</span></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在&quot;main.h&quot;中直接使用printf发出数据*/</span></span><br><span class="line">u8 val = <span class="number">123</span>;                     <span class="comment">//定义变量</span></span><br><span class="line">u8 buf[<span class="number">50</span>] = &#123;<span class="string">&quot;lanqiaobei\r\n&quot;</span>&#125;;  <span class="comment">//定义数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;HelloWorld!\r\n&quot;</span>);        <span class="comment">//发送字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,<span class="number">666</span>);             <span class="comment">//发送数字    </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;val:%d\r\n&quot;</span>,&amp;val);        <span class="comment">//发送变量中的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>,buf);             <span class="comment">//发送数组</span></span><br></pre></td></tr></table></figure><h2 id="3-UART接收模块代码"><a href="#3-UART接收模块代码" class="headerlink" title="3.UART接收模块代码"></a>3.UART接收模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="string">&lt;string.h&gt;</span>    <span class="comment">//包含后可使用memset()函数</span></span></span><br><span class="line">u8 uart_buf[<span class="number">20</span>];       <span class="comment">//uart接收数组</span></span><br><span class="line">u32 uartTick;          <span class="comment">//uart定时器计数变量</span></span><br><span class="line">u8 rx_cnt;             <span class="comment">//uart数据下表变量</span></span><br><span class="line">u8 rx_buf[<span class="number">10</span>];         <span class="comment">//uart接收缓存数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RxIdle_Process</span><span class="params">()</span>                   <span class="comment">//拓展部分函数，用于清空储存数组中的垃圾值        </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(uwTick - uartTick &lt; <span class="number">50</span>)<span class="keyword">return</span>;           <span class="comment">//50ms执行一次</span></span><br><span class="line">    uartTick = uwTick;</span><br><span class="line"></span><br><span class="line">    rx_cnt = <span class="number">0</span>;                                 <span class="comment">//计数下标清零</span></span><br><span class="line">    <span class="built_in">memset</span>(rx_buf,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(rx_buf));         <span class="comment">//清空rx_buf中的数据，使用要引用&lt;string.h&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span>     <span class="comment">//uart接收回调中断</span></span><br><span class="line">&#123;</span><br><span class="line">    uartTick = uwTick;                          <span class="comment">//重新计时50ms</span></span><br><span class="line">    </span><br><span class="line">    rx_buf[rx_cnt++] = uart_buf[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(rx_cnt == <span class="number">3</span>)                    <span class="comment">//此处代码为：当接收到3个值时，执行亮灯操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        rx_cnt = <span class="number">0</span>;</span><br><span class="line">        LED_Control(rx_buf[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_UART_Receive_IT(&amp;huart1,uart_buf,<span class="number">1</span>);    <span class="comment">//重新打开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart1,uart_buf,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="十一、RTC模块"><a href="#十一、RTC模块" class="headerlink" title="十一、RTC模块"></a>十一、RTC模块</h1><h2 id="1-RTC模块CubeMX配置"><a href="#1-RTC模块CubeMX配置" class="headerlink" title="1.RTC模块CubeMX配置"></a>1.RTC模块CubeMX配置</h2><p><img src="/2024/12/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/20.png" alt="3bd079d3540a45a6aa1f6ab3f3300362.png"></p><p>RTC配置</p><h2 id="2-RTC模块代码"><a href="#2-RTC模块代码" class="headerlink" title="2.RTC模块代码"></a>2.RTC模块代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RTC_TimeTypeDef RTC_time;<span class="comment">//定义时间结构体变量</span></span><br><span class="line">RTC_DateTypeDef RTC_data;<span class="comment">//定义日期结构体变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RTC_Process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_RTC_GetTime(&amp;hrtc,&amp;RTC_time,RTC_FORMAT_BIN);<span class="comment">//获取时间，返回十进制</span></span><br><span class="line">    HAL_RTC_GetDate(&amp;hrtc,&amp;RTC_data,RTC_FORMAT_BIN);<span class="comment">//获取日期，返回十进制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></center></center>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;center&gt;本文不涉及原理，只涉及模块的使用
&lt;center&gt;南京工业大学浦江学院 22级自动化 姚道文

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 </summary>
      
    
    
    
    <category term="蓝桥杯" scheme="https://ydw-item.github.io.git/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="嵌入式" scheme="https://ydw-item.github.io.git/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="蓝桥杯" scheme="https://ydw-item.github.io.git/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="嵌入式" scheme="https://ydw-item.github.io.git/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>GPIO基础知识</title>
    <link href="https://ydw-item.github.io.git/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://ydw-item.github.io.git/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2024-09-27T16:07:09.000Z</published>
    <updated>2024-09-27T16:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GPIO：通用型输入输出，可以<code>控制输入输出</code>的STM32引脚</strong></p><table><thead><tr><th align="center"><strong>浮空输入</strong></th><th align="center"><strong>Input floating</strong></th></tr></thead><tbody><tr><td align="center"><strong>拉上输入</strong></td><td align="center"><strong>Input pull-up</strong></td></tr><tr><td align="center"><strong>下拉输入</strong></td><td align="center"><strong>Input-pull-down</strong></td></tr><tr><td align="center"><strong>模拟输入</strong></td><td align="center"><strong>Anglog</strong></td></tr><tr><td align="center"><strong>开漏输出</strong></td><td align="center"><strong>Output open-drain</strong></td></tr><tr><td align="center"><strong>推挽输出</strong></td><td align="center"><strong>Output push-pull</strong></td></tr><tr><td align="center"><strong>推翻复用</strong></td><td align="center"><strong>Alternate function push-pull</strong></td></tr><tr><td align="center"><strong>开漏复用</strong></td><td align="center"><strong>Alternate function open-drain</strong></td></tr></tbody></table><p><strong>输出模式：<code>控制端口输出高电平低电平</code>，用于驱动LED，蜂鸣器等，若十大功率器件，则要加上驱动器（小电流控制大电流）</strong></p><p><strong>输入模式：<code>读取端口的高低电平</code>，用于读取外接按键，外接模拟信号的输入，ADC电压采集，模拟通信协议接受数据等</strong></p><p><img src="/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240927202349798.png" alt="image-20240927202349798"></p><ul><li><strong>端口位设置&#x2F;清除寄存器(GPIOx_BSRR)(x&#x3D;A…E):低位用于设置ODRy位为1，高位用于设置ODRy位为0</strong></li><li><strong>端口输出数据寄存器(GPIOx_ODR)(x&#x3D;A..E):可以分别地对各个ODR位进行独立的设置&#x2F;清除</strong></li></ul><h1 id="一、推挽输出"><a href="#一、推挽输出" class="headerlink" title="一、推挽输出"></a>一、推挽输出</h1><ul><li><p><strong>当输出控制为1时</strong></p><p>  <strong>P-MOS导通，N-MOS不导通，输出<code>高电平</code></strong></p></li><li><p><strong>当输出控制为0时</strong></p></li></ul><p>​<strong>P-MOS永远不导通，N-MOS导通，输出低电平</strong></p><ul><li><strong>引脚<code>电流流向单片机內部</code>或着<code>从单片机内部流向外部</code></strong></li><li><strong>可以同时从输入寄存器读取引脚状态</strong></li><li><strong>使用场所</strong></li></ul><ol><li><strong>驱动能力需求高的场合</strong></li><li><strong>高速信号传输</strong></li><li><strong>无需共用信号线的场合</strong></li></ol><h1 id="二、开漏输出"><a href="#二、开漏输出" class="headerlink" title="二、开漏输出"></a>二、开漏输出</h1><ul><li><p><strong>输出控制为0</strong></p><p>  <strong>P-MOS永远关闭，N-MOS导通，  输出低电平</strong></p></li><li><p><strong>输出控制为1</strong></p></li></ul><p>​<strong>P-MOS永远不导通,N-MOS也不导通，输出高阻态</strong></p><p>​<strong>此时要想引脚输出高电平或低电平，需要在单片机外部，接上拉或下拉电阻</strong></p><p>​电阻很大–弱上拉     电阻很小–强上拉</p><ul><li><strong>可以同时从输入寄存器读取引脚状态</strong></li><li><strong>使用场所</strong></li></ul><ol><li><p><strong>多个设备共用信号线</strong></p></li><li><p><strong>不同电压系统之间的接口</strong></p></li><li><p><strong>需要外部上拉电阻来确定逻辑高电平的场合</strong></p></li><li><p><strong>工作时，两个MOS管交替工作来驱动负载。</strong></p><p> <strong>输出1时，上部晶体管导通将电流推向负载</strong></p></li></ol><p>​<strong>输出0时，下部集体管导通将电流拉回地线</strong></p><h1 id="三、复用功能"><a href="#三、复用功能" class="headerlink" title="三、复用功能"></a>三、复用功能</h1><p><strong>引脚不作为IO口来使用，用作其它功能</strong></p><h1 id="四、上拉和下拉输入"><a href="#四、上拉和下拉输入" class="headerlink" title="四、上拉和下拉输入"></a>四、上拉和下拉输入</h1><p><strong>读取引脚的电平</strong></p><ul><li><p><strong>当IO输入电压大于VDD，二极管导通，此时VIO &#x3D;&#x3D; VDD，保护芯片</strong></p></li><li><p><strong>当IO输入电压小于VDD，二极管导通，此时VIO &#x3D;&#x3D; VSS，保护芯片</strong>  </p></li><li><p><strong>该模式下输出功能无效</strong></p></li><li><p><strong>施密特触发器作用</strong></p></li></ul><p><img src="/2024/09/28/GPIO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240928000612157.png" alt="image-20240928000612157"></p><h1 id="五、模拟输入"><a href="#五、模拟输入" class="headerlink" title="五、模拟输入"></a>五、模拟输入</h1><ul><li><p><strong>施密特触发器禁用，输入数据寄存器值为0</strong></p></li><li><p><strong>ADC</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GPIO：通用型输入输出，可以&lt;code&gt;控制输入输出&lt;/code&gt;的STM32引脚&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;浮空输入&lt;/strong&gt;&lt;/th&gt;
&lt;th al</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="外设" scheme="https://ydw-item.github.io.git/categories/STM32/%E5%A4%96%E8%AE%BE/"/>
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>LVGL(二)部件部分</title>
    <link href="https://ydw-item.github.io.git/2024/09/25/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/"/>
    <id>https://ydw-item.github.io.git/2024/09/25/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/</id>
    <published>2024-09-25T10:13:55.000Z</published>
    <updated>2024-09-28T16:22:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、标签部件"><a href="#一、标签部件" class="headerlink" title="一、标签部件"></a>一、标签部件</h1><p><strong>主体   滚动条   选中的文本</strong>    </p><h2 id="1-创建标签部件"><a href="#1-创建标签部件" class="headerlink" title="1 .创建标签部件"></a>1 .创建标签部件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *label =lv_label_create(lv_scr_act()); <span class="comment">//create中传入父对象</span></span><br></pre></td></tr></table></figure><h2 id="2-设置文本的三种方式"><a href="#2-设置文本的三种方式" class="headerlink" title="2. 设置文本的三种方式"></a>2. 设置文本的三种方式</h2><ul><li><strong>直接设置文本，存储文本的<u>内存动态分配</u></strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text(label,<span class="string">&quot;hello\n lvgl&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>文本不存储在动态内存，而是在<u>指定的缓冲区中</u>，代码块中只读，修改可能会崩溃(慎用)</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text_static(label,<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>格式化显示文本，类似printf</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text_fmt(label,<span class="string">&quot;Value:%d&quot;</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h2 id="3-设置文本样式"><a href="#3-设置文本样式" class="headerlink" title="3.设置文本样式"></a>3.设置文本样式</h2><ul><li><strong>背景颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_bg_color(label,    <span class="comment">//父对象</span></span><br><span class="line">         lv_color_hex(<span class="number">0xff0000</span>),    <span class="comment">//十六进制颜色</span></span><br><span class="line">              LV_STATE_DEFAULT);    <span class="comment">//触发类型</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置背景透明度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_bg_opa(label,</span><br><span class="line">                          <span class="number">100</span>，<span class="comment">//0-255,越大越不透明</span></span><br><span class="line">            LV_STATE_DEFAULT); <span class="comment">//触发类型  </span></span><br></pre></td></tr></table></figure><ul><li><strong>字体大小</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_font(label,    <span class="comment">//对象</span></span><br><span class="line">           &amp;lv_font_montserrat_30,    <span class="comment">//字号       使用字体要打开lv_conf,h中对应的宏定义</span></span><br><span class="line">               LV_STATE_DEFAULT);    <span class="comment">//触发类型</span></span><br></pre></td></tr></table></figure><ul><li><strong>文本颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_color(label,<span class="comment">//对象</span></span><br><span class="line">           lv_color_hex(<span class="number">0x5084db</span>),<span class="comment">//字体颜色</span></span><br><span class="line">                LV_STATE_DEFAULT);<span class="comment">//触发类型</span></span><br></pre></td></tr></table></figure><p><img src="/2024/09/25/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/image-20240924223843334-1727619652515-4.png" alt="image-20240924223843334"></p><ul><li><p><strong>单独设置字体颜色</strong></p><ul><li><strong>开启重新着色的功能</strong></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_recolor(label,ture);</span><br></pre></td></tr></table></figure><ul><li></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_text(label,<span class="string">&quot;hello #ff0000 lvgl#&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2024/09/25/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/image-20240924225050932-1727619652515-5.png" alt="image-20240924225050932"></p><h2 id="4-文本长度"><a href="#4-文本长度" class="headerlink" title="4. 文本长度"></a>4. 文本长度</h2><ul><li><p><strong>默认情况下，如果没有限定标签部件大小，那它的大小自动拓展为文本大小</strong></p></li><li><p><strong>长文本模式</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_label_set_long_mode(label,  <span class="comment">//对象</span></span><br><span class="line">       LV_LABEL_LONG_SCROLL);  <span class="comment">//显示模式</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LV_LABEL_LONG_WRAP,             <span class="comment">/* 默认模式，如果部件大小已固定，超出的文本将被剪切 */</span></span><br><span class="line">    LV_LABEL_LONG_DOT,              <span class="comment">/* 将label右下角的最后3个字符替换为... */</span></span><br><span class="line">    LV_LABEL_LONG_SCROLL,           <span class="comment">/* 来回滚动 */</span></span><br><span class="line">    LV_LABEL_LONG_SCROLL_CIRCULAR,  <span class="comment">/* 循环滚动 */</span></span><br><span class="line">    LV_LABEL_LONG_CLIP,             <span class="comment">/* 直接剪切掉部件外面的文本部分 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二、按钮部件"><a href="#二、按钮部件" class="headerlink" title="二、按钮部件"></a>二、按钮部件</h1><p><strong>按钮部件相比基础对象，没有新增功能</strong></p><ul><li><strong>创建按钮部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *btn = lv_btn_create(lv_scr_act());</span><br></pre></td></tr></table></figure><ul><li><strong>设置样式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size(btn,<span class="number">100</span>,<span class="number">50</span>);    <span class="comment">// 大小</span></span><br><span class="line">lv_obj_set_align(btn,LV_ALIGN_CENTER);  <span class="comment">// 对齐方式</span></span><br><span class="line">lv_obj_set_style_bg_color(btn,lv_color_hex(<span class="number">0xde4d3e</span>),LV_STATE_PRESSED);</span><br></pre></td></tr></table></figure><ul><li><strong>添加事件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_flag(btn,LV_OBJ_FLAG_CHECKABLE);         <span class="comment">// 开启状态 </span></span><br><span class="line">lv_obj_add_event_cb(btn,<span class="comment">//对象</span></span><br><span class="line">               event_cb,<span class="comment">//回调函数名称</span></span><br><span class="line"> LV_EVENT_VALUE_CHANGED,<span class="comment">//触发类型</span></span><br><span class="line">                  <span class="literal">NULL</span>);<span class="comment">//  </span></span><br></pre></td></tr></table></figure><h1 id="三、开关部件"><a href="#三、开关部件" class="headerlink" title="三、开关部件"></a>三、开关部件</h1><p><strong>开关部件常用于控制某个功能的开启或关闭，可以直接显示被控对象的状态</strong></p><p><strong>主体（关闭时显示）    <code>LV_PART_MAIN</code></strong></p><p><strong>手柄       <code>LV_PART_KNOB</code></strong></p><p><strong>指示器（开启时显示）<code>LV_PART_INDICATOR</code></strong></p><ul><li><strong>创建开关部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *switch1 = lv_switch_create(lv_scr_act());</span><br><span class="line">lv_obj_set_style_bg_color(switch1,lv_color_hex(<span class="number">0xdf5345</span>),LV_STATE_CHECKED|LV_PART_INDICATOR); <span class="comment">//指示器要设置显示状态</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加、清除开关状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_state(switch1, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">// 添加状态：默认打开且不可修改</span></span><br><span class="line">lv_obj_clear_state(switch1, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">// 清除开关的状态 </span></span><br></pre></td></tr></table></figure><ul><li><strong>获取（判断）开关状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_has_state(switch1, LV_STATE_CHECKED) <span class="comment">//判断是否是LV_STATE_CHECKED状态， 返回值：bool类型</span></span><br></pre></td></tr></table></figure><h1 id="四、复选框"><a href="#四、复选框" class="headerlink" title="四、复选框"></a>四、复选框</h1><p><strong>主体</strong></p><p><strong>勾选框</strong></p><ul><li><strong>创建复选框</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *checkbox  = lv_checkbox_create (parent );</span><br></pre></td></tr></table></figure><ul><li><strong>文本设置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_checkbox_set_text( checkbox, <span class="string">&quot;remember the password&quot;</span> );<span class="comment">/* 设置文本内容 */</span></span><br><span class="line">lv_obj_set_style_pad_column( checkbox, <span class="number">20</span>, LV_STATE_DEFAULT ); <span class="comment">/* 设置文本和勾选框的间距</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加、清除复选框状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_state(checkbox, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">/* 添加状态：默认选中且不可修改 */</span></span><br><span class="line">lv_obj_clear_state(checkbox, LV_STATE_CHECKED | LV_STATE_DISABLED);<span class="comment">/* 清除复选框的状态 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取（判断）复选框状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_has_state(checkbox, LV_STATE_CHECKED); <span class="comment">/* 返回值：1，选中； 0，非选中 */</span></span><br></pre></td></tr></table></figure><h1 id="五、进度条部件"><a href="#五、进度条部件" class="headerlink" title="五、进度条部件"></a>五、进度条部件</h1><p><strong>常用于显示当前任务的进度</strong></p><p><strong>主体</strong></p><p><strong>指示器</strong></p><ul><li><strong>创建进度条部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *bar  = lv_bar_create ( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置大小、当前值、范围值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size( bar, <span class="number">400</span>, <span class="number">20</span> );<span class="comment">/* 设置大小 */</span> <span class="comment">// 决定进度条从左往右，还是从下往上</span></span><br><span class="line">lv_bar_set_value( bar, <span class="number">50</span>, LV_ANIM_ON );<span class="comment">/* 设置当前值 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置动画时间</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_anim_time( bar, <span class="number">500</span>, LV_STATE_DEFAULT ); <span class="comment">/* 动画设置必须放在当前值设置之前 */</span> </span><br><span class="line">                                         <span class="comment">//选择器</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置样式和起始值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_bar_set_mode( bar, LV_BAR_MODE_RANGE );<span class="comment">/* 设置模式 */</span></span><br><span class="line">lv_bar_set_start_value( bar, <span class="number">-50</span>, LV_ANIM_OFF );<span class="comment">/* 设置起始</span></span><br></pre></td></tr></table></figure><ul><li><strong>模式枚举</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LV_BAR_MODE_NORMAL,<span class="comment">/* 默认模式 */</span></span><br><span class="line">    LV_BAR_MODE_SYMMETRICAL,    <span class="comment">/* 从零值绘制到当前值（当前值可以小于0） */</span></span><br><span class="line">    LV_BAR_MODE_RANGE<span class="comment">/* 允许设置起始值，但起始值必须小于当前值 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="六、加载器部件"><a href="#六、加载器部件" class="headerlink" title="六、加载器部件"></a>六、加载器部件</h1><p><strong>常用于提示当前任务正在加载</strong></p><p><strong>主体</strong></p><p><strong>指示器</strong></p><p><strong>手柄（指示器的起点）</strong></p><ul><li><strong>创建加载器部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *spinner  = lv_spinner_create( parent, spin_time, arc_length );</span><br></pre></td></tr></table></figure><ul><li><strong>设置圆弧的颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_arc_color( spinner, lv_color_hex(<span class="number">0x4a9f00</span>), LV_PART_MAIN );    <span class="comment">/* 设置主体圆弧颜色 */</span></span><br><span class="line">lv_obj_set_style_arc_color( spinner, lv_color_hex(<span class="number">0x83bd55</span>), LV_PART_INDICATOR );   <span class="comment">/* 设置指示器圆弧颜色 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置圆弧宽度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_arc_width( spinner, <span class="number">30</span>, LV_PART_MAIN ); <span class="comment">/* 设置主体圆弧宽度 */</span></span><br><span class="line">lv_obj_set_style_arc_width( spinner, <span class="number">30</span>, LV_PART_INDICATOR );<span class="comment">/* 设置指示器圆弧宽度 */</span></span><br></pre></td></tr></table></figure><h1 id="七、LED部件"><a href="#七、LED部件" class="headerlink" title="七、LED部件"></a>七、LED部件</h1><p><strong>常用于指示控制对象的状态</strong></p><ul><li><strong>创建LED部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *led = lv_led_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置LED颜色、亮度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_led_set_color( led, lv_color_hex(<span class="number">0xff0000</span>) )；<span class="comment">/* 设置LED颜色 */</span></span><br><span class="line">lv_led_set_brightness( led, <span class="number">0</span> );    <span class="comment">/* 设置LED亮度，范围0~255 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置LED状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_led_on( led );    <span class="comment">/* 打开LED（设置亮度为255）*/</span></span><br><span class="line">lv_led_off( led );    <span class="comment">/* 关闭LED */</span></span><br><span class="line">lv_led_toggle( led );<span class="comment">/* 翻转LED状态 */</span></span><br></pre></td></tr></table></figure><h1 id="八、列表部件"><a href="#八、列表部件" class="headerlink" title="八、列表部件"></a>八、列表部件</h1><p><strong>常用于多选一的场景，默认会展现多个选项</strong></p><p><strong>主体</strong></p><p><strong>滚动条</strong></p><ul><li><strong>创建列表部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *<span class="built_in">list</span> = lv_list_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>添加列表文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_list_add_text( <span class="built_in">list</span>, “Settings<span class="string">&quot; );</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加列表按钮</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *btn= lv_list_add_btn( <span class="built_in">list</span>, LV_SYMBOL_WIFI, “WLAN<span class="string">&quot;); </span></span><br></pre></td></tr></table></figure><ul><li><strong>获取列表按钮文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_list_get_btn_text( <span class="built_in">list</span>, list_btn );</span><br></pre></td></tr></table></figure><ul><li><strong>回调</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *list_btn = lv_event_get_target(e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> *list_btn = lv_event_get_target(e);   <span class="comment">// 获取触发源</span></span><br><span class="line">    lv_label_set_text(list_label,lv_list_get_btn_text(<span class="built_in">list</span>,list_btn)); <span class="comment">// 获取按钮文本并显示</span></span><br><span class="line">    lv_obj_add_state(list_btn,LV_STATE_FOCUS_KEY);    <span class="comment">// 添加状态（聚焦）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、下拉列表部件"><a href="#九、下拉列表部件" class="headerlink" title="九、下拉列表部件"></a>九、下拉列表部件</h1><p><strong>按钮</strong></p><p><strong>列表</strong></p><ul><li><strong>创建下拉列表部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *dd = lv_dropdown_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置选项内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_set_options( dd, <span class="string">&quot;a\nb\nc\nd&quot;</span>);   <span class="comment">/* 设置选项 */</span></span><br><span class="line">lv_dropdown_set_options_static( dd, <span class="string">&quot;a\nb\nc\nd &quot;</span>);<span class="comment">/* 设置选项 （静态）*/</span></span><br><span class="line">lv_dropdown_add_option( dd, <span class="string">&quot;e&quot;</span>, <span class="number">4</span>);<span class="comment">/* 添加选项，索引从0开始 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前所选项</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_set_selected( dd, <span class="number">1</span>);<span class="comment">/* 注意：索引从0开始 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取选项内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_get_selected( dd);<span class="comment">/* 获取索引 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">lv_dropdown_get_selected_str( dd, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">/* 获取选项文本</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置方向和图标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_dropdown_set_dir(dd, LV_DIR_RIGHT);<span class="comment">/* 设置列表展开方向 */</span></span><br><span class="line">lv_dropdown_set_symbol(dd, LV_SYMBOL_RIGHT);    <span class="comment">/* 设置图标 */</span></span><br></pre></td></tr></table></figure><h1 id="十、滚轮部件"><a href="#十、滚轮部件" class="headerlink" title="十、滚轮部件"></a>十、滚轮部件</h1><p><strong>常用于多选一的场景，它以滚轮的形式来展现多个选项</strong></p><p><strong>主体</strong></p><p><strong>选项框</strong></p><ul><li><strong>创建滚轮部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *roller= lv_roller_create( parent )；</span><br></pre></td></tr></table></figure><ul><li><strong>设置选项间隔</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_line_space(roller, <span class="number">30</span>, </span><br><span class="line">                          LV_STATE_DEFAULT);  <span class="comment">//选择器，什么状态下应用</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置选项内容、滚动模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_set_options(roller, “a\nb\nc\nd”, LV_ROLLER_MODE_NORMAL); <span class="comment">/* 正常模式 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前所选项</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_set_selected(roller, <span class="number">3</span>, LV_ANIM_ON);</span><br></pre></td></tr></table></figure><ul><li><strong>设置可见行数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_set_visible_row_count(roller, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>获取选项内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_roller_get_selected(roller);<span class="comment">/* 获取索引 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">lv_roller_get_selected_str(roller, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">/* 获取选项文</span></span><br></pre></td></tr></table></figure><h1 id="十一、滑块部件"><a href="#十一、滑块部件" class="headerlink" title="十一、滑块部件"></a>十一、滑块部件</h1><p><strong>常用于调节某个参数的值，它以直线滑动的形式来修改数值</strong></p><p><strong>主体</strong></p><p><strong>指示器</strong></p><p><strong>旋钮</strong></p><ul><li><strong>创建跨快部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *slider = lv_slider_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置大小、当前值、范围值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size(slider, <span class="number">20</span>, <span class="number">200</span>);<span class="comment">/* 高度&gt;宽度时，滑块为纵向 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_slider_get_value(slider);</span><br></pre></td></tr></table></figure><ul><li><strong>模式设置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_slider_set_mode(slider, LV_SLIDER_MODE_...);</span><br></pre></td></tr></table></figure><ul><li><strong>设置、获取左值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_slider_set_left_value(slider, <span class="number">20</span>, LV_ANIM_OFF);<span class="comment">/* 设置左值 */</span></span><br><span class="line">lv_slider_get_left_value(slider);<span class="comment">/* 获取左值 */</span></span><br></pre></td></tr></table></figure><h1 id="十二、圆弧部件"><a href="#十二、圆弧部件" class="headerlink" title="十二、圆弧部件"></a>十二、圆弧部件</h1><p><strong>以弧形滑动的形式来调节、显示某个参数的值</strong></p><p><strong>背景弧</strong></p><p><strong>前景弧</strong></p><p><strong>旋钮</strong></p><ul><li><strong>创建圆弧部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *arc = lv_arc_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置范围值、当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_value(arc, <span class="number">80</span>);<span class="comment">/* 设置当前值（需要在范围值之内）*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置圆弧角度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_angles(arc, <span class="number">135</span>, <span class="number">270</span>);<span class="comment">/* 设置前景弧角度 */</span></span><br><span class="line">lv_arc_set_bg_angles(arc, <span class="number">135</span>, <span class="number">45</span>);<span class="comment">/* 设置背景弧角度 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置旋转角度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_rotation(arc, <span class="number">180</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>获取当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_get_value(arc);</span><br></pre></td></tr></table></figure><ul><li><strong>设置模式、圆弧绘制速率</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_arc_set_mode(arc, LV_ARC_MODE_REVERSE);<span class="comment">/* 设置模式 */</span></span><br><span class="line">lv_arc_set_change_rate(arc, <span class="number">90</span>);<span class="comment">/* 绘制速率：90°/秒 */</span></span><br></pre></td></tr></table></figure><h1 id="十三-、线条部件"><a href="#十三-、线条部件" class="headerlink" title="十三 、线条部件"></a>十三 、线条部件</h1><p><strong>线条部件能够在一组坐标点之间依次绘制直线</strong></p><p><strong>主体</strong></p><ul><li><strong>创建线条部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>   *line = lv_line_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置线条坐标点</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">lv_point_t</span>  line_points[] = &#123; &#123;<span class="number">15</span>, <span class="number">5</span>&#125;, &#123;<span class="number">25</span>, <span class="number">20</span>&#125;, &#123;<span class="number">5</span>, <span class="number">20</span>&#125;, &#123;<span class="number">15</span>, <span class="number">5</span>&#125; &#125;;</span><br><span class="line">lv_line_set_points(line, line_points, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>设置线条样式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_line_width(line, <span class="number">8</span>, LV_PART_MAIN);           <span class="comment">/* 设置宽度 */</span></span><br><span class="line">lv_obj_set_style_line_rounded(line, <span class="literal">true</span>, LV_PART_MAIN);   <span class="comment">/* 设置圆角 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置Y轴翻转</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_line_set_y_invert(line, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h1 id="十四、图片部件"><a href="#十四、图片部件" class="headerlink" title="十四、图片部件"></a>十四、图片部件</h1><p><strong>用于图片显示、功能界面优化、背景优化等</strong></p><p><strong>主体</strong></p><ul><li><strong>创建图片部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *img = lv_img_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>设置图片源</strong><ul><li><strong>图片来源：C语言数组、Bin文件、LVGL内置字体图标</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LV_IMG_DECLARE(img_bird);<span class="comment">/* 声明图片 在函数外 */</span></span><br><span class="line">lv_img_set_src(img, &amp;img_bird);<span class="comment">/* 设置图片源 * /</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置图片偏移</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_img_set_offset_x(img, <span class="number">100</span>);<span class="comment">/* x轴偏移100 */</span></span><br><span class="line">lv_img_set_offset_y(img, <span class="number">20</span>); <span class="comment">/* y轴偏移20  */</span></span><br></pre></td></tr></table></figure><ul><li><strong>图片重新着色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_img_recolor(img, lv_color_hex(<span class="number">0xffe1d2</span>), LV_PART_MAIN);<span class="comment">/* 对图片进行蒙色*/</span></span><br><span class="line">lv_coloc_make(R,G,B); <span class="comment">// 获取RGB三通道的值</span></span><br><span class="line">lv_obj_set_style_img_recolor_opa(img, <span class="number">150</span>, LV_PART_MAIN);<span class="comment">/* 修该蒙色透明度 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置图片缩放、旋转</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_img_set_zoom(img, <span class="number">512</span>);<span class="comment">/* 放大2倍 ，原尺寸256 */</span></span><br><span class="line">lv_img_set_angle(img, <span class="number">900</span>);<span class="comment">/* 顺时针方向旋转90° */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>设置中心点</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_update_layout(img);<span class="comment">/* 更新图片布局信息 */</span></span><br><span class="line">lv_img_set_pivot(img, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">/* 设置中心点 ，中心点坐标是相对于原坐标来说的*/</span></span><br></pre></td></tr></table></figure><h1 id="十五、色环部件"><a href="#十五、色环部件" class="headerlink" title="十五、色环部件"></a>十五、色环部件</h1><p><strong>在UI设计中，色环部件一般用作颜色选择器</strong></p><ul><li><strong>创建色环部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *cw = lv_colorwheel_create( parent, </span><br><span class="line">                               knob_recolor ); <span class="comment">//手柄是否重新着色</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前选中的颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_colorwheel_set_rgb(cw, lv_color_hex(<span class="number">0xff0000</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>获取当前选中的颜色</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_colorwheel_get_rgb(cw);</span><br></pre></td></tr></table></figure><ul><li><strong>设置色环模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_colorwheel_set_mode(cw, LV_COLORWHEEL_MODE_HUE/SATURATION/VALUE); <span class="comment">/* 色相、饱和度、明度 */</span></span><br><span class="line">lv_colorwheel_set_mode_fixed(cw, <span class="literal">true</span>);<span class="comment">// 固定色环模式</span></span><br></pre></td></tr></table></figure><p><img src="/2024/09/25/LVGL-2-%E9%83%A8%E4%BB%B6%E9%83%A8%E5%88%86/image-20240928151156900-1727619652515-6.png" alt="image-20240928151156900"></p><h1 id="十六、按钮矩阵部件"><a href="#十六、按钮矩阵部件" class="headerlink" title="十六、按钮矩阵部件"></a>十六、按钮矩阵部件</h1><p><strong>可以在不同的行和列中显示多个轻量级按钮</strong></p><p><strong>主体</strong></p><p><strong>按钮</strong></p><ul><li><strong>创建按钮矩阵部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *btnm = lv_btnmatrix_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>设置按钮数量、文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="built_in">map</span>[] = &#123; <span class="string">&quot;btn1&quot;</span>, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;btn2&quot;</span>, <span class="string">&quot;btn3&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;<span class="comment">/* 定义按钮数组，最后一个元素必须为空 */</span></span><br><span class="line">lv_btnmatrix_set_map(btnm, <span class="built_in">map</span>);<span class="comment">/* 设置按钮 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置按钮相对高度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_set_btn_width(btnm, id, width);<span class="comment">/* 索引 (id) 从0开始，宽度1~7 ( 默认为1 ) */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取按钮索引、文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_get_selected_btn(btnm);<span class="comment">/* 获取索引 */</span></span><br><span class="line">lv_btnmatrix_get_btn_text(btnm, id);<span class="comment">/* 获取文本 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置、清除按钮属性</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_set_btn_ctrl(btnm, id, LV_BTNMATRIX_CTRL_...); <span class="comment">/* 设置单个按钮属性 */</span></span><br><span class="line">lv_btnmatrix_clear_btn_ctrl(btnm, id, LV_BTNMATRIX_CTRL_...); <span class="comment">/* 清除单个按钮属性 */</span></span><br><span class="line">lv_btnmatrix_set_btn_ctrl_all(btnm, LV_BTNMATRIX_CTRL_...);  <span class="comment">/* 设置所有按钮属性 */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_HIDDEN, <span class="comment">/* 隐藏 */</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_DISABLED,<span class="comment">/* 失能 */</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_CHECKABLE, <span class="comment">/* 允许状态切换 */</span></span><br><span class="line">    LV_BTNMATRIX_CTRL_RECOLOR, <span class="comment">/* 允许文本重新着色 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>设置单次选中属性</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_btnmatrix_set_one_checked(btnm, <span class="literal">true</span>);  <span class="comment">/* 注意：需要先设置允许状态切换属性 */</span></span><br></pre></td></tr></table></figure><h1 id="十七、文本区域部件"><a href="#十七、文本区域部件" class="headerlink" title="十七、文本区域部件"></a>十七、文本区域部件</h1><p><strong>即文本输入框，用户可以在其中输入文本内容</strong></p><p><strong>主体</strong></p><p><strong>滚动条</strong></p><p><strong>所选文本</strong></p><p><strong>光标</strong></p><p><strong>占位符</strong></p><ul><li><strong>创建文本去部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *ta = lv_textarea_create(parent);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>添加文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_add_char(ta, <span class="string">&#x27;A&#x27;</span>);<span class="comment">/* 添加一个字符到当前光标处 */</span></span><br><span class="line">lv_textarea_add_text(ta, <span class="string">&quot;BCDEF&quot;</span>); <span class="comment">/* 添加字符串到当前光标处 */</span></span><br><span class="line"><span class="type">lv_obj_t</span> *keyboard = lv_keyboard_create(lv_scr_act());<span class="comment">/* 创建键盘部件 */</span></span><br><span class="line">lv_keyboard_set_textarea(keyboard, ta);<span class="comment">/* 关联键盘和文本区域部件 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置光标位置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_cursor_pos(ta, <span class="number">0</span>);<span class="comment">/* 0：最左侧，  LV_TEXTAREA_CURSOR_LAST：最右侧 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>删除文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_del_char(ta);<span class="comment">/* 删除光标左侧的一个字符 */</span></span><br><span class="line">lv_textarea_del_char_forward(ta);<span class="comment">/* 删除光标右侧的一个字符 </span></span><br></pre></td></tr></table></figure><ul><li><strong>设置模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_one_line(ta, <span class="literal">true</span>);<span class="comment">/* 单行模式 */</span></span><br><span class="line">lv_textarea_set_password_mode(ta, <span class="literal">true</span>);<span class="comment">/* 密码模式（隐藏输入的内容） */</span></span><br></pre></td></tr></table></figure><ul><li><strong>限制字符输入</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_accepted_chars(ta,<span class="string">&quot;0123456789&quot;</span>);<span class="comment">/* 限制接收的字符 */</span></span><br><span class="line">lv_textarea_set_max_length(ta,<span class="number">6</span>); <span class="comment">/* 限制字符长度 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置占位符</strong>(提示文本)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_textarea_set_placeholder_text(ta, <span class="string">&quot;password&quot;</span>); <span class="comment">/* 提示输入密码 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *txt = lv_textarea_get_text(ta); <span class="comment">/* 获取文本框文本 */</span> </span><br></pre></td></tr></table></figure><ul><li><strong>比对文本内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(<span class="type">const</span> <span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2);<span class="comment">/* 当s1=s2时，返回0 */</span></span><br></pre></td></tr></table></figure><h1 id="十八、键盘部件"><a href="#十八、键盘部件" class="headerlink" title="十八、键盘部件"></a>十八、键盘部件</h1><p><strong>可用于输入文本内容，其本质上就是一个特殊的按钮矩阵</strong></p><p><strong>主体</strong></p><p><strong>按钮</strong></p><ul><li><strong>创建键盘部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *kb = lv_keyboard_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>关联文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *ta = lv_textarea_create(lv_scr_act());<span class="comment">/* 创建文本区域部件 */</span></span><br><span class="line">lv_keyboard_set_textarea(kb, ta);<span class="comment">/* 关联键盘和文本区域部件</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置按键弹窗</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_keyboard_set_popovers(kb, <span class="literal">true</span>);<span class="comment">/* 允许按键弹窗提示 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置键盘模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_keyboard_set_mode(kb, LV_KEYBOARD_MODE_NUMBER);<span class="comment">/* 数字键盘模式 */</span></span><br></pre></td></tr></table></figure><h1 id="十九、图片按钮部件"><a href="#十九、图片按钮部件" class="headerlink" title="十九、图片按钮部件"></a>十九、图片按钮部件</h1><p><strong>类似于按钮部件，不同的是，用户可以在其中设置图片</strong></p><p><strong>主体</strong></p><ul><li><strong>创建图片按钮部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_keyboard_set_mode(kb, LV_KEYBOARD_MODE_NUMBER);<span class="comment">/* 数字键盘模式 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置图片源、按钮大小</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_imgbtn_set_src(imgbtn, LV_IMGBTN_STATE_..., src_left, src_mid, src_right);<span class="comment">/* 设置某个状态的图片源 */</span></span><br><span class="line">lv_obj_set_size(imgbtn, <span class="number">64</span> * <span class="number">3</span>, <span class="number">64</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>设置按钮状态</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_imgbtn_set_state(imgbtn, LV_IMGBTN_STATE_PRESSED);<span class="comment">/* 设置按下状态 */</span></span><br></pre></td></tr></table></figure><h1 id="二十、选项卡部件"><a href="#二十、选项卡部件" class="headerlink" title="二十、选项卡部件"></a>二十、选项卡部件</h1><p><strong>主体</strong></p><p><strong>按钮</strong></p><ul><li><strong>创建选项卡部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *tabview =  lv_tabview_create(parent, LV_DIR_..., tab_size);</span><br></pre></td></tr></table></figure><ul><li><strong>添加选项卡</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *tab1 = lv_tabview_add_tab(tabview, <span class="string">&quot;Tab 1&quot;</span>); </span><br><span class="line"><span class="type">lv_obj_t</span> *tab2 = lv_tabview_add_tab(tabview, <span class="string">&quot;Tab 2&quot;</span>); </span><br></pre></td></tr></table></figure><ul><li><strong>设置当前选中的选项卡</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_tabview_set_act(tabview, <span class="number">1</span>, LV_ANIM_OFF); <span class="comment">/* 索引从0开始 */</span></span><br></pre></td></tr></table></figure><h1 id="二十一、平铺视图部件"><a href="#二十一、平铺视图部件" class="headerlink" title="二十一、平铺视图部件"></a>二十一、平铺视图部件</h1><p><strong>可以实现不同方向的页面切换，用户可以在页面中添加内容</strong></p><p><strong>主体</strong></p><p><strong>滚动条</strong></p><ul><li><strong>创建平铺视图部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>  *tileview = lv_tileview_create( parent );</span><br></pre></td></tr></table></figure><ul><li><strong>添加页面</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *tile1 = lv_tileview_add_tile( tileview, <span class="number">0</span>, <span class="number">0</span>, LV_DIR_RIGHT );</span><br><span class="line"><span class="type">lv_obj_t</span> *tile2 = lv_tileview_add_tile( tileview, <span class="number">1</span>, <span class="number">0</span>, LV_DIR_LEFT );</span><br></pre></td></tr></table></figure><ul><li><strong>设置当前显示页面</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_update_layout( tileview );<span class="comment">/* 更新参数 */</span></span><br><span class="line">lv_obj_set_tile( tileview, tile2, LV_ANIM_OFF );<span class="comment">/* 根据页面对象设置 */</span></span><br><span class="line">lv_obj_set_tile_id( tileview, <span class="number">1</span>, <span class="number">0</span>, LV_ANIM_OFF );<span class="comment">/* 根据页面行列设置 */</span></span><br></pre></td></tr></table></figure><h1 id="二十二、窗口部件"><a href="#二十二、窗口部件" class="headerlink" title="二十二、窗口部件"></a>二十二、窗口部件</h1><p><strong>可以作为一个容器，展示不同功能的页面</strong></p><ul><li><strong>创建窗口部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *win = lv_win_create(parent, header_height);</span><br></pre></td></tr></table></figure><ul><li><strong>添加标题、按钮</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *title = lv_win_add_title(win, <span class="string">&quot;Setting&quot;</span>);</span><br><span class="line"><span class="type">lv_obj_t</span> *btn = lv_win_add_btn(win, LV_SYMBOL_CLOSE, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>添加主体内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *content = lv_win_get_content(win); <span class="comment">/* 获取主体 */</span></span><br><span class="line"><span class="type">lv_obj_t</span> *label = lv_label_create(content);<span class="comment">/* 添加内容 */</span></span><br></pre></td></tr></table></figure><h1 id="二十三、消息框部件"><a href="#二十三、消息框部件" class="headerlink" title="二十三、消息框部件"></a>二十三、消息框部件</h1><p><strong>消息框部件可以实现弹窗提示，常用于消息通知、确定操作等</strong></p><p><strong>主体</strong></p><p><strong>标题</strong></p><p><strong>关闭按钮</strong></p><p><strong>按钮矩阵</strong></p><ul><li><strong>创建消息框部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *btns[] = &#123; <span class="string">&quot;Continue&quot;</span>, <span class="string">&quot;Close&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line"><span class="type">lv_obj_t</span> *msgbox = lv_msgbox_create( lv_scr_act(), <span class="string">&quot;Notice&quot;</span>, <span class="string">&quot;Do you want to continue?&quot;</span>, btns, <span class="literal">true</span> );</span><br><span class="line"><span class="comment">//   标题       主体文本                  按钮矩阵 关闭按钮</span></span><br></pre></td></tr></table></figure><ul><li><strong>关闭消息框</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_msgbox_close(msgbox);</span><br></pre></td></tr></table></figure><ul><li><strong>获取按钮索引、文本</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *target = lv_event_get_current_target(e);<span class="comment">/* 获取当前触发源 */</span></span><br><span class="line">lv_msgbox_get_active_btn(target);<span class="comment">/* 获取按钮索引 */</span></span><br><span class="line">lv_msgbox_get_active_btn_text(target);<span class="comment">/* 获取按钮文本 */</span></span><br></pre></td></tr></table></figure><h1 id="二十四、微调器部件"><a href="#二十四、微调器部件" class="headerlink" title="二十四、微调器部件"></a>二十四、微调器部件</h1><p><strong>微调器部件本质上就是一个数字文本，常用于精确调节某个参数的值</strong></p><p><strong>主体</strong></p><p><strong>光标</strong></p><ul><li><strong>创建微调器部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *spinbox = lv_spinbox_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>数值递增、递减</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_increment(spinbox);<span class="comment">/* 递增 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置步进值、范围值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_set_step(spinbox, <span class="number">200</span>);<span class="comment">/* 设置步进值，默认为1*/</span></span><br><span class="line">lv_spinbox_set_range(spinbox, <span class="number">-1000</span>, <span class="number">1000</span>);<span class="comment">/* 设置范围值，默认±99999*/</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_set_value(spinbox, <span class="number">400</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>设置数字格式、光标位置</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_set_digit_format(spinbox, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">/* 设置数字位数、小数点位置 */</span></span><br><span class="line">lv_spinbox_set_pos(spinbox, <span class="number">3</span>);<span class="comment">/* 设置光标位置 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>获取当前值</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_spinbox_get_value(spinbox); <span class="comment">/* 返回值为整数，而非小数 */</span></span><br></pre></td></tr></table></figure><h1 id="二十五、表格部件"><a href="#二十五、表格部件" class="headerlink" title="二十五、表格部件"></a>二十五、表格部件</h1><p><strong>有一个个单元格组成，它的单元格中只能存放文本形式的内容</strong></p><p><strong>主体</strong></p><p><strong>单元格</strong></p><ul><li><strong>创建表格部件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *table = lv_table_create(parent);</span><br></pre></td></tr></table></figure><ul><li><strong>设置行数、列数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_table_set_row_cnt(table,<span class="number">2</span>); <span class="comment">/* 设置行数 */</span></span><br><span class="line">lv_table_set_col_cnt(table,<span class="number">2</span>); <span class="comment">/* 设置列数 */</span></span><br></pre></td></tr></table></figure><ul><li><strong>设置单元格的内容</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_table_set_cell_value(table, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">lv_table_set_cell_value_fmt(table, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;%d&quot;</span>, <span class="number">100</span> );<span class="comment">/* 格式化输入，类似printf */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、标签部件&quot;&gt;&lt;a href=&quot;#一、标签部件&quot; class=&quot;headerlink&quot; title=&quot;一、标签部件&quot;&gt;&lt;/a&gt;一、标签部件&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;主体   滚动条   选中的文本&lt;/strong&gt;    &lt;/p&gt;
&lt;h2 id=&quot;1-创建</summary>
      
    
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/categories/LVGL/"/>
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/tags/LVGL/"/>
    
  </entry>
  
  <entry>
    <title>LVGL(一)基础对象</title>
    <link href="https://ydw-item.github.io.git/2024/09/22/LVGL-1-%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1/"/>
    <id>https://ydw-item.github.io.git/2024/09/22/LVGL-1-%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1/</id>
    <published>2024-09-21T16:00:19.000Z</published>
    <updated>2024-09-21T16:18:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、创建对象"><a href="#一、创建对象" class="headerlink" title="一、创建对象"></a>一、创建对象</h1><ul><li><strong>在屏幕上创建开关部件switch</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>* switch1 = lv_switch_create(lv_scr_act());</span><br></pre></td></tr></table></figure><ul><li><strong>在按键switch1上创建开关部件switch2</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span>* switch2 = lv_switch_create(switch1);</span><br></pre></td></tr></table></figure><h1 id="二、设置大小"><a href="#二、设置大小" class="headerlink" title="二、设置大小"></a>二、设置大小</h1><ul><li><strong>设置宽度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_width(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> width);</span><br></pre></td></tr></table></figure><ul><li><strong>设置高度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_height(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> height);</span><br></pre></td></tr></table></figure><ul><li><strong>同时设置宽度和高度</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_size(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> width, <span class="type">lv_coord_t</span> height);</span><br></pre></td></tr></table></figure><h1 id="三、设置位置"><a href="#三、设置位置" class="headerlink" title="三、设置位置"></a>三、设置位置</h1><ul><li><strong>原点为(0,0)，X轴向右，Y轴向下</strong></li><li><strong>若屏幕像素为800*480，则原点的对点为(799,470)</strong></li><li><strong>子类以父类的左上角为原点，超出父对象的区域不显示</strong></li><li><strong>设置X轴坐标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_x(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> x);</span><br></pre></td></tr></table></figure><ul><li><strong>设置Y轴坐标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_y(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> y);</span><br></pre></td></tr></table></figure><ul><li><strong>同时设置X、Y轴坐标</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_pos(<span class="type">lv_obj_t</span> * obj, <span class="type">lv_coord_t</span> x, <span class="type">lv_coord_t</span> y);</span><br></pre></td></tr></table></figure><h1 id="四、设置对齐方式"><a href="#四、设置对齐方式" class="headerlink" title="四、设置对齐方式"></a>四、设置对齐方式</h1><h2 id="1-参照父对象对齐"><a href="#1-参照父对象对齐" class="headerlink" title="1. 参照父对象对齐"></a>1. 参照父对象对齐</h2><ul><li>参照父对象对齐</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_align(<span class="type">lv_obj_t</span> * obj, <span class="comment">//子对象</span></span><br><span class="line">                 <span class="type">lv_align_t</span> align); <span class="comment">//对齐模式 LV_ALIGN_XXXX</span></span><br></pre></td></tr></table></figure><ul><li>参照父对象对齐，在进行偏移</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_align(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">           <span class="type">lv_align_t</span> align,    <span class="comment">//对齐模式 LV_ALIGN_XXXX</span></span><br><span class="line">           <span class="type">lv_coord_t</span> x_ofs,<span class="comment">//X轴偏移量</span></span><br><span class="line">           <span class="type">lv_coord_t</span> y_ofs);<span class="comment">//Y轴偏移量</span></span><br></pre></td></tr></table></figure><h2 id="2-参照其它对象对齐"><a href="#2-参照其它对象对齐" class="headerlink" title="2. 参照其它对象对齐"></a>2. 参照其它对象对齐</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_align_to(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">         <span class="type">const</span> <span class="type">lv_obj_t</span> * base,    <span class="comment">//参照对象</span></span><br><span class="line">              <span class="type">lv_align_t</span> align,    <span class="comment">//对齐模式 LV_ALIGN_XXXX</span></span><br><span class="line">              <span class="type">lv_coord_t</span> x_ofs,    <span class="comment">//X轴偏移量</span></span><br><span class="line">              <span class="type">lv_coord_t</span> y_ofs);   <span class="comment">//Y轴偏移量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-对齐模式"><a href="#3-对齐模式" class="headerlink" title="3. 对齐模式"></a>3. 对齐模式</h2><table><thead><tr><th align="center"></th><th align="center">OUT_TOP_LEFT</th><th align="center">OUT_TOP_MID</th><th align="center">OUT_TOP_RIGHT</th><th align="center"></th></tr></thead><tbody><tr><td align="center"><strong>OUT_LEFT_TOP</strong></td><td align="center"><strong>TOP_LEFT</strong></td><td align="center"><strong>TOP_MID</strong></td><td align="center"><strong>TOP_RIGHT</strong></td><td align="center"><strong>OUT_RIGHT_TOP</strong></td></tr><tr><td align="center"><strong>OUT_LEFT_MID</strong></td><td align="center"><strong>LEFT_MID</strong></td><td align="center"><strong>CENTER</strong></td><td align="center"><strong>RIGHT_MID</strong></td><td align="center"><strong>OUT_RIGHT_MID</strong></td></tr><tr><td align="center"><strong>OUT_LEFT_BOTTOM</strong></td><td align="center"><strong>BOTTOM_LEFT</strong></td><td align="center"><strong>BOTTOM_MID</strong></td><td align="center"><strong>BOTTOM_RIGHT</strong></td><td align="center"><strong>OUT_RIGHT_BOTTOM</strong></td></tr><tr><td align="center"></td><td align="center"><strong>OUT_BOTTOM_LEFT</strong></td><td align="center"><strong>OUT_BOTTOM_MID</strong></td><td align="center"><strong>OUT_BOTTOM_RIGHT</strong></td><td align="center"></td></tr></tbody></table><h1 id="五、设置样式"><a href="#五、设置样式" class="headerlink" title="五、设置样式"></a>五、设置样式</h1><ul><li><strong>样式用于设置部件的外观，以优化显示界面和实现用户交互</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">lv_style_t</span> style;<span class="comment">//定义样式变量</span></span><br><span class="line">lv_style_init(&amp;style);<span class="comment">//初始化样式</span></span><br><span class="line">lv_style_set_bg_color(&amp;style,lv_color_hex(<span class="number">0xf4183</span>));<span class="comment">//设置背景颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">lv_obj_t</span> *obj = lv_boj_create(lv_scr_act());  <span class="comment">//创建一个部件</span></span><br><span class="line">lv_obj_add_style(obj,&amp;style,LV_STATE_DEFAULT);<span class="comment">//设置部件的样式</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加本地样式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> *obj = lv_boj_create(lv_scr_act());<span class="comment">//创建一个部件</span></span><br><span class="line">lv_obj_set_style_bg_color(boj,  <span class="comment">//子对象</span></span><br><span class="line">       lv_color_hex(<span class="number">0xf4b183</span>),  <span class="comment">//设置颜色</span></span><br><span class="line">            LV_STATE_DEFAULT);<span class="comment">//样式何时生效</span></span><br></pre></td></tr></table></figure><h1 id="六、设置事件"><a href="#六、设置事件" class="headerlink" title="六、设置事件"></a>六、设置事件</h1><ul><li><strong>在LVGL中，当发生用户感兴趣的事情时，可以触发<u>回调事件</u>，以执行相关操作</strong></li><li><strong>添加事件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_add_event_cb(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">            <span class="type">lv_event_cb_t</span> event_cb,    <span class="comment">//事件回调函数，自己定义</span></span><br><span class="line">            <span class="type">lv_event_code_t</span> filter,    <span class="comment">//事件类型</span></span><br><span class="line">                  <span class="type">void</span> * user_data);   <span class="comment">//用户数据</span></span><br></pre></td></tr></table></figure><ul><li><strong>删除事件</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_remove_event_cb(<span class="type">lv_obj_t</span> * obj,    <span class="comment">//子对象</span></span><br><span class="line">               <span class="type">lv_event_cb_t</span> event_cb);   a<span class="comment">//事件回调函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>不同的事件类型共用同一个回调函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="type">lv_event_t</span>* e)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_event_code code = lv_event_get_code(e);<span class="comment">//获取事件类型</span></span><br><span class="line">    <span class="keyword">if</span>(code == LV_EVENT_CLICKED)     <span class="comment">//判断事件类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;事件类型，按下后释放\r\n&quot;</span>);  <span class="comment">//执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(code == LV_EVENT_LONG_PRESSED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;事件类型按下（长按）\r\n&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>不同的部件共用同一个回调函数</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_cb</span><span class="params">(<span class="type">lv_event_t</span>* e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> *target = lv_event_get_target(e);<span class="comment">//获取触发事件的部件</span></span><br><span class="line">    <span class="keyword">if</span>(target == target_obj)       <span class="comment">//判断触发事件的部件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;父对象触发事件\r\n&quot;</span>);      <span class="comment">//执行相应操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(target == child_obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子对象触发事件\r\n&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、创建对象&quot;&gt;&lt;a href=&quot;#一、创建对象&quot; class=&quot;headerlink&quot; title=&quot;一、创建对象&quot;&gt;&lt;/a&gt;一、创建对象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在屏幕上创建开关部件switch&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;fi</summary>
      
    
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/categories/LVGL/"/>
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/tags/LVGL/"/>
    
  </entry>
  
  <entry>
    <title>I2C通信协议</title>
    <link href="https://ydw-item.github.io.git/2024/09/21/I2C/"/>
    <id>https://ydw-item.github.io.git/2024/09/21/I2C/</id>
    <published>2024-09-20T16:59:49.000Z</published>
    <updated>2024-09-20T16:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、I2C协议简介"><a href="#一、I2C协议简介" class="headerlink" title="一、I2C协议简介"></a>一、I2C协议简介</h1><p>实验板：蓝桥杯嵌入式，STM32G4RBT6</p><ul><li>I2C是一种简单的<u>双向两线制</u>总线协议标准，支持<u>同步串行半双工</u>通讯。</li><li>SDA:双向串行数据总线，只能一位一位的发送数据。</li><li>SCL:串行时钟线，用于数据收发同步</li><li>半双工通信：可以实现双向的通信，但不能在两个方向上同时进行，必须交替进行，</li></ul><h1 id="二、I2C物理层"><a href="#二、I2C物理层" class="headerlink" title="二、I2C物理层"></a>二、I2C物理层</h1><h2 id="设备间的常用连接方式"><a href="#设备间的常用连接方式" class="headerlink" title="设备间的常用连接方式"></a>设备间的常用连接方式</h2><ul><li><strong>在一个I2C通信总线中，可以连接多个I2C通讯设备。支持多个通讯主机和多个通信从机。</strong></li></ul><p><img src="/2024/09/21/I2C/image-20240921013007221.png" alt="image-20240921013007221"></p><h1 id="三、I2C协议层"><a href="#三、I2C协议层" class="headerlink" title="三、I2C协议层"></a>三、I2C协议层</h1><p><strong><u>主机写数据到从机</u></strong></p><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\image-20240920154403849.png" alt="image-20240920154403849"><ul><li><strong>在I2C总线上，<u>每个设备的地址都是唯一的</u>，当主机广播的地址与某个设备地址相同时，设备会自动匹配，匹配成功后，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。</strong></li><li><strong>主机发送完数据，从机应答了，主机照样可以直接发送停止信号终止通讯。</strong></li><li><strong>从机地址可以是<u>7位</u>或者<u>10位</u>，在地址位之后，是读写的权限的选择位，0表示写权限，1表示读权限。</strong></li><li><strong>I2C规定，通信时的时钟，起始信号，停止信号<u>只能</u>由主机产生。</strong></li></ul><p><u><strong>主机从从机读取数据</strong></u></p><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\image-20240920160821303.png" alt="image-20240920160821303"><ul><li><strong>在接受到任何数据时，无论时主机还是从机，都要做出应答信号（我还要数据）或非应答信号（我不要数据了）</strong></li></ul><p><strong><u>读写数据混合格式</u></strong></p><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\8d6a0670-ca9e-473b-b625-d6da0fab7cee.png" alt="8d6a0670-ca9e-473b-b625-d6da0fab7cee"><ul><li><strong>第一次通讯是确定读写从机设备内部寄存器或存储器的地址</strong></li><li><strong>第二次则是<u>读或写</u>上一次确定内部寄存器或存储器的地址上面的数据。</strong></li></ul><h2 id="1-空闲状态"><a href="#1-空闲状态" class="headerlink" title="1. 空闲状态"></a>1. 空闲状态</h2><p><strong>I2C总线的SDA和SCL两条信号线<u>同时处于高电平</u>时，则为总线空闲状态，所有挂载在总线上的设备都输出高阻态（相当于断开与总线的连接），两条总线被上拉电阻的把电平拉高。</strong></p><h2 id="2-起始信号与停止信号"><a href="#2-起始信号与停止信号" class="headerlink" title="2. 起始信号与停止信号"></a>2. 起始信号与停止信号</h2><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\image-20240920180358340.png" alt="image-20240920180358340" style="zoom:80%;"><p><strong>起始信号：当SCL线在高电平期间 SDA 线<u>由高电平向低电平切换</u><br>停止信号：当SCL线在高电平期间 SDA 线<u>由低电平向高电平切换</u></strong></p><p><strong>传输数据：当SCL线在高电平期间SDA 线<u>电平状态保持不变</u></strong></p><p><u><em><strong>起始信号和停止信号只能由主机产生</strong></em></u></p><h2 id="3-数据有效性"><a href="#3-数据有效性" class="headerlink" title="3. 数据有效性"></a>3. 数据有效性</h2><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\021ca9d7-3767-4b9b-a25b-8905ab64172e.png" alt="021ca9d7-3767-4b9b-a25b-8905ab64172e" style="zoom:80%;"><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\image-20240920182422762.png" alt="image-20240920182422762" style="zoom:80%;"><ul><li><strong>SDA数据线在SCL的每个时钟周期（时钟脉冲）传输一位数据</strong></li><li><strong>SCL为高电平期间：SDA表示数据有效，此时SDA的电平要稳定，SDA的高低电平代表数据1或0</strong></li><li><strong>SCL为低电平时：SDA的数据无效，一般在这个时候SDA进行电平转化，为下次数据传输做准备</strong></li><li><strong>数据和地址进行传输时，&#x3D;&#x3D;先传输高位&#x3D;&#x3D;，每次传输的字节不受限制</strong></li></ul><h2 id="4-地址及数据方向"><a href="#4-地址及数据方向" class="headerlink" title="4. 地址及数据方向"></a>4. 地址及数据方向</h2><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\image-20240920190314548.png" alt="image-20240920190314548"><ul><li><strong>读数据方向时，主机会&#x3D;&#x3D;释放对 SDA 信号线的控制&#x3D;&#x3D;，由&#x3D;&#x3D;从机控制 SDA 信号线&#x3D;&#x3D;（向主机发送数据），主机接收信号</strong></li><li><strong>写数据方向时，SDA 由主机控制（向从机发送数据），从机接收信号</strong></li></ul><h2 id="5-应答和非应答信号"><a href="#5-应答和非应答信号" class="headerlink" title="5. 应答和非应答信号"></a>5. 应答和非应答信号</h2><p><strong>I2C 的数据和地址传输都带响应当数据接收端(无论主从机)接收到 I2C 传输的一个字节数据或地址后：</strong></p><ul><li><p><strong>若希望对方继续发送数据，则向对方发送“应答(ACK)”信号(低电平)</strong></p></li><li><p><strong>若希望对方结束数据传输，则向对方发送“非应答(NACK)”信号(高电平)发送方接收到该信号后会产生一个停止信号，结束信号传输。</strong></p></li><li><p><strong>在一个字节传输的8个时钟后的第9个时钟期间，接收器必须回送一个应答位(ACK)或者是非应答位(NACK)给发送器  。</strong></p></li><li><p><strong>在第 9 个时钟时，数据发送端会释放 SDA 的控制权，由数据接收端控制 SDA，给发送端传输应答或非应答信号</strong></p></li></ul><img src="/2024/09/21/I2C/blog\myblog\source\_posts\I2C\5a15817b-bf12-4c4d-b3cd-c0ad501b5e5e.png" alt="5a15817b-bf12-4c4d-b3cd-c0ad501b5e5e"><p><img src="/2024/09/21/I2C/blog\myblog\source_posts\I2C\image-20240920222354354.png" alt="image-20240920222354354"></p><h2 id="6-写入一个字节时序"><a href="#6-写入一个字节时序" class="headerlink" title="6. 写入一个字节时序"></a>6. 写入一个字节时序</h2><p><img src="/2024/09/21/I2C/blog\myblog\source_posts\I2C\image-20240920222442639.png" alt="image-20240920222442639"></p><h2 id="7-读出一个字节时序"><a href="#7-读出一个字节时序" class="headerlink" title="7. 读出一个字节时序"></a>7. 读出一个字节时序</h2><p><img src="/2024/09/21/I2C/blog\myblog\source_posts\I2C\image-20240920222451423.png" alt="image-20240920222451423"></p><h2 id="8-单次写入多个字节时序"><a href="#8-单次写入多个字节时序" class="headerlink" title="8. 单次写入多个字节时序"></a>8. 单次写入多个字节时序</h2><p><img src="/2024/09/21/I2C/blog\myblog\source_posts\I2C\image-20240920222600643.png" alt="image-20240920222600643"></p><h2 id="9-单次读出多个字节时序"><a href="#9-单次读出多个字节时序" class="headerlink" title="9. 单次读出多个字节时序"></a>9. 单次读出多个字节时序</h2><p><img src="/2024/09/21/I2C/image-20240920222553835.png" alt="image-20240920222553835"></p><h1 id="四、-实验"><a href="#四、-实验" class="headerlink" title="四、 实验"></a>四、 实验</h1><p><strong>实验：使用STM32F103C8T6作实验平台,将数据写入AT24C0，并读取出来</strong></p><h2 id="1-Driver-i2c-h"><a href="#1-Driver-i2c-h" class="headerlink" title="1. Driver_i2c.h"></a>1. Driver_i2c.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DRIVER_IIC_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DRIVER_IIC_H </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NACK 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_HIGH (GPIOB-&gt;ODR |= GPIO_ODR_ODR10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_LOW  (GPIOB-&gt;ODR &amp;= ~GPIO_ODR_ODR10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_HIGH (GPIOB-&gt;ODR |= GPIO_ODR_ODR11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_LOW (GPIOB-&gt;ODR &amp;= ~GPIO_ODR_ODR11)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_SDA (GPIOB-&gt;IDR &amp; GPIO_IDR_IDR11)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 引脚初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_Start</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 停止信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C2_Stop</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 应答信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_Ack</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 非应答信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_NAck</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 等待接收方的应答 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Driver_I2C2_WaitAck</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送一个字节的数据 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Driver_I2C_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> byte)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接收一个字节的数据 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Driver_I2C_ReadByte</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-Driver-i2c-c"><a href="#2-Driver-i2c-c" class="headerlink" title="2. Driver_i2c.c"></a>2. Driver_i2c.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-main-c"><a href="#3-main-c" class="headerlink" title="3. main.c"></a>3. main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/09/21/I2C/image-20240921013215257.png" alt="image-20240921013215257"></p><p><img src="/2024/09/21/I2C/image-20240921013424465.png" alt="image-20240921013424465"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、I2C协议简介&quot;&gt;&lt;a href=&quot;#一、I2C协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、I2C协议简介&quot;&gt;&lt;/a&gt;一、I2C协议简介&lt;/h1&gt;&lt;p&gt;实验板：蓝桥杯嵌入式，STM32G4RBT6&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I2C是一种</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="通信协议" scheme="https://ydw-item.github.io.git/categories/STM32/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="通讯协议" scheme="https://ydw-item.github.io.git/tags/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="I2C" scheme="https://ydw-item.github.io.git/tags/I2C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ydw-item.github.io.git/2024/09/14/hello-world/"/>
    <id>https://ydw-item.github.io.git/2024/09/14/hello-world/</id>
    <published>2024-09-14T09:11:25.674Z</published>
    <updated>2024-09-14T09:11:25.674Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
