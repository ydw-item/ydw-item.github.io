<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The personal blog of DWen_666</title>
  
  <subtitle>姚道文</subtitle>
  <link href="https://ydw-item.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://ydw-item.github.io.git/"/>
  <updated>2025-05-11T15:58:30.000Z</updated>
  <id>https://ydw-item.github.io.git/</id>
  
  <author>
    <name>DWen_666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SPI通信协议</title>
    <link href="https://ydw-item.github.io.git/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/"/>
    <id>https://ydw-item.github.io.git/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/</id>
    <published>2025-05-11T15:58:30.000Z</published>
    <updated>2025-05-11T15:58:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考资料</strong>：</p><p><a href="https://blog.csdn.net/chenyuanlidejiyi/article/details/121639160">笔记之STM32F0芯片SPI_DMA的使用（HAL库）_stm32 spi dma-CSDN博客</a></p><h1 id="一、SPI简介"><a href="#一、SPI简介" class="headerlink" title="一、SPI简介"></a>一、SPI简介</h1><p><strong>SPI</strong>英文全称Serial Peripheral Interface，即串行外围设备接口，是一种高速、<strong>全双工</strong>、<strong>同步</strong>的<strong>串行</strong>通信总线。</p><h1 id="二、-信号线"><a href="#二、-信号线" class="headerlink" title="二、 信号线"></a>二、 信号线</h1><ul><li><strong>SCK</strong>（Serial Clock）：串行<strong>时钟线</strong>，由主设备产生，用于同步数据传输。</li><li><strong>MOSI</strong>（Master Output Slave Input）：<strong>主机输出</strong>从机输入线，主设备通过这条线发送数据给从设备。</li><li><strong>MISO</strong>（Master Input Slave Output）：<strong>主机输入</strong>从机输出线，主设备通过这条线接收从设备发送的数据。</li><li><strong>CS</strong>（Slave Select）(NSS或SS)：<strong>从机选择线</strong>（每个从机一根选择线），用于选择与主设备进行通信的从设备。通常情况下，SS线为<strong>低电平有效</strong>，即当<strong>SS</strong>线为<strong>低电平</strong>时，<strong>选中对应的从设备进行通信</strong>。</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/5.png" alt="image-20250511102329794"></p><h1 id="三、-开始与结束"><a href="#三、-开始与结束" class="headerlink" title="三、 开始与结束"></a>三、 开始与结束</h1><p>当SS从高电平拉低到<strong>低电平</strong>，这个算是<strong>起始</strong>的一个时序。而SS从低电平拉高到<strong>高电平</strong>，就算是结束的时序。</p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/1.png" alt="img"></p><h2 id="1-4-发送和接收字节"><a href="#1-4-发送和接收字节" class="headerlink" title="1.4 发送和接收字节"></a>1.4 发送和接收字节</h2><p>发送接收字节看似是两个时序，但是在SPI中却是<strong>同一个时序</strong>，因为SPI的机制是&#x3D;&#x3D;我们发送一个字节，并且接收一个字节&#x3D;&#x3D;（<strong>哪怕我们并不需要接收数据</strong>）。反过来看也可以是我们接收一个字节，并且发送一个字节（<strong>哪怕这个字节是无用的数据</strong>）。</p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/6.png" alt="image-20250511102607470"></p><ul><li>来一个时钟<strong>上升沿</strong>信号，主机和从机分别把自己<strong>高位</strong>的值左移出来(<strong>一般高位先行</strong>)</li><li>来一个时钟<strong>下降沿</strong>信号，主机和从机分别<strong>读入</strong>数据，存储到移位寄存器的低位</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/2.png" alt="img"></p><h2 id="交换bit"><a href="#交换bit" class="headerlink" title="交换bit"></a>交换bit</h2><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/3.png" alt="img"></p><p><strong>在SCK上升沿的时候，移出MOSI的数据，在SCK下降沿的时候读取MISO的数据。</strong></p><p><strong>需要在SCK上升沿之前把需要发送的数据位放置在MOSI线上</strong></p><p><strong>SCK下降沿的时候马上读取MISO线上的数据位</strong></p><p><strong>（实际上下降沿和读取应该是同时的，但是我们软件模拟没法同时，但是效果是一样的）</strong></p><h2 id="1-6-不同模式下的通信"><a href="#1-6-不同模式下的通信" class="headerlink" title="1.6 不同模式下的通信"></a>1.6 不同模式下的通信</h2><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/9.png" alt="image-20250305141745720"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/10.png" alt="image-20250305141814533"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/8.png" alt="image-20250305141718015"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/7.png" alt="image-20250305141639698"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/11.png" alt="image-20250305141859718"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/12.png" alt="image-20250305142011451"></p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/13.png" alt="image-20250305142031698"></p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><h2 id="时钟的极性和相位"><a href="#时钟的极性和相位" class="headerlink" title="时钟的极性和相位"></a>时钟的极性和相位</h2><h3 id="1-时钟的极性-CPOL"><a href="#1-时钟的极性-CPOL" class="headerlink" title="1.时钟的极性(CPOL)"></a>1.时钟的极性(CPOL)</h3><p>什么时候读数据(数据采集)和设置的<strong>时钟和相位</strong>有关</p><p>通信的整个过程分为空闲时刻和通信时刻</p><p>模式1：SCK上升沿的时候，移出MOSI的数据，在SCK下降沿的时候读取MISO数据</p><ul><li>空闲状态SCLK是低电平，CPOL&#x3D;0</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511103646951.png" alt="image-20250511103646951"></p><ul><li>空闲状态SCLK是高电平，CPOL&#x3D;1</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511103726353.png" alt="image-20250511103726353"></p><h3 id="2-时钟的相位-CPHA"><a href="#2-时钟的相位-CPHA" class="headerlink" title="2.时钟的相位(CPHA)"></a>2.时钟的相位(CPHA)</h3><p>直接决定SPI总线从那个跳变沿开始采样数据</p><ul><li>CPHA&#x3D;0：表示从第一个跳变沿开始采样</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104059236.png" alt="image-20250511104059236"></p><ul><li>CPHA&#x3D;1：表示从第二个跳变沿开始采样</li></ul><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104044786.png" alt="image-20250511104044786"></p><h3 id="3-SPI的4种模式"><a href="#3-SPI的4种模式" class="headerlink" title="3.SPI的4种模式"></a>3.SPI的4种模式</h3><p>时钟的两种极性和2种相位的不同组合，得到了SPI的4种工作模式</p><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104312629.png" alt="image-20250511104312629"></p><h4 id="3-1-模式0和模式2"><a href="#3-1-模式0和模式2" class="headerlink" title="3.1 模式0和模式2"></a>3.1 模式0和模式2</h4><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104947143.png" alt="image-20250511104947143"></p><h4 id="3-2-模式1和模式3"><a href="#3-2-模式1和模式3" class="headerlink" title="3.2 模式1和模式3"></a>3.2 模式1和模式3</h4><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250511104902672.png" alt="image-20250511104902672"></p><h1 id="三、硬件SPI"><a href="#三、硬件SPI" class="headerlink" title="三、硬件SPI"></a>三、硬件SPI</h1><p><img src="/2025/05/11/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/SPI/image-20250512125536962.png" alt="image-20250512125536962"></p><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><h3 id="3-1-1-SPI-HandleTypeDef"><a href="#3-1-1-SPI-HandleTypeDef" class="headerlink" title="3.1.1 SPI_HandleTypeDef"></a>3.1.1 SPI_HandleTypeDef</h3><h4 id="SPI-InitTypeDef"><a href="#SPI-InitTypeDef" class="headerlink" title="SPI_InitTypeDef"></a>SPI_InitTypeDef</h4><ul><li><p><strong>Mode</strong>：指定 SPI 工作模式</p><ul><li><code>SPI_MODE_SLAVE</code>：从模式</li><li><code>SPI_MODE_MASTER</code>：主模式</li></ul></li><li><p><strong>Direction</strong>：指定 SPI 双向模式状态</p><ul><li><code>SPI_DIRECTION_2LINES</code>：同时支持数据的发送和接收</li><li><code>SPI_DIRECTION_2LINES_RXONLY</code>：SPI只接收数据</li><li><code>SPI_DIRECTION_1LINE</code>：SPI只使用一条数据线进行双向数据传输</li></ul></li><li><p><strong>DataSize</strong>：指定 SPI 数据大小</p><ul><li><code>SPI_DATASIZE_8BIT</code>：8位</li><li><code>SPI_DATASIZE_16BIT</code>：16位</li></ul></li><li><p><strong>CLKPolarity</strong>：指定时钟极性（空闲状态时时钟的电平）</p><ul><li><code>SPI_POLARITY_LOW</code>：空闲时低电平</li><li><code>SPI_POLARITY_HIGH</code>：空闲时高电平</li></ul></li><li><p><strong>CLKPhase</strong>：指定时钟相位（数据采样的边沿）</p><ul><li><code>SPI_PHASE_1EDGE</code>：第一个时钟边沿采样</li><li><code>SPI_PHASE_2EDGE</code>：第二个时钟边沿采样</li></ul></li><li><p><strong>NSS</strong>：指定片选信号(NSS)的管理方式</p><ul><li><code>SPI_NSS_SOFT</code>：软件管理模式</li><li><code>SPI_NSS_HARD_INPUT</code>：硬件输入模式</li><li><code>SPI_NSS_HARD_OUTPUT</code>：硬件输出模式</li></ul></li><li><p><strong>BaudRatePrescaler</strong>：指定波特率预分频值</p><ul><li><code>SPI_BAUDRATEPRESCALER_2</code>：</li><li><code>SPI_BAUDRATEPRESCALER_4</code>：</li><li><code>SPI_BAUDRATEPRESCALER_8</code>：</li><li><code>SPI_BAUDRATEPRESCALER_16</code>：</li><li><code>SPI_BAUDRATEPRESCALER_32</code>：</li><li><code>SPI_BAUDRATEPRESCALER_64</code>：</li><li><code>SPI_BAUDRATEPRESCALER_128</code>：</li><li><code>SPI_BAUDRATEPRESCALER_256</code>：</li></ul></li><li><p><strong>FirstBit</strong>：指定数据传输时的字节顺序</p><ul><li><code>SPI_FIRSTBIT_MSB</code>：最先发送高位</li><li><code>SPI_FIRSTBIT_LSB</code>：最先发送低位</li></ul></li><li><p><strong>TIMode</strong>：用于控制SPI的三态模式(是否能进入高阻态)</p><ul><li><code>SPI_TIMODE_DISABLE</code>：禁用三态模式</li><li><code>SPI_TIMODE_ENABLE</code>：启用三态模式</li></ul></li><li><p><strong>CRCCalculation</strong>：控制是否启用CRC</p><ul><li><code>SPI_CRCCALCULATION_DISABLE</code>：禁用CRC计算</li><li><code>SPI_CRCCALCULATION_ENABLE</code>：启用CRC计算</li></ul></li><li><p><strong>CRCPolynomial</strong>：an odd number between Min_Data &#x3D; 1 and Max_Data &#x3D; 65535</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出"><a href="#1-硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出" class="headerlink" title="1. 硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出?"></a>1. 硬件SPI的MISO引脚配置成浮空输入还是复用推挽输出?</h2><p>​当一个<a href="https://so.csdn.net/so/search?q=GPIO&spm=1001.2101.3001.7020">GPIO</a>端口配置为GPIO_Mode_AF_PP时，片上外设的复用功能输出信号会连接到输出控制电路，然后在端口上产生输出信号。但是在芯片内部，MISO是SPI模块的输入引脚，而不是输出引脚，也就是说“复用功能输出信号”根本不存在，所以”输出控制电路”就不能对外部产生输出信号，然而即使在复用推挽输出模式下，复用功能输入信号却与外部引脚之间相互连接，既MISO得到了外部信号的电平，实现了输入的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chenyuanlidejiyi/article/details/121639160&quot;&gt;笔记之STM32F0芯片SPI_DMA的使用（HAL库）_stm</summary>
      
    
    
    
    <category term="SPI" scheme="https://ydw-item.github.io.git/categories/SPI/"/>
    
    <category term="通信协议" scheme="https://ydw-item.github.io.git/categories/SPI/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="通讯协议" scheme="https://ydw-item.github.io.git/tags/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="SPI" scheme="https://ydw-item.github.io.git/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>USART通信</title>
    <link href="https://ydw-item.github.io.git/2025/04/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/USART/"/>
    <id>https://ydw-item.github.io.git/2025/04/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/USART/</id>
    <published>2025-04-28T07:29:30.000Z</published>
    <updated>2025-04-28T07:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Usart-Init"><a href="#一、Usart-Init" class="headerlink" title="一、Usart_Init"></a>一、Usart_Init</h1><h2 id="1-1-UART-HandleTypeDef"><a href="#1-1-UART-HandleTypeDef" class="headerlink" title="1.1 UART_HandleTypeDef"></a>1.1 UART_HandleTypeDef</h2><ul><li><strong>Instance</strong>： UART 外设的寄存器基地址</li><li><strong>Init</strong>：UART 配置参数</li><li><strong>pTxBuffPtr</strong>：指向 UART 发送缓冲区的指针</li><li><strong>TxXferSize</strong>：UART 发送缓冲区的大小</li><li><strong>TxXferCount</strong>：UART 发送传输计数器</li><li><strong>pRxBuffPtr</strong>：指向 UART 接收缓冲区的指针</li><li><strong>RxXferSize</strong>：UART 接收缓冲区的大小</li><li><strong>RxXferCount</strong>：UART 接收传输计数器</li><li><strong>ReceptionType</strong>：正在进行的接收类型</li><li><strong>RxEventType</strong>：接收事件类型</li><li><strong>hdmatx</strong>：UART 发送 DMA 句柄</li><li><strong>hdmarx</strong>：UART 接收 DMA 句柄</li><li><strong>Lock</strong>：锁对象，用于管理 UART 的并发访问</li><li><strong>gState</strong>：UART 全局句柄的当前状态</li><li><strong>RxState</strong>：与接收操作相关的 UART 状态信息</li><li><strong>ErrorCode</strong>：UART 错误代码</li></ul><h2 id="1-2-UART-InitTypeDef"><a href="#1-2-UART-InitTypeDef" class="headerlink" title="1.2 UART_InitTypeDef"></a>1.2 UART_InitTypeDef</h2><ul><li><strong>Init.BaudRate</strong>：UART 通信的波特率</li></ul><p>​<code>9600</code></p><p>​<code>115200</code></p><p>​<code>921600</code></p><ul><li><p><strong>Init.WordLength</strong>：指定数据帧中传输或接收的数据位数</p><p>  <code>UART_WORDLENGTH_8B</code> </p><p>  <code>UART_WORDLENGTH_9B</code></p></li><li><p><strong>Init.StopBits</strong>：指定传输的停止位数量</p></li></ul><p>​<code>UART_STOPBITS_1</code></p><p>​<code>UART_STOPBITS_2</code></p><ul><li><strong>Init.Parity</strong>：指定校验模式</li></ul><p>​<code>UART_PARITY_NONE</code>:无校验</p><p>​<code>UART_PARITY_EVEN</code>:偶校验</p><p>​<code>UART_PARITY_ODD</code>:奇校验</p><ul><li><strong>Init.Mode</strong>：是否启用接收或发送模式</li></ul><p>​<code>UART_MODE_RX</code></p><p>​<code>UART_MODE_TX</code></p><p>​<code>UART_MODE_TX_RX</code></p><ul><li><strong>Init.HwFlowCtl</strong>：是否启用硬件流控制模式</li></ul><p>​<code>UART_STATE_DISABLE</code></p><p>​<code>UART_STATE_ENABLE</code></p><ul><li><strong>Init.OverSampling</strong>：启用几倍过采样</li></ul><p>​<code>UART_OVERSAMPLING_16</code>:8次采样来获取</p><p>​<code>UART_OVERSAMPLING_8</code>:8次采样来获取</p><h2 id="1-3-HAL-UART-Init-UART-HandleTypeDef-huart"><a href="#1-3-HAL-UART-Init-UART-HandleTypeDef-huart" class="headerlink" title="1.3 HAL_UART_Init(UART_HandleTypeDef *huart)"></a>1.3 HAL_UART_Init(UART_HandleTypeDef *huart)</h2><p>将1.1和1.2中的配置进行初始化，此函数会调用AL_UART_MspInit(UART_HandleTypeDef* uartHandle)</p><p>进行串口的硬件初始化</p><h1 id="二、HAL-UART-MspInit"><a href="#二、HAL-UART-MspInit" class="headerlink" title="二、HAL_UART_MspInit"></a>二、HAL_UART_MspInit</h1><h2 id="2-1-GPIO-InitTypeDef"><a href="#2-1-GPIO-InitTypeDef" class="headerlink" title="2.1 GPIO_InitTypeDef"></a>2.1 GPIO_InitTypeDef</h2><ul><li><strong>Pin</strong>：指定要配置的 GPIO 引脚</li></ul><p>​<code>GPIO_PIN_x</code></p><ul><li><strong>Mode</strong>:指定引脚的工作模式</li></ul><p>​<code>GPIO_MODE_INPUT</code>：输入模式</p><p>​<code>GPIO_MODE_OUTPUT_PP</code>：推挽输出模式</p><p>​<code>GPIO_MODE_OUTPUT_OD</code>：开漏输出模式</p><p>​<code>GPIO_MODE_AF_PP</code>：复用功能推挽输出模式</p><p>​<code>GPIO_MODE_AF_OD</code>：复用功能开漏输出模式</p><p>​<code>GPIO_MODE_ANALOG</code>：模拟模式</p><p>​<code>GPIO_MODE_IT_RISING</code>：外部中断模式，触发上升沿</p><p>​<code>GPIO_MODE_IT_FALLING</code>：外部中断模式，触发下降沿</p><p>​<code>GPIO_MODE_IT_RISING_FALLING</code>：外部中断模式，触发上升沿或下降沿</p><p>​<code>GPIO_MODE_EVT_RISING</code>：外部事件模式，触发上升沿</p><p>​<code>GPIO_MODE_EVT_FALLING</code>：外部事件模式，触发下降沿</p><p>​<code>GPIO_MODE_EVT_RISING_FALLING</code>：外部事件模式，触发上升沿或下降沿</p><ul><li><strong>Pull</strong>:指定引脚的上拉或下拉电阻</li></ul><p>​<code>GPIO_NOPULL</code>：无上下拉</p><p>​<code>GPIO_PULLUP</code>：上拉</p><p>​<code>GPIO_PULLDOWN</code>：下拉</p><ul><li><strong>Speed</strong>:指定引脚的输出速度</li></ul><p>​<code>GPIO_SPEED_FREQ_LOW</code>:低速</p><p>​<code>GPIO_SPEED_FREQ_MEDIUM</code>:中速</p><p>​<code>GPIO_SPEED_FREQ_HIGH</code>:高速</p><ul><li><strong>Alternate</strong>:引脚的复用功能</li></ul><h2 id="2-2-HAL-GPIO-Init-GPIO-TypeDef-GPIOx-GPIO-InitTypeDef-GPIO-Init"><a href="#2-2-HAL-GPIO-Init-GPIO-TypeDef-GPIOx-GPIO-InitTypeDef-GPIO-Init" class="headerlink" title="2.2 HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)"></a>2.2 HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)</h2><p>将2.1的结构体传入HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)进行初始化</p><h2 id="2-3-DMA-HandleTypeDef"><a href="#2-3-DMA-HandleTypeDef" class="headerlink" title="2.3 DMA_HandleTypeDef"></a>2.3 DMA_HandleTypeDef</h2><ul><li><strong>Instance</strong>：指向DMA 流寄存器基地址</li><li><strong>Init</strong>：DMA 通信参数的结构体</li><li><strong>Lock</strong>：DMA 锁对象</li><li><strong>State</strong>：DMA 传输的当前状态</li><li><strong>Parent</strong>：指向与 DMA 操作相关联的父对象</li><li><strong>XferCpltCallback</strong>：传输完成时调用的回调</li><li><strong>XferHalfCpltCallback</strong>：半传输完成时调用的回调</li><li><strong>XferM1CpltCallback</strong>：内存 1 的传输完成时调用的回调</li><li><strong>XferM1HalfCpltCallback</strong>：内存 1 的半传输完成时调用的回调</li><li><strong>XferErrorCallback</strong>：DMA 传输出错时调用的回调</li><li><strong>XferAbortCallback</strong>：DMA 传输被中止时调用的回调</li><li><strong>ErrorCode</strong>：DMA 传输过程中出现错误代码</li><li><strong>StreamBaseAddress</strong>：DMA 流的基地址</li><li><strong>StreamIndex</strong>：DMA 流的索引</li></ul><h2 id="2-4-DMA-InitTypeDef"><a href="#2-4-DMA-InitTypeDef" class="headerlink" title="2.4 DMA_InitTypeDef"></a>2.4 DMA_InitTypeDef</h2><ul><li><strong>Channel</strong>：指定 DMA 流使用的通道</li></ul><p>​<code>DMA_CHANNEL_x</code></p><ul><li><strong>Direction</strong>：指定数据传输的方向</li></ul><p>​<code>DMA_MEMORY_TO_MEMORY</code>:内存到内存</p><p>​<code>DMA_MEMORY_TO_PERIPH</code>:内存到外设</p><p>​<code>DMA_PERIPH_TO_MEMORY</code>:外设到内存</p><ul><li><strong>PeriphInc</strong>：外设地址寄存器是否需要递增</li></ul><p>​<code>DMA_PINC_ENABLE</code>:启用</p><p>​<code>DMA_PINC_DISABLE</code>:禁用</p><ul><li><p><strong>MemInc</strong>：内存地址寄存器是否需要递增</p><p>  <code>DMA_MINC_ENABLE</code>::启用</p><p>  <code>DMA_MINC_DISABLE</code>:禁用</p></li><li><p><strong>PeriphDataAlignment</strong>：外设数据宽度</p></li></ul><p>​<code>DMA_PDATAALIGN_BYTE</code>:字节对齐 (1 字节)</p><p>​<code>DMA_PDATAALIGN_HALFWORD</code>: 半字对齐 (2字节)</p><p>​<code>DMA_PDATAALIGN_WORD</code>:字对齐 (4字节)</p><ul><li><strong>MemDataAlignment</strong>：内存数据宽度</li></ul><p>​<code>DMA_MDATAALIGN_BYTE</code>:字节对齐 (1 字节)</p><p>​<code>DMA_MDATAALIGN_HALFWORD</code>:半字对齐 (2字节)</p><p>​<code>DMA_MDATAALIGN_WORD</code>:字对齐 (4字节)</p><ul><li><strong>Mode</strong>：DMA 流的操作模式</li></ul><p>​<code>DMA_NORMAL</code>:正常模式(DMA 执行一次数据传输后会停止)</p><p>​<code>DMA_CIRCULAR</code>:循环模式(DMA 会在数据传输完成后自动重新启动)</p><p>​<code>DMA_PFCTRL</code>:优先控制模式(外设优先级控制)</p><ul><li><strong>Priority</strong>：DMA 流的优先级</li></ul><p>​<code>DMA_PRIORITY_LOW</code>:低优先级</p><p>​<code>DMA_PRIORITY_MEDIUM</code>:中优先级</p><p>​<code>DMA_PRIORITY_HIGH</code>:高优先级</p><p>​<code>DMA_PRIORITY_VERY_HIGH</code>:非常高优先级</p><ul><li><strong>FIFOMode</strong>：是否使用 FIFO 模式或者直接模式</li></ul><p>​<code>DMA_FIFOMODE_DISABLE</code>:直接模式(数据会直接从内存传输到外设，或者反向操作)</p><p>​<code>DMA_FIFOMODE_ENABLE</code>:DMA 流会使用 FIFO 队列来缓存数据，直到数据达到一定数量时才会传输</p><ul><li><strong>FIFOThreshold</strong>：FIFO 阈值等级</li></ul><p>​<code>DMA_FIFO_THRESHOLD_1QUARTERFULL</code>:四分之一满DMA 会开始数据传输</p><p>​<code>DMA_FIFO_THRESHOLD_HALFFULL</code>:一半满DMA 会开始数据传输</p><p>​<code>DMA_FIFO_THRESHOLD_3QUARTERSFULL</code>:三分之一满DMA 会开始数据传输</p><p>​<code>DMA_FIFO_THRESHOLD_FULL</code>:完全满DMA 会开始数据传输</p><ul><li><strong>MemBurst</strong>：内存传输的突发模式配置</li></ul><p>​<code>DMA_MBURST_SINGLE</code>:单次传输模式</p><p>​<code>DMA_MBURST_INC4</code>:递增 4 字节传输模式</p><p>​<code>DMA_MBURST_INC8</code>:递增 8 字节传输模式</p><p>​<code>DMA_MBURST_INC16</code>:递增 16 字节传输模式</p><ul><li><strong>PeriphBurst</strong>：外设传输的突发模式配置</li></ul><p>​<code>DMA_PBURST_SINGLE</code>:单次传输模式</p><p>​<code>DMA_PBURST_INC4</code>:递增 4 字节传输模式</p><p>​<code>DMA_PBURST_INC8</code>:递增 8 字节传输模式</p><p>​<code>DMA_PBURST_INC16</code>:递增 16 字节传输模式</p><h2 id="2-5-HAL-StatusTypeDef-HAL-DMA-Init-DMA-HandleTypeDef-hdma"><a href="#2-5-HAL-StatusTypeDef-HAL-DMA-Init-DMA-HandleTypeDef-hdma" class="headerlink" title="2.5 HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)"></a>2.5 HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)</h2><p>调用此函数初始化2.3结构体的配置</p><h1 id="三、-HAL-LINKDMA"><a href="#三、-HAL-LINKDMA" class="headerlink" title="三、__HAL_LINKDMA"></a>三、__HAL_LINKDMA</h1><p>____HAL_LINKDMA(<strong>HANDLE</strong>, <strong>PERIPH</strong>, <strong>DMA_HANDLE</strong>)</p><p>将一个 DMA 句柄（<code>DMA_HandleTypeDef</code>）与外设（如 UART、SPI、I2C 等）的相关操作关联起来</p><ul><li><p><strong>HANDLE</strong>:外设句柄</p></li><li><p><strong>PERIPH</strong>:外设的 DMA 相关字段</p></li><li><p><strong>DMA_HANDLE__</strong>:实际的 DMA 句柄</p></li></ul><h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><h2 id="4-1-HAL-NVIC-SetPriority"><a href="#4-1-HAL-NVIC-SetPriority" class="headerlink" title="4.1 HAL_NVIC_SetPriority"></a>4.1 HAL_NVIC_SetPriority</h2><p>HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)</p><p><strong>设置中断的优先级</strong></p><ul><li><strong>IRQn</strong>：中断请求号</li><li><strong>PreemptPriority</strong>：抢占优先级(值越小，优先级越高)</li><li><strong>SubPriority</strong>：响应优先级(值越小，优先级越高)</li></ul><h2 id="4-2-HAL-NVIC-EnableIRQ"><a href="#4-2-HAL-NVIC-EnableIRQ" class="headerlink" title="4.2 HAL_NVIC_EnableIRQ"></a>4.2 HAL_NVIC_EnableIRQ</h2><p>HAL_NVIC_EnableIRQ(IRQn_Type IRQn)</p><p><strong>启用指定中断</strong></p><ul><li><strong>IRQn</strong>:中断请求号</li></ul><h1 id="五、中断响应"><a href="#五、中断响应" class="headerlink" title="五、中断响应"></a>五、中断响应</h1><p><img src="/2025/04/28/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/USART/image-20250503175203247.png" alt="image-20250503175203247"></p><h2 id="5-1-DMA2-Stream2-IRQHandler"><a href="#5-1-DMA2-Stream2-IRQHandler" class="headerlink" title="5.1 DMA2_Stream2_IRQHandler()"></a>5.1 DMA2_Stream2_IRQHandler()</h2><p>当 DMA2 的 Stream 2 发生中断时，调用 <code>HAL_DMA_IRQHandler</code> 来处理相关的中断事件</p><h2 id="5-2-HAL-DMA-IRQHandler"><a href="#5-2-HAL-DMA-IRQHandler" class="headerlink" title="5.2 HAL_DMA_IRQHandler"></a>5.2 HAL_DMA_IRQHandler</h2><p>用于处理 DMA 相关的中断事件</p><ul><li><strong>传输完成中断</strong>:当 DMA 完成数据的传输时</li></ul><p><code>HAL_DMA_TxCpltCallback()</code>:DMA 发送完成时触发的回调</p><p><code>HAL_DMA_RxCpltCallback()</code>:DMA 接收完成时触发的回调</p><ul><li><strong>半传输完成中断</strong>:当 DMA 在传输数据时到达数据缓冲区的一半时</li></ul><p><code>HAL_DMA_HalfTxCpltCallback()</code>:DMA 发送半传输完成时触发的回调</p><p><code>HAL_DMA_HalfRxCpltCallback()</code>:DMA 接收半传输完成时触发的回调</p><ul><li><strong>传输错误中断</strong>:当 DMA 在传输过程中发生错误时</li></ul><p><code>HAL_DMA_ErrorCallback()</code>:当发生 DMA 错误时触发的回调</p><ul><li><strong>直接存储器访问总线错误</strong>:当 DMA 控制器遇到总线错误时</li><li><strong>DMA Stream&#x2F;Channel 中的中断源</strong>:</li></ul><h1 id="5-3-HAL-UART-IRQHandler"><a href="#5-3-HAL-UART-IRQHandler" class="headerlink" title="5.3 HAL_UART_IRQHandler"></a>5.3 HAL_UART_IRQHandler</h1><ul><li><strong>数据接收完成中断</strong>:</li></ul><p><code>HAL_UART_RxCpltCallback</code>:当 UART 数据接收完成时</p><p><code>HAL_UART_RxHalfCpltCallback()</code>:当 UART 半接收完成时</p><ul><li><strong>数据发送完成中断</strong>:</li></ul><p><code>HAL_UART_TxCpltCallback()</code>:当 UART 数据发送完成时</p><p><code>HAL_UART_TxHalfCpltCallback()</code>:当 UART 半发送完成时</p><ul><li><strong>错误中断</strong>:</li></ul><p><code>HAL_UART_ErrorCallback()</code>:当 UART 发生错误时</p><ul><li><strong>其他中断（如行结束中断等）</strong>:</li></ul><p><code>HAL_UART_AbortCpltCallback()</code>:当 UART 中的传输被取消时</p><h1 id="三、发送重定向"><a href="#三、发送重定向" class="headerlink" title="三、发送重定向"></a>三、发送重定向</h1><h2 id="1-my-usart-h"><a href="#1-my-usart-h" class="headerlink" title="1.my_usart.h"></a>1.my_usart.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MY_USART_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MY_USART_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdarg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> U1_TxBuff_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_usart1</span><span class="params">(<span class="type">char</span> *format,...)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-my-usart-c"><a href="#2-my-usart-c" class="headerlink" title="2.my_usart.c"></a>2.my_usart.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_usart1</span><span class="params">(<span class="type">char</span> *format,...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list listdata;</span><br><span class="line">    va_start(listdata,format);</span><br><span class="line">    <span class="built_in">vsprintf</span>((<span class="type">char</span> *)U1_TxBuff,format,listdata);</span><br><span class="line">    va_end(listdata);</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1,(<span class="type">const</span> <span class="type">uint8_t</span> *)U1_TxBuff,<span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span>*)U1_TxBuff),<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-HAL-UART-GET-FLAG-huart1-UART-FLAG-TXE"><a href="#1-HAL-UART-GET-FLAG-huart1-UART-FLAG-TXE" class="headerlink" title="1. __HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_TXE)"></a>1. __HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_TXE)</h2><p><strong>检查 USART状态寄存器中特定标志位的宏</strong></p><table><thead><tr><th align="center">宏定义</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">UART_FLAG_CTS</td><td align="center">清除发送</td></tr><tr><td align="center">UART_FLAG_LBD</td><td align="center">线路中断</td></tr><tr><td align="center">UART_FLAG_TXE</td><td align="center">传输数据寄存器空</td></tr><tr><td align="center">UART_FLAG_TC</td><td align="center">传输完成</td></tr><tr><td align="center">UART_FLAG_RXNE</td><td align="center">接收数据寄存器非空</td></tr><tr><td align="center">UART_FLAG_IDLE</td><td align="center">空闲线</td></tr><tr><td align="center">UART_FLAG_ORE</td><td align="center">接收溢出错误</td></tr><tr><td align="center">UART_FLAG_NE</td><td align="center">接收噪声错误</td></tr><tr><td align="center">UART_FLAG_FE</td><td align="center">接收帧错误</td></tr><tr><td align="center">UART_FLAG_PE</td><td align="center">接收奇偶校验错误</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Usart-Init&quot;&gt;&lt;a href=&quot;#一、Usart-Init&quot; class=&quot;headerlink&quot; title=&quot;一、Usart_Init&quot;&gt;&lt;/a&gt;一、Usart_Init&lt;/h1&gt;&lt;h2 id=&quot;1-1-UART-HandleTypeDef&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="STM32" scheme="https://ydw-item.github.io.git/categories/STM32/"/>
    
    <category term="通信协议" scheme="https://ydw-item.github.io.git/categories/STM32/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    
    <category term="通讯协议" scheme="https://ydw-item.github.io.git/tags/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="USART" scheme="https://ydw-item.github.io.git/tags/USART/"/>
    
  </entry>
  
  <entry>
    <title>LVGL页面图层</title>
    <link href="https://ydw-item.github.io.git/2025/04/06/LVGL/LVGL-%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    <id>https://ydw-item.github.io.git/2025/04/06/LVGL/LVGL-%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/</id>
    <published>2025-04-06T08:24:19.000Z</published>
    <updated>2025-04-06T08:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、菜单页面，背景色不动"><a href="#一、菜单页面，背景色不动" class="headerlink" title="一、菜单页面，背景色不动"></a>一、菜单页面，背景色不动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ui_MenuPage_bottom = lv_obj_create(<span class="literal">NULL</span>);</span><br><span class="line">lv_obj_set_width(ui_MenuPage_bottom, <span class="number">240</span>);</span><br><span class="line">lv_obj_set_height(ui_MenuPage_bottom,<span class="number">280</span>);</span><br><span class="line"></span><br><span class="line">bg_image = lv_img_create(ui_MenuPage_bottom);</span><br><span class="line">lv_img_set_src(bg_image,&amp;bg_2);</span><br><span class="line">lv_obj_set_style_bg_opa(bg_image, LV_OPA_70, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">ui_MenuPage_top = lv_obj_create(ui_MenuPage_bottom);</span><br><span class="line">lv_obj_set_align(ui_MenuPage_top, LV_ALIGN_TOP_MID);  </span><br><span class="line">lv_obj_add_flag(ui_MenuPage_top, LV_OBJ_FLAG_SCROLLABLE);  <span class="comment">// 设置为可滚动的对象</span></span><br><span class="line">lv_obj_set_scroll_dir(ui_MenuPage_top, LV_DIR_VER);</span><br><span class="line">lv_obj_set_style_bg_opa(ui_MenuPage_top, <span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">lv_obj_set_width(ui_MenuPage_top, <span class="number">240</span>);</span><br><span class="line">lv_obj_set_height(ui_MenuPage_top, <span class="number">280</span>);</span><br></pre></td></tr></table></figure><img src="/2025/04/06/LVGL/LVGL-%E9%A1%B5%E9%9D%A2%E8%AE%BE%E8%AE%A1/1.gif" width="240" height="280"><h1 id="二、右滑切换界面"><a href="#二、右滑切换界面" class="headerlink" title="二、右滑切换界面"></a>二、右滑切换界面</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ui_event_AboutPage</span><span class="params">(<span class="type">lv_event_t</span> * e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_event_code_t</span> event_code = lv_event_get_code(e);</span><br><span class="line">    <span class="type">lv_obj_t</span> * target = lv_event_get_target(e);<span class="comment">//获取触发该事件的目标对象（即哪个控件触发了事件）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(event_code == LV_EVENT_GESTURE)  <span class="comment">//检测手势</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lv_indev_get_gesture_dir(lv_indev_get_act()) == LV_DIR_RIGHT)<span class="comment">//右滑</span></span><br><span class="line">        &#123;</span><br><span class="line">    user_Stack_Pop(&amp;ScrRenewStack); <span class="comment">//出栈</span></span><br><span class="line">            ui_MenuPage_screen_init();      <span class="comment">//初始化目标页面       </span></span><br><span class="line">            lv_scr_load_anim(ui_MenuPage_bottom,LV_SCR_LOAD_ANIM_MOVE_RIGHT,<span class="number">100</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">            user_Stack_Push(&amp;ScrRenewStack,(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;ui_MenuPage_bottom);<span class="comment">//将目标页面压栈</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、菜单页面，背景色不动&quot;&gt;&lt;a href=&quot;#一、菜单页面，背景色不动&quot; class=&quot;headerlink&quot; title=&quot;一、菜单页面，背景色不动&quot;&gt;&lt;/a&gt;一、菜单页面，背景色不动&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/categories/LVGL/"/>
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/tags/LVGL/"/>
    
  </entry>
  
  <entry>
    <title>LVGL移植</title>
    <link href="https://ydw-item.github.io.git/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/"/>
    <id>https://ydw-item.github.io.git/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/</id>
    <published>2025-03-24T08:24:19.000Z</published>
    <updated>2025-03-24T08:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、LVGL文件裁剪"><a href="#一、LVGL文件裁剪" class="headerlink" title="一、LVGL文件裁剪"></a>一、LVGL文件裁剪</h1><h2 id="1-删除根目录下选中的文件"><a href="#1-删除根目录下选中的文件" class="headerlink" title="1. 删除根目录下选中的文件"></a>1. <strong>删除根目录下选中的文件</strong></h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/9.png" alt="1"></p><p><strong>删除后</strong></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/10.png" alt="2"></p><h2 id="2-裁剪examples文件夹"><a href="#2-裁剪examples文件夹" class="headerlink" title="2. 裁剪examples文件夹"></a>2. 裁剪examples文件夹</h2><ul><li>删除<code>porting</code>中输入输出相关的接口文件，其它全部删除</li></ul><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/11.png" alt="QQ_1742610639413"></p><h2 id="3-修改lvgl配置文件文件名"><a href="#3-修改lvgl配置文件文件名" class="headerlink" title="3. 修改lvgl配置文件文件名"></a>3. 修改lvgl配置文件文件名</h2><p>将根目录下的<code>lv_conf_template.h</code>文件名修改为<code>lv_conf.h</code></p><h2 id="4-最终文件"><a href="#4-最终文件" class="headerlink" title="4. 最终文件"></a>4. 最终文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/12.png" alt="image-20250322104307792"></p><ul><li><code>demos</code>文件夹中保存的是官方历程，可以删除</li></ul><h2 id="5-修改lv-conf-h"><a href="#5-修改lv-conf-h" class="headerlink" title="5. 修改lv_conf.h"></a>5. 修改lv_conf.h</h2><ul><li>将<code>#if 0</code>修改为<code>#if 1</code></li></ul><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/14.png" alt="image-20250322110212708"></p><h1 id="二、工程目录"><a href="#二、工程目录" class="headerlink" title="二、工程目录"></a>二、工程目录</h1><h2 id="1-移植裁剪后的lvgl"><a href="#1-移植裁剪后的lvgl" class="headerlink" title="1. 移植裁剪后的lvgl"></a>1. 移植裁剪后的lvgl</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/13.png" alt="image-20250322110141115"></p><p><strong>不按次结构，有些头文件的引用可能会报错</strong></p><h2 id="2-添加文件进工程"><a href="#2-添加文件进工程" class="headerlink" title="2.添加文件进工程"></a>2.添加文件进工程</h2><h3 id="1-添加分组"><a href="#1-添加分组" class="headerlink" title="(1) 添加分组"></a>(1) 添加分组</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/15.png" alt="image-20250322114144151"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Middlewares/lvgl/example/porting</span><br><span class="line">Middlewares/lvgl/src/core</span><br><span class="line">Middlewares/lvgl/src/core    </span><br><span class="line">Middlewares/lvgl/src/extra</span><br><span class="line">Middlewares/lvgl/src/font</span><br><span class="line">Middlewares/lvgl/src/gpu</span><br><span class="line">Middlewares/lvgl/src/hal</span><br><span class="line">Middlewares/lvgl/src/widgets</span><br></pre></td></tr></table></figure><h3 id="2-为什么要这样分组"><a href="#2-为什么要这样分组" class="headerlink" title="(2) 为什么要这样分组"></a>(2) 为什么要这样分组</h3><p>因为这样分组和LVGL的结构是相同的</p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/16.png" alt="image-20250322114311900"></p><h3 id="3-为分组添加文件"><a href="#3-为分组添加文件" class="headerlink" title="(3) 为分组添加文件"></a>(3) 为分组添加文件</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/17.png" alt="image-20250322111729503"></p><h3 id="4-添加头文件路径"><a href="#4-添加头文件路径" class="headerlink" title="(4) 添加头文件路径"></a>(4) 添加头文件路径</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/19.png" alt="QQ_1742618216223"></p><h3 id="5-开启C99模式"><a href="#5-开启C99模式" class="headerlink" title="(5) 开启C99模式"></a>(5) 开启C99模式</h3><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/18.png" alt="QQ_1742615627487"></p><h1 id="三、配置输出"><a href="#三、配置输出" class="headerlink" title="三、配置输出"></a>三、配置输出</h1><h2 id="1-修改头文件"><a href="#1-修改头文件" class="headerlink" title="1. 修改头文件"></a>1. 修改头文件</h2><p><code>lvgl\examples\porting</code>路径下的<code>lv_port_disp_template.c/h</code>是官方提供的显示接口函数</p><p>使用前需要将<code>#if 0</code> 改为<code>#if 1</code></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/20.png" alt="image-20250322125754825"></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/21.png" alt="image-20250322125858697"></p><h2 id="2-包含输出设备驱动头文件"><a href="#2-包含输出设备驱动头文件" class="headerlink" title="2. 包含输出设备驱动头文件"></a>2. 包含输出设备驱动头文件</h2><h2 id="3-在disp-init-中调用LCD初始化代码"><a href="#3-在disp-init-中调用LCD初始化代码" class="headerlink" title="3. 在disp_init()中调用LCD初始化代码"></a>3. 在disp_init()中调用LCD初始化代码</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/2.png" alt="image-20250322131803479"></p><h2 id="4-配置图形数据缓冲模式"><a href="#4-配置图形数据缓冲模式" class="headerlink" title="4. 配置图形数据缓冲模式"></a>4. 配置图形数据缓冲模式</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/23.png" alt="image-20250322132844255"></p><h2 id="5-设置屏幕尺寸"><a href="#5-设置屏幕尺寸" class="headerlink" title="5. 设置屏幕尺寸"></a>5. 设置屏幕尺寸</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/24.png" alt="image-20250322133003409"></p><h2 id="6-在disp-flush中使用自己的打点函数"><a href="#6-在disp-flush中使用自己的打点函数" class="headerlink" title="6. 在disp_flush中使用自己的打点函数"></a>6. 在disp_flush中使用自己的打点函数</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/1.png" alt="image-20250318133644412"></p><h1 id="四、配置输入"><a href="#四、配置输入" class="headerlink" title="四、配置输入"></a>四、配置输入</h1><h2 id="1-修改输入设备接口文件"><a href="#1-修改输入设备接口文件" class="headerlink" title="1. 修改输入设备接口文件"></a>1. 修改输入设备接口文件</h2><p><code>lvgl\examples\porting</code>路径下的<code>lv_port_indev_template.c/h</code>是官方提供的显示接口函数</p><p>使用前需要将<code>#if 0</code> 改为<code>#if 1</code></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/38.png" alt="image-20250323144615574"></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/39.png" alt="image-20250323144639488"></p><h2 id="2-按需裁剪输入设备"><a href="#2-按需裁剪输入设备" class="headerlink" title="2. 按需裁剪输入设备"></a>2. 按需裁剪输入设备</h2><p><strong>删除<code>lv_port_indev_template.c/h</code>中未使用的部分，只保留使用到的部分</strong></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/4.png" alt="image-20250323145225160"></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/40.png" alt="image-20250323145323205"></p><h2 id="3-在接口文件中包含触摸头文件"><a href="#3-在接口文件中包含触摸头文件" class="headerlink" title="3. 在接口文件中包含触摸头文件"></a>3. 在接口文件中包含触摸头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/41.png" alt="QQ_1742714448348"></p><h2 id="4-在touchpad-init-中调用触摸初始化代码"><a href="#4-在touchpad-init-中调用触摸初始化代码" class="headerlink" title="4. 在touchpad_init()中调用触摸初始化代码"></a>4. 在touchpad_init()中调用触摸初始化代码</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/3.png" alt="image-20250323151034944"></p><h2 id="5-触摸检测函数配置"><a href="#5-触摸检测函数配置" class="headerlink" title="5. 触摸检测函数配置"></a>5. 触摸检测函数配置</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/5.png" alt="image-20250318135936403"></p><h2 id="6-配置坐标获取函数"><a href="#6-配置坐标获取函数" class="headerlink" title="6. 配置坐标获取函数"></a>6. 配置坐标获取函数</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/6.png" alt="image-20250318140033233"></p><h1 id="五、为LVGL提供时基"><a href="#五、为LVGL提供时基" class="headerlink" title="五、为LVGL提供时基"></a>五、为LVGL提供时基</h1><h2 id="1-stm32f4xx-it-c文件中添加头文件"><a href="#1-stm32f4xx-it-c文件中添加头文件" class="headerlink" title="1. stm32f4xx_it.c文件中添加头文件"></a>1. <code>stm32f4xx_it.c</code>文件中添加头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/25.png" alt="image-20250322142414771"></p><h2 id="2-调用lv-tick-inc-函数"><a href="#2-调用lv-tick-inc-函数" class="headerlink" title="2. 调用lv_tick_inc()函数"></a>2. 调用<code>lv_tick_inc()</code>函数</h2><p><code>x参数</code>为进入函数的时间，<strong>例如1ms发生一次中断，则x改为1</strong></p><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/26.png" alt="QQ_1742624811806"></p><h1 id="六、main-函数部分移植"><a href="#六、main-函数部分移植" class="headerlink" title="六、main()函数部分移植"></a>六、main()函数部分移植</h1><h2 id="1-包含头文件"><a href="#1-包含头文件" class="headerlink" title="1. 包含头文件"></a>1. 包含头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/28.png" alt="QQ_1742625782915"></p><h2 id="2-初始化LVGL库、输入输出设备"><a href="#2-初始化LVGL库、输入输出设备" class="headerlink" title="2. 初始化LVGL库、输入输出设备"></a>2. 初始化LVGL库、输入输出设备</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/27.png" alt="image-20250322144233357"></p><h2 id="3-每5ms调用一次lv-timer-hander"><a href="#3-每5ms调用一次lv-timer-hander" class="headerlink" title="3. 每5ms调用一次lv_timer_hander()"></a>3. 每5ms调用一次<code>lv_timer_hander()</code></h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/35.png" alt="image-20250322165012000"></p><h2 id="4-调用测试代码"><a href="#4-调用测试代码" class="headerlink" title="4. 调用测试代码"></a>4. 调用测试代码</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/37.png" alt="image-20250322165048497"></p><h1 id="七、测试官方历程"><a href="#七、测试官方历程" class="headerlink" title="七、测试官方历程"></a>七、测试官方历程</h1><h2 id="1-将demos文件夹放入GUI-APP中"><a href="#1-将demos文件夹放入GUI-APP中" class="headerlink" title="1. 将demos文件夹放入GUI_APP中"></a>1. 将<code>demos</code>文件夹放入<code>GUI_AP</code>P中</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/34.png" alt="image-20250322164939645"></p><h2 id="2-添加头文件路径"><a href="#2-添加头文件路径" class="headerlink" title="2. 添加头文件路径"></a>2. 添加头文件路径</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/29.png" alt="QQ_1742632798292"></p><h2 id="3-将lv-conf-h文件，更改宏定义"><a href="#3-将lv-conf-h文件，更改宏定义" class="headerlink" title="3. 将lv_conf_h文件，更改宏定义"></a>3. 将lv_conf_h文件，更改宏定义</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/31.png" alt="image-20250322164639124"></p><h2 id="4-新建工程组"><a href="#4-新建工程组" class="headerlink" title="4. 新建工程组"></a>4. 新建工程组</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/30.png" alt="QQ_1742632928236"></p><h2 id="5-在main中添加头文件"><a href="#5-在main中添加头文件" class="headerlink" title="5. 在main中添加头文件"></a>5. 在main中添加头文件</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/32.png" alt="image-20250322164705613"></p><h2 id="6-调用测试函数"><a href="#6-调用测试函数" class="headerlink" title="6. 调用测试函数"></a>6. 调用测试函数</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/33.png" alt="image-20250322164737470"></p><h2 id="7-现象"><a href="#7-现象" class="headerlink" title="7. 现象"></a>7. 现象</h2><p><img src="/2025/03/24/LVGL/LVGL-%E7%A7%BB%E6%A4%8D/36.JPG" alt="IMG_5519"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、LVGL文件裁剪&quot;&gt;&lt;a href=&quot;#一、LVGL文件裁剪&quot; class=&quot;headerlink&quot; title=&quot;一、LVGL文件裁剪&quot;&gt;&lt;/a&gt;一、LVGL文件裁剪&lt;/h1&gt;&lt;h2 id=&quot;1-删除根目录下选中的文件&quot;&gt;&lt;a href=&quot;#1-删除根目录下</summary>
      
    
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/categories/LVGL/"/>
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/tags/LVGL/"/>
    
  </entry>
  
  <entry>
    <title>LVGL(一)基础对象</title>
    <link href="https://ydw-item.github.io.git/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/"/>
    <id>https://ydw-item.github.io.git/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/</id>
    <published>2025-03-07T08:24:19.000Z</published>
    <updated>2025-03-07T08:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18H4y1g7CF?spm_id_from=333.788.videopod.sections&vd_source=daf1db3c953df56f74e76077dfa61ab4">2-3-1_LVGL入门教程之基础对象(lv_obj)_哔哩哔哩_bilibili</a></p><p><a href="https://lvgl.100ask.net/master/details/widgets/index.html">Widgets（控件） — LVGL 文档</a></p><h1 id="一、目录说明"><a href="#一、目录说明" class="headerlink" title="一、目录说明"></a>一、目录说明</h1><ul><li>demos：存放的是LVGL一些综合的内置示例，部分示例可以在官网体验</li><li>docs：存放LVGL的开发文档，阅读时一般不在这里直接阅读，而是在LVGL站点阅读</li><li>env_support:一些环境或者平台的支持，不如我们所使用的RT-Thread就在其中</li><li>scripts：存放一些处理脚本，我们在使用LVGL时基本不会用到</li><li>src：存放LVGL实际的源码，我们使用LVGL进行开发时，都是使用这里面的代码文件</li><li>tests：存放一些CI测试文件，我们在使用LVGL时不会用到</li></ul><h1 id="二、LVGL的启动流程初探"><a href="#二、LVGL的启动流程初探" class="headerlink" title="二、LVGL的启动流程初探"></a>二、LVGL的启动流程初探</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化LVGL库 */</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化LVGL的硬件抽象层（显示、触摸）  */</span></span><br><span class="line">    <span class="type">lv_display_t</span> * display = lv_windows_create_display(title, <span class="number">1024</span>, <span class="number">600</span>, <span class="number">100</span>, FALSE, FALSE);</span><br><span class="line">    lv_windows_acquire_pointer_indev(display);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将提示信息输出到控制台，也可以使用printf函数 */</span></span><br><span class="line">    LV_LOG_USER(<span class="string">&quot;LVGL initialization completed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行demo */</span></span><br><span class="line">    <span class="comment">// 下面这三行是运行一个demo，第一行和后面两行的效果是一样的，只能同时去掉第一行或者后面两行，两者之一的注释</span></span><br><span class="line">    <span class="comment">// 后续学习的时候要确保下面这三行都被注释掉</span></span><br><span class="line">    lv_demo_widgets();</span><br><span class="line">    <span class="comment">//char * demo_str[] = &#123;&quot;widgets&quot;&#125;;</span></span><br><span class="line">    <span class="comment">//lv_demos_create(demo_str, strlen((char * )demo_str));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 课程示例代码，一般同时只运行一个</span></span><br><span class="line"><span class="comment">       运行前，请将上面的三行代码都注释掉 */</span></span><br><span class="line">    <span class="comment">//lesson_2_3_1();         // 基础对象(lv_obj)，&quot;Hello, LVGL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* 定期调用lv_task处理（定时器）程序它也可以在定时器或操作系统任务中完成 */</span></span><br><span class="line">        lv_task_handler();</span><br><span class="line">        usleep(<span class="number">5000</span>);       <span class="comment">/* 不一直占用系统资源 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LVGL的定时器处理程序是一个内置的任务系统，允许开发者注册函数，使其可以定期被调用，它帮助管理时间敏感的操作（毫秒级别）和周期性的活动</p><h1 id="三、LVGL裁剪"><a href="#三、LVGL裁剪" class="headerlink" title="三、LVGL裁剪"></a>三、LVGL裁剪</h1><p>LVGL的裁剪在<code>lv_conf.h</code>文件中进行</p><p>我们可以尝试关闭<code>lv_conf.h</code>文件中的WIDGETS和THEMES的部分功能来验证</p><h1 id="四、SquareLine-Stdio使用"><a href="#四、SquareLine-Stdio使用" class="headerlink" title="四、SquareLine_Stdio使用"></a>四、SquareLine_Stdio使用</h1><ul><li><p>Project name (项目名称)：<code>lvgl_1</code>：这是该项目的名称。项目名通常用于标识和区分不同的应用或设计。</p></li><li><p>路径 (路径)：<code>G:\ydw_item\LVGL\my_lvgl_work\my_lvgl_1\</code>：显示了该项目的存储路径。此路径用于保存项目文件。</p></li><li><p>Resolution (分辨率)：<code>240 x 280</code>：设置显示屏的分辨率为 240 像素宽，280 像素高。这意味着你的显示设备具有240像素的宽度和280像素的高度。</p></li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/8.png" alt="image-20250316153602188"></p><ul><li>Rotation (旋转)<code>：0 degree</code>：显示方向设置为 0 度，也就是没有旋转，显示方向与硬件显示方向一致。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/1.png" alt="image-20250316151839395"></p><ul><li><p>Offset (偏移)：<code>0, 0</code>：设置显示区域的偏移量，通常用来对显示内容进行微调，确保图像和内容显示正确。在这里，偏移量设置为 <code>(0, 0)</code>，表示没有偏移。</p><p>  <img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/5.png" alt="image-20250316152820450"></p></li><li><p>Shape (形状)：<code>Rectangle</code>：设置显示区域的形状为矩形，这适用于大多数显示屏，尤其是液晶或OLED显示器。</p></li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/4.png" alt="image-20250316152240395"></p><ul><li>Color depth (颜色深度)：设置颜色深度为 16 位，这意味着每个像素使用 16 位来表示颜色，通常为 RGB 565 格式（5 位红色，6 位绿色，5 位蓝色）。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/2.png" alt="image-20250316151915238"></p><ul><li>LVGL version (LVGL 版本)：该项目使用的 LVGL 版本是 8.3.6，这是 Lightweight Graphics Library 的版本。LVGL 是一个开源的图形库，通常用于嵌入式系统中的图形用户界面（GUI）。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/6.png" alt="image-20250316152850607"></p><ul><li>Theme (主题)：Light：主题设置为浅色主题，意味着界面背景会较亮，适用于在明亮环境中使用。</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/7.png" alt="image-20250316152924653"></p><ul><li>Multilanguage (多语言)：Disable：多语言支持被禁用，意味着该界面不会有语言切换功能，可能只支持单一语言</li></ul><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/3.png" alt="image-20250316152119619"></p><h1 id="五、自定义字体"><a href="#五、自定义字体" class="headerlink" title="五、自定义字体"></a>五、自定义字体</h1><h2 id="5-1-生成自定义字库"><a href="#5-1-生成自定义字库" class="headerlink" title="5.1 生成自定义字库"></a>5.1 生成自定义字库</h2><p><a href="https://lvgl.io/tools/fontconverter">LVGL在线自定义字体转换器</a></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/9.png" alt="QQ_1742203731682"></p><h2 id="5-2-声明自定义字库"><a href="#5-2-声明自定义字库" class="headerlink" title="5.2 声明自定义字库"></a>5.2 声明自定义字库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV_FONT_DECLARE(alimamashuheiti_48);</span><br></pre></td></tr></table></figure><h2 id="5-3-使用字体"><a href="#5-3-使用字体" class="headerlink" title="5.3 使用字体"></a>5.3 使用字体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_font(ui_TimeMinuteLabel, &amp;alimamashuheiti_48, LV_PART_MAIN | LV_STATE_DEFAULT);</span><br></pre></td></tr></table></figure><h2 id="5-4-设置字体颜色"><a href="#5-4-设置字体颜色" class="headerlink" title="5.4 设置字体颜色"></a>5.4 设置字体颜色</h2><p><a href="https://www.jyshare.com/front-end/55/">RGB 转 16 进制工具 | 菜鸟工具</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lv_obj_set_style_text_color(ui_TimeMinuteLabel, lv_color_hex(<span class="number">0xCDCDB4</span>), LV_PART_MAIN | LV_STATE_DEFAULT);</span><br></pre></td></tr></table></figure><h1 id="六、图像"><a href="#六、图像" class="headerlink" title="六、图像"></a>六、图像</h1><h2 id="6-1-生成代码"><a href="#6-1-生成代码" class="headerlink" title="6.1 生成代码"></a>6.1 生成代码</h2><p><a href="https://lvgl.io/tools/imageconverter">LVGL在线图像生成器</a></p><p><strong>在使用生成器前使用PS软件将图片修改致对应大小</strong> </p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/10.png" alt="QQ_1742209430572"></p><h2 id="6-2-声明图像"><a href="#6-2-声明图像" class="headerlink" title="6.2 声明图像"></a>6.2 声明图像</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LV_IMG_DECLARE(image1);</span><br></pre></td></tr></table></figure><h2 id="6-3-设置图像"><a href="#6-3-设置图像" class="headerlink" title="6.3 设置图像"></a>6.3 设置图像</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lv_obj_t</span> * bg_image = lv_img_create(screem);</span><br><span class="line">lv_img_set_src(bg_image,&amp;image1);</span><br></pre></td></tr></table></figure><h1 id="七、GIF图像"><a href="#七、GIF图像" class="headerlink" title="七、GIF图像"></a>七、GIF图像</h1><h1 id="七、自定义图标"><a href="#七、自定义图标" class="headerlink" title="七、自定义图标"></a>七、自定义图标</h1><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p><a href="https://www.qqxiuzi.cn/bianma/Unicode-UTF.php"><code>Unicode编码</code>转换<code>UTF-8编码</code></a></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/11.png" alt="image-20250323194551201"></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/image-20250323194617525.png" alt="image-20250323194617525"></p><p><img src="/2025/03/07/LVGL/LVGL-0-%E6%9D%82%E8%B0%88/image-20250323194640838.png" alt="image-20250323194640838"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV18H4y1g7CF?spm_id_from=333.788.videopod.sections&amp;vd_source=daf1db3c953df56f74e76077dfa61ab4&quot;&gt;2-</summary>
      
    
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/categories/LVGL/"/>
    
    
    <category term="LVGL" scheme="https://ydw-item.github.io.git/tags/LVGL/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-9-二叉树</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2025-02-25T06:39:49.000Z</published>
    <updated>2025-02-25T06:39:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的创建与遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>             //定义二叉树结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createTree</span><span class="params">(TreeNode** T, <span class="type">char</span>* data, <span class="type">int</span>* index)</span>   <span class="comment">//初始化树</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = data[*index];                                   </span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时为空节点</span></span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时不为空</span></span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T) -&gt; data = ch;</span><br><span class="line">        <span class="comment">// 创建左子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;lchild), data, index);</span><br><span class="line">        <span class="comment">// 创建右子树，逻辑一致，进行递归</span></span><br><span class="line">        createTree(&amp;((*T)-&gt;rchild), data, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        preOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        preOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode* T)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        inOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 中办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        inOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode* T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理左孩子</span></span><br><span class="line">        postOrder(T-&gt;lchild);</span><br><span class="line">        <span class="comment">// 处理右孩子</span></span><br><span class="line">        postOrder(T-&gt;rchild);</span><br><span class="line">        <span class="comment">// 后办事</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* T;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    createTree(&amp;T, argv[<span class="number">1</span>], &amp;index);</span><br><span class="line">    preOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    inOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    postOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-8-暴力匹配</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/</id>
    <published>2025-02-25T06:38:49.000Z</published>
    <updated>2025-02-25T06:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力匹配</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span>       //定义字符串结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125; String;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String* <span class="title function_">initString</span><span class="params">()</span>                                <span class="comment">//初始化字符串 </span></span><br><span class="line">&#123;</span><br><span class="line">    String* s = (String*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(String));    <span class="comment">//为字符串开辟动态内存空间</span></span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>;                                 <span class="comment">//为</span></span><br><span class="line">    s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stringAssign</span><span class="params">(String* s, <span class="type">char</span>* data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;data) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* temp = data;</span><br><span class="line">    <span class="keyword">while</span> (*temp) </span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        temp = data;</span><br><span class="line">        s-&gt;len = len;</span><br><span class="line">        s-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++, temp++) </span><br><span class="line">        &#123;</span><br><span class="line">            s-&gt;data[i] = *temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printString</span><span class="params">(String* s)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s-&gt;len; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(i == <span class="number">0</span> ? <span class="string">&quot;%c &quot;</span> : <span class="string">&quot;-&gt; %c &quot;</span>, s-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">forceMatch</span><span class="params">(String* master, String* sub)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp; j &lt; sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;data[i] == sub-&gt;data[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == sub-&gt;len) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match success.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;force match fail.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    String* s = initString();</span><br><span class="line">    String* s1 = initString();</span><br><span class="line">    stringAssign(s, argv[<span class="number">1</span>]);</span><br><span class="line">    stringAssign(s1, argv[<span class="number">2</span>]);</span><br><span class="line">    printString(s);</span><br><span class="line">    printString(s1);</span><br><span class="line">    forceMatch(s, s1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-7-循环队列</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</id>
    <published>2025-02-25T06:37:49.000Z</published>
    <updated>2025-02-25T06:37:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Queue* <span class="title function_">initQueue</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要知道队列当前有多少个元素</span></span><br><span class="line">    <span class="type">int</span> length = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">    <span class="type">int</span> index = Q-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, Q-&gt;data[index]);</span><br><span class="line">        index = (index + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">enQueue</span><span class="params">(Queue* Q, <span class="type">int</span> data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = data;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Queue* Q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data = Q-&gt;data[Q-&gt;front];</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue* Q = initQueue();</span><br><span class="line">    enQueue(Q, <span class="number">1</span>);</span><br><span class="line">    enQueue(Q, <span class="number">2</span>);</span><br><span class="line">    enQueue(Q, <span class="number">3</span>);</span><br><span class="line">    enQueue(Q, <span class="number">4</span>);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    printQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-6-栈</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</id>
    <published>2025-02-25T06:36:49.000Z</published>
    <updated>2025-02-25T06:36:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义栈结点的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *<span class="title function_">initStack</span><span class="params">()</span>                               <span class="comment">//初始化栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));     <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L-&gt;data = <span class="number">0</span>;                                <span class="comment">//data初始化</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                             <span class="comment">//头结点next指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> L;                                   <span class="comment">//返回头结点的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Node *L, <span class="type">int</span> data)</span>                    <span class="comment">//入栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                          <span class="comment">//为data赋值</span></span><br><span class="line">    node-&gt;next = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    L-&gt;next = node;                             <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    L-&gt;data++;                                  <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Node *L)</span>                            <span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span>)                       <span class="comment">//判断栈是否为空栈 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//是空栈则返回 1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Node *node = L-&gt;next;               <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        <span class="type">int</span> data = node-&gt;data;              <span class="comment">//将头结点的下一结点的data 赋值给 data</span></span><br><span class="line">        L-&gt;next = node-&gt;next;               <span class="comment">//将头结点的下一结点的next 赋值给头结点的next</span></span><br><span class="line">        <span class="built_in">free</span>(node);                         <span class="comment">//释放头结点的下一结点的动态内存空间</span></span><br><span class="line">        L-&gt;data--;                          <span class="comment">//将头结点的data--</span></span><br><span class="line">        <span class="keyword">return</span> data;                        <span class="comment">//返回取出的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node *L)</span>                        <span class="comment">//判断是否为空栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;data == <span class="number">0</span> || L-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//判断头结点的data == 0 或者 头结点的next的值为NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">//返回 1，代表此栈为空栈</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                           <span class="comment">//返回 0，代表此栈不是空栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Node *<span class="built_in">stack</span>)</span>            <span class="comment">//打印栈</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = <span class="built_in">stack</span>-&gt;next;           <span class="comment">//将头结点的next的值 赋值给node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                        <span class="comment">//判断node是否为NULL</span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);   <span class="comment">//打印node的data</span></span><br><span class="line">        node = node-&gt;next;              <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node *<span class="built_in">stack</span> = initStack();          <span class="comment">//创建栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">1</span>);                     <span class="comment">//1 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">2</span>);                     <span class="comment">//2 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">3</span>);                     <span class="comment">//3 入栈</span></span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="number">4</span>);                     <span class="comment">//4 入栈</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pop = %d\n&quot;</span>, pop(<span class="built_in">stack</span>));   <span class="comment">//出战</span></span><br><span class="line">    printStack(<span class="built_in">stack</span>);                  <span class="comment">//打印栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-5-队列</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</id>
    <published>2025-02-25T06:35:49.000Z</published>
    <updated>2025-02-25T06:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="comment">//往头结点前面入队 ，从头结点后面出队</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义队列的结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initQueue</span><span class="params">()</span>                               <span class="comment">//初始化队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为头结点分配动态内春空间</span></span><br><span class="line">    Q-&gt;data = <span class="number">0</span>;                </span><br><span class="line">    Q-&gt;pre = Q;                                 <span class="comment">//初始化pre</span></span><br><span class="line">    Q-&gt;next = Q;                                <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Node* Q, <span class="type">int</span> data)</span>                         <span class="comment">//入队       </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));           <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node-&gt;data = data;                                  <span class="comment">//为新结点赋值</span></span><br><span class="line">    node-&gt;next = Q;                                     <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    node-&gt;pre = Q-&gt;pre;                                 <span class="comment">//将头结点的pre的值 赋值给 新结点的pre</span></span><br><span class="line">    Q-&gt;pre-&gt;next = node;                                <span class="comment">//将新结点的地址 赋值给 头结点的pre指向的结点的next</span></span><br><span class="line">    Q-&gt;pre = node;                                      <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    Q-&gt;data++;                                          <span class="comment">//头结点的data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Node* Q)</span>                                    <span class="comment">//判队列是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;data == <span class="number">0</span> || Q-&gt;next == Q)                   <span class="comment">//如果头结点的data == 0，或者头结点的next == 自己</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                       <span class="comment">//返回 1，代表队列为空</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0，代表队列不为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deQueue</span><span class="params">(Node* Q)</span>                                    <span class="comment">//出队</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(Q))                                     <span class="comment">//判断队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//为空则返回 0</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;                                          </span><br><span class="line">        Node* node = Q-&gt;next;                           <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next;                        <span class="comment">//将头结点的next指向的结点的next的值 赋值给 头结点的next</span></span><br><span class="line">        Q-&gt;next-&gt;pre = Q;                               <span class="comment">//将头结点的地址 赋值给 头结点的next指向的结点的pre</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;data;                              <span class="comment">//返回出队结点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Node* Q)</span>                                <span class="comment">//打印队列</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = Q -&gt; next;                             <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != Q)                                   <span class="comment">//判断node 是否是头结点的地址       </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);                 <span class="comment">//打印node的data</span></span><br><span class="line">        node = node -&gt; next;                            <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node* Q = initQueue();                      <span class="comment">//初始化队列</span></span><br><span class="line">    enQueue(Q, <span class="number">1</span>);                              <span class="comment">//1 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">2</span>);                              <span class="comment">//2 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">3</span>);                              <span class="comment">//3 入队</span></span><br><span class="line">    enQueue(Q, <span class="number">4</span>);                              <span class="comment">//4 入队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dequeue = %d\n&quot;</span>, deQueue(Q));       <span class="comment">//出队</span></span><br><span class="line">    printQueue(Q);                              <span class="comment">//打印队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-4-双循环链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:34:49.000Z</published>
    <updated>2025-02-25T06:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>                 //定义结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化头结点，创建链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//为头结点分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化头结点的data</span></span><br><span class="line">    L -&gt; pre = L;                           <span class="comment">//初始化头结点的pre，指向自己</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化头结点的next，指向next</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//为新结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的next的值 赋值给 新结点的next</span></span><br><span class="line">    node -&gt; pre = L;                            <span class="comment">//将头头结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    L -&gt; next -&gt; pre = node;                    <span class="comment">//将新结点的地址 赋值给 原来头结点的下一个结点的pre</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 头结点的next </span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L)                     <span class="comment">//判断node是否是最后一个结点</span></span><br><span class="line">    &#123;                                           <span class="comment">//如果不是</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点分配动态内存空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将原来最后一个结点的地址 赋值给 新结点的pre</span></span><br><span class="line">    n -&gt; next = L;                              <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; pre = n;                               <span class="comment">//将新结点的地址 赋值给 头结点的pre</span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点data++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                       <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                         <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node != L)                               <span class="comment">//判断node 是否是 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)                   <span class="comment">//判断node是否是目标结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next的值 赋值给 目标结点的pre指向的结点的next</span></span><br><span class="line">            node -&gt; next -&gt; pre = node -&gt; pre;      <span class="comment">//将目标结点的pre的值  赋值给 目标结点的next指向的结点的pre</span></span><br><span class="line">            <span class="built_in">free</span>(node);                             <span class="comment">//释放目标结点的动态内存空间</span></span><br><span class="line">            L -&gt; data --;                           <span class="comment">//头结点的data--</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;                               <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                        <span class="comment">//如果不是目标结点，更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                       <span class="comment">//返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点的next的值 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否是 目标结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;data);           <span class="comment">//打印node的值</span></span><br><span class="line">        node = node-&gt;next;                      <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">///打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();           <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);               <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);               <span class="comment">//头插 2</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);               <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);               <span class="comment">//头插 5</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);               <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);               <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">7</span>);                   <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);                   <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-3-双链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:32:49.000Z</published>
    <updated>2025-02-25T06:32:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>             //创建结点结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;   Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//创建链表头结点，分配动态内存空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化链表结点数</span></span><br><span class="line">    L -&gt; pre = <span class="literal">NULL</span>;                        <span class="comment">//初始化pre</span></span><br><span class="line">    L -&gt; next = <span class="literal">NULL</span>;                       <span class="comment">//初始化next</span></span><br><span class="line">    <span class="keyword">return</span> L;                               <span class="comment">//返沪Node类型的指针L</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>           <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//开辟结点动态内存空间</span></span><br><span class="line">    node -&gt; data = data;                     <span class="comment">//结点赋值</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                <span class="comment">//将头结点next指向的结点地址 赋值给 新的结点</span></span><br><span class="line">    node -&gt; pre = L;                         <span class="comment">//新结点的pre指向头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L -&gt; next)                           <span class="comment">//判断头结点的next是否是NULL</span></span><br><span class="line">    &#123;                                        <span class="comment">//如果不为空</span></span><br><span class="line">        L -&gt; next -&gt; pre = node;             <span class="comment">//将新结点的地址 赋值给 头结点下一个结点的 pre</span></span><br><span class="line">        L -&gt; next = node;                    <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                     <span class="comment">//当链表中只有头结点时</span></span><br><span class="line">    &#123; </span><br><span class="line">        L -&gt; next = node;                       <span class="comment">//将新结点的地址 赋值给 头结点的next</span></span><br><span class="line">    &#125;</span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点的地址 赋值给 node</span></span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//为新结点赋值</span></span><br><span class="line">    <span class="keyword">while</span> (node -&gt; next)                        <span class="comment">//遍历到链表最后一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;                                           <span class="comment">//node此时为尾结点</span></span><br><span class="line">    n -&gt; next = node -&gt; next;                   <span class="comment">//将尾结点next指向的地址 赋值给 新结点的next     </span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//将尾结点的next指向n   </span></span><br><span class="line">    n -&gt; pre = node;                            <span class="comment">//将新结点的pre指向原来的尾结点</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;                                  </span><br><span class="line">    Node* node = L-&gt;next;                       <span class="comment">//将头结点next指向的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//如果node不为空结点</span></span><br><span class="line">    &#123;                             </span><br><span class="line">        <span class="keyword">if</span> (node -&gt; data == data)               <span class="comment">//如果node是目标结点 </span></span><br><span class="line">        &#123;     </span><br><span class="line">            node -&gt; pre -&gt; next = node -&gt; next; <span class="comment">//将node的next 赋值给 node上一个结点的next</span></span><br><span class="line">            <span class="keyword">if</span> (node -&gt; next)                   <span class="comment">//如果node不是尾结点</span></span><br><span class="line">            &#123;                                       </span><br><span class="line">                node -&gt; next -&gt; pre = node -&gt; pre;  <span class="comment">//将node的pre 赋值给 node下一结点的pre</span></span><br><span class="line">            &#125;</span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点数据 --</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放node的空间</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//找到目标值，删除成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//node更新为下一结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到值，删除失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点指向的结点 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span> (node)                                <span class="comment">//当node不为空时， </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node -&gt; data);         <span class="comment">//打印node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node为下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//当node为空结点时打印NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();                       <span class="comment">//创建链表，初始化头结点</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);                           <span class="comment">//头插1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);                           <span class="comment">//头插2</span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);                           <span class="comment">//头插3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);                           <span class="comment">//头插4</span></span><br><span class="line">    tailInsert(L, <span class="number">5</span>);                           <span class="comment">//尾插5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);                           <span class="comment">//尾插6</span></span><br><span class="line">    printList(L);                               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">6</span>);                               <span class="comment">//删除6</span></span><br><span class="line">    printList(L);                               <span class="comment">//删除链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-2-单循环链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%BE%AA%E7%8E%AF%E8%BF%9E%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:31:49.000Z</published>
    <updated>2025-02-25T06:31:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单循环链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>         //定义结点结构体</span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;               <span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>      <span class="comment">//结构体指针，指向下一个结点</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                            <span class="comment">//初始化结构体，创建头结点 </span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//开辟口结点空间</span></span><br><span class="line">    L -&gt; data = <span class="number">0</span>;                          <span class="comment">//初始化data数据</span></span><br><span class="line">    L -&gt; next = L;                          <span class="comment">//初始化指针，指向自己</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//开辟结点空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将数据赋值给data</span></span><br><span class="line">    node -&gt; next = L -&gt; next;                   <span class="comment">//将头结点的的next 赋值给 新结点的next</span></span><br><span class="line">    L -&gt; next = node;                           <span class="comment">//新结点的地址 赋值给 头结点的node</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span>              <span class="comment">//尾插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* n = L;                                <span class="comment">//将头结点 赋值给 n</span></span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//为新结点开辟空间</span></span><br><span class="line">    node -&gt; data = data;                        <span class="comment">//将data 赋值给 新结点的data</span></span><br><span class="line">    <span class="keyword">while</span>(n -&gt; next != L)                       <span class="comment">//使用遍历，判断n的next 是否 指向 头结点，找到最后一个结点</span></span><br><span class="line">    &#123;       </span><br><span class="line">        n = n -&gt; next;                          <span class="comment">//不是则更新n</span></span><br><span class="line">    &#125;</span><br><span class="line">    node -&gt; next = L;                           <span class="comment">//将头结点的地址 赋值给 新结点的next</span></span><br><span class="line">    n -&gt; next = node;                           <span class="comment">//将新结点的地址 赋值给 原来最后一个结点的next</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点数据++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                   <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* preNode = L;                          <span class="comment">//将头结点的地址 赋值给 preNode</span></span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next存储的地址 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node的 地址 是否等于 头结点的地址</span></span><br><span class="line">    &#123;               </span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)                <span class="comment">//判断node的data 是否等于 目标值</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;     <span class="comment">//将目标结点的next值 赋值给 前一个结点的next</span></span><br><span class="line">            <span class="built_in">free</span>(node);                         <span class="comment">//释放目标结点 动态内存空间</span></span><br><span class="line">            L -&gt; data --;                       <span class="comment">//头结点的数据--</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        <span class="comment">//返回 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;                         <span class="comment">//更新preNode</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;                               <span class="comment">//未找到目标结点，返回 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                         <span class="comment">//打印链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                     <span class="comment">//将头结点的next 赋值给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node != L)                            <span class="comment">//判断node 是否等于 头结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node -&gt; data);           <span class="comment">//打应node的值</span></span><br><span class="line">        node = node -&gt; next;                    <span class="comment">//更新node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);                           <span class="comment">//单循环链表，最后一个结点的next应指向头结点，此处代码错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = initList();       <span class="comment">//初始化链表</span></span><br><span class="line">    headInsert(L, <span class="number">1</span>);           <span class="comment">//头插 1</span></span><br><span class="line">    headInsert(L, <span class="number">2</span>);           <span class="comment">//头插 2 </span></span><br><span class="line">    headInsert(L, <span class="number">3</span>);           <span class="comment">//头插 3</span></span><br><span class="line">    headInsert(L, <span class="number">4</span>);           <span class="comment">//头插 4</span></span><br><span class="line">    headInsert(L, <span class="number">5</span>);           <span class="comment">//头插 5</span></span><br><span class="line">    tailInsert(L, <span class="number">6</span>);           <span class="comment">//尾插 6</span></span><br><span class="line">    tailInsert(L, <span class="number">7</span>);           <span class="comment">//尾插 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    delete(L, <span class="number">4</span>);               <span class="comment">//删除 4</span></span><br><span class="line">    delete(L, <span class="number">7</span>);               <span class="comment">//删除 7</span></span><br><span class="line">    printList(L);               <span class="comment">//打印链表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-1-单链表</title>
    <link href="https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>https://ydw-item.github.io.git/2025/02/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2025-02-25T06:30:49.000Z</published>
    <updated>2025-02-25T06:30:49.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>     //定义一个结点的数据结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">//数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;   Node;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">initList</span><span class="params">()</span>                                <span class="comment">//创建链表头</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));   <span class="comment">//开辟空间</span></span><br><span class="line">    <span class="built_in">list</span> -&gt;data = <span class="number">0</span>;                            <span class="comment">//头结点值为0</span></span><br><span class="line">    <span class="built_in">list</span> -&gt;next = <span class="literal">NULL</span>;                         <span class="comment">//头结点 指向 NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">headInsert</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span>          <span class="comment">//头插法</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//开辟空间   </span></span><br><span class="line">    node -&gt; data = data;                       <span class="comment">//给新结点赋值</span></span><br><span class="line">    node -&gt; next = <span class="built_in">list</span> -&gt; next;               <span class="comment">//新结点的指针 指向 下一个结点</span></span><br><span class="line">    <span class="built_in">list</span> -&gt; next = node;                       <span class="comment">//头结点的指针 指向 新结点</span></span><br><span class="line">    <span class="built_in">list</span> -&gt; data++;                            <span class="comment">//头结点数据++，代表链表中的结点增多</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L;                             <span class="comment">//将头结点赋值给node</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; L -&gt; data; i++)          <span class="comment">//遍历原来的尾结点，i&lt;非头结点的结点数量</span></span><br><span class="line">    &#123;       </span><br><span class="line">        node = node-&gt;next;                      <span class="comment">//两个非头结点移一次，</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node* n = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));      <span class="comment">//给新结点开辟内存空间</span></span><br><span class="line">    n -&gt; data = data;                           <span class="comment">//给新结点赋值</span></span><br><span class="line">    n -&gt; next = <span class="literal">NULL</span>;                           <span class="comment">//将新结点指向NULL</span></span><br><span class="line">    node -&gt; next = n;                           <span class="comment">//原来的为节点node指向 新的尾结点n</span></span><br><span class="line">    L -&gt; data ++;                               <span class="comment">//头结点的值++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span>                    <span class="comment">//删除结点</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* preNode = L;                            <span class="comment">//将头结点赋值给preNode</span></span><br><span class="line">    Node* node = L -&gt; next;                       <span class="comment">//将头结点的指向的地址赋给 node</span></span><br><span class="line">    <span class="keyword">while</span>(node)                                   <span class="comment">//当node的地址不为空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node -&gt; data == data)                  <span class="comment">//判断node的值是否等于要删除的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            preNode -&gt; next = node -&gt; next;    <span class="comment">//将目标结点指向的地址 赋值给 上一个结点的指针</span></span><br><span class="line">            <span class="built_in">free</span>(node);                           <span class="comment">//释放空间</span></span><br><span class="line">            L -&gt; data--;                          <span class="comment">//链表个数--</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;                        </span><br><span class="line">        &#125;</span><br><span class="line">        preNode = node;                          <span class="comment">//不等于,头节点等于node</span></span><br><span class="line">        node = node -&gt; next;                     <span class="comment">//不等于，node等于node指向的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node* L)</span>                          <span class="comment">//打印链表中的数据</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L -&gt; next;                      <span class="comment">//将头节点指向的结点赋值给node</span></span><br><span class="line">    <span class="keyword">while</span>(node)                                  <span class="comment">//当node不是尾结点时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;node = %d \n&quot;</span>,node -&gt; data);     <span class="comment">//打印node的值</span></span><br><span class="line">        node = node -&gt; next;                     <span class="comment">//更新node的结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    Node* <span class="built_in">list</span> = initList();</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">1</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">2</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">3</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">4</span>);</span><br><span class="line">    headInsert(<span class="built_in">list</span>,<span class="number">5</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">6</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">7</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">8</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">9</span>);</span><br><span class="line">    tailInsert(<span class="built_in">list</span>,<span class="number">10</span>);</span><br><span class="line">    printList(<span class="built_in">list</span>);</span><br><span class="line">    delete(<span class="built_in">list</span>,<span class="number">9</span>);</span><br><span class="line">    printList(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://ydw-item.github.io.git/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-PIN</title>
    <link href="https://ydw-item.github.io.git/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/"/>
    <id>https://ydw-item.github.io.git/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/</id>
    <published>2025-02-19T06:22:05.000Z</published>
    <updated>2025-02-19T06:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-设置引脚模式-rt-pin-mode"><a href="#1-设置引脚模式-rt-pin-mode" class="headerlink" title="1. 设置引脚模式 rt_pin_mode()"></a>1. 设置引脚模式 rt_pin_mode()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/1.png" alt="image-20250219155159103"> </p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">PIN_MODE_OUTPUT</td><td align="center">输出</td></tr><tr><td align="center">PIN_MODE_INPUT</td><td align="center">输入</td></tr><tr><td align="center">PIN_MODE_INPUT_PULLUP</td><td align="center">上拉输入</td></tr><tr><td align="center">PIN_MODE_INPUT_PULLDOWN</td><td align="center">下拉输入</td></tr><tr><td align="center">PIN_MODE_OUTPUT_OD</td><td align="center">开漏输出</td></tr></tbody></table><h2 id="2-设置引脚电平-rt-pin-write"><a href="#2-设置引脚电平-rt-pin-write" class="headerlink" title="2. 设置引脚电平 rt_pin_write()"></a>2. 设置引脚电平 rt_pin_write()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/2.png" alt="image-20250219155633545"></p><h2 id="3-读取引脚电平-rt-pin-read"><a href="#3-读取引脚电平-rt-pin-read" class="headerlink" title="3. 读取引脚电平 rt_pin_read ()"></a>3. 读取引脚电平 rt_pin_read ()</h2><p><img src="/2025/02/19/RTOS/RT-Thread/RT-Thread-3-PIN/image-20250219161129046.png" alt="image-20250219161129046"></p><h2 id="4-绑定引脚中断回调函数-rt-pin-attach-irq"><a href="#4-绑定引脚中断回调函数-rt-pin-attach-irq" class="headerlink" title="4. 绑定引脚中断回调函数 rt_pin_attach_irq ()"></a>4. 绑定引脚中断回调函数 rt_pin_attach_irq ()</h2><h2 id="5-脱离引脚中断回调函数-rt-pin-detach-irq"><a href="#5-脱离引脚中断回调函数-rt-pin-detach-irq" class="headerlink" title="5.脱离引脚中断回调函数 rt_pin_detach_irq ()"></a>5.脱离引脚中断回调函数 rt_pin_detach_irq ()</h2><h2 id="6-使能-屏蔽引脚中断-rt-pin-irq-enable"><a href="#6-使能-屏蔽引脚中断-rt-pin-irq-enable" class="headerlink" title="6. 使能 &#x2F; 屏蔽引脚中断 rt_pin_irq_enable ()"></a>6. 使能 &#x2F; 屏蔽引脚中断 rt_pin_irq_enable ()</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-设置引脚模式-rt-pin-mode&quot;&gt;&lt;a href=&quot;#1-设置引脚模式-rt-pin-mode&quot; class=&quot;headerlink&quot; title=&quot;1. 设置引脚模式 rt_pin_mode()&quot;&gt;&lt;/a&gt;1. 设置引脚模式 rt_pin_mode()</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-IO</title>
    <link href="https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/"/>
    <id>https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/</id>
    <published>2025-02-17T09:44:05.000Z</published>
    <updated>2025-02-17T09:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、drv-gpio-c"><a href="#一、drv-gpio-c" class="headerlink" title="一、drv_gpio.c"></a>一、drv_gpio.c</h1><h1 id="1-1在drv-common-c中调用rt-hw-pin-init-函数"><a href="#1-1在drv-common-c中调用rt-hw-pin-init-函数" class="headerlink" title="1.1在drv_common,c中调用rt_hw_pin_init()函数"></a>1.1在drv_common,c中调用rt_hw_pin_init()函数</h1><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/1.png" alt="image-20250217174741243"></p><h2 id="1-2-rt-hw-pin-init"><a href="#1-2-rt-hw-pin-init" class="headerlink" title="1.2 rt_hw_pin_init()"></a>1.2 rt_hw_pin_init()</h2><p>启用 STM32 微控制器中 <strong>GPIOA</strong> 外设的时钟</p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/2.png" alt="image-20250217175841655"></p><h1 id="1-3-pins"><a href="#1-3-pins" class="headerlink" title="1.3 pins[]"></a>1.3 pins[]</h1><p><strong>为每个pin定义编号</strong></p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/3.png" alt="image-20250217181636459"></p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-IO/4.png" alt="image-20250217181926120"></p><p>这个宏会创建一个结构体，结构体中包含了三个成员：</p><ul><li><code>index</code>：通常是一个标识符或索引，用于标识该引脚的具体位置。</li><li><code>GPIO##gpio</code>：指定了 GPIO 端口（如 <code>GPIOA</code>、<code>GPIOB</code> 等）。</li><li><code>GPIO_PIN_##gpio_index</code>：指定了具体的引脚（如 <code>GPIO_PIN_0</code>、<code>GPIO_PIN_1</code> 等）。</li></ul><h1 id="stm32-pin-write"><a href="#stm32-pin-write" class="headerlink" title="stm32_pin_write"></a>stm32_pin_write</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stm32_pin_write</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin, <span class="type">rt_base_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_WritePin(index-&gt;gpio, index-&gt;pin, (GPIO_PinState)value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stm32-pin-read"><a href="#stm32-pin-read" class="headerlink" title="stm32_pin_read"></a>stm32_pin_read</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">stm32_pin_read</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line"></span><br><span class="line">    value = PIN_LOW;</span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    value = HAL_GPIO_ReadPin(index-&gt;gpio, index-&gt;pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stm32-pin-mode"><a href="#stm32-pin-mode" class="headerlink" title="stm32_pin_mode"></a>stm32_pin_mode</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">atic <span class="type">void</span> <span class="title function_">stm32_pin_mode</span><span class="params">(<span class="type">rt_device_t</span> dev, <span class="type">rt_base_t</span> pin, <span class="type">rt_base_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_index</span> *<span class="title">index</span>;</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">    index = get_pin(pin);</span><br><span class="line">    <span class="keyword">if</span> (index == RT_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configure GPIO_InitStructure */</span></span><br><span class="line">    GPIO_InitStruct.Pin = index-&gt;pin;</span><br><span class="line">    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">    GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == PIN_MODE_OUTPUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* output setting */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: not pull. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT_PULLUP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: pull up. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_PULLUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_INPUT_PULLDOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* input setting: pull down. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_PULLDOWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mode == PIN_MODE_OUTPUT_OD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* output setting: od. */</span></span><br><span class="line">        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;</span><br><span class="line">        GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HAL_GPIO_Init(index-&gt;gpio, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、drv-gpio-c&quot;&gt;&lt;a href=&quot;#一、drv-gpio-c&quot; class=&quot;headerlink&quot; title=&quot;一、drv_gpio.c&quot;&gt;&lt;/a&gt;一、drv_gpio.c&lt;/h1&gt;&lt;h1 id=&quot;1-1在drv-common-c中调用rt-hw-</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-2-时钟管理</title>
    <link href="https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://ydw-item.github.io.git/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/</id>
    <published>2025-02-17T08:44:05.000Z</published>
    <updated>2025-02-17T08:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、时钟节拍"><a href="#一、时钟节拍" class="headerlink" title="一、时钟节拍"></a>一、时钟节拍</h1><ul><li><p>时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用，一般是 1ms–100ms，时钟节拍率越快，系统的实时响应越快，但是系统的额外开销就越大，从系统启动开始计数的时钟节拍数称为系统时间。</p></li><li><p>时钟节拍的长度可以根据 RT_TICK_PER_SECOND 的定义来调整，等于 1&#x2F;RT_TICK_PER_SECOND 秒。</p><p>  <img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/1.png" alt="image-20250217164837198"></p></li></ul><h1 id="二、时钟节拍的实现方式"><a href="#二、时钟节拍的实现方式" class="headerlink" title="二、时钟节拍的实现方式"></a>二、时钟节拍的实现方式</h1><p>中断触发模式的硬件定时器产生，当中断到来时，将调用一次：void rt_tick_increase(void)，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SysTick_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 进入中断 */</span></span><br><span class="line">    rt_interrupt_enter();</span><br><span class="line">    ……</span><br><span class="line">    rt_tick_increase();</span><br><span class="line">    <span class="comment">/* 退出中断 */</span></span><br><span class="line">    rt_interrupt_leave();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中断函数中调用 rt_tick_increase() 对全局变量 rt_tick 进行自加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_tick_increase</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 全局变量 rt_tick 自加 */</span></span><br><span class="line">    ++ rt_tick;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查时间片 */</span></span><br><span class="line">    thread = rt_thread_self();</span><br><span class="line"></span><br><span class="line">    -- thread-&gt;remaining_tick;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;remaining_tick == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 重新赋初值 */</span></span><br><span class="line">        thread-&gt;remaining_tick = thread-&gt;init_tick;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 线程挂起 */</span></span><br><span class="line">        rt_thread_yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查定时器 */</span></span><br><span class="line">    rt_timer_check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rt_tick 的值表示了系统<strong>从启动开始</strong>总共经过的时钟节拍数，即<strong>系统时间</strong></p><p>每经过一个时钟节拍时，都会检查当前线程的时间片是否用完，以及是否有定时器超时。</p><h1 id="三、获取时钟节拍"><a href="#三、获取时钟节拍" class="headerlink" title="三、获取时钟节拍"></a>三、获取时钟节拍</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_tick_t</span> <span class="title function_">rt_tick_get</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="四、定时器管理"><a href="#四、定时器管理" class="headerlink" title="四、定时器管理"></a>四、定时器管理</h1><ul><li><strong>硬件定时器</strong>是芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。硬件定时器的精度一般很高，可以达到纳秒级别，并且是中断触发方式。</li><li><strong>软件定时器</strong>是由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。</li><li>RT-Thread 操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是 OS Tick 的整数倍，例如一个 OS Tick 是 10ms，那么上层软件定时器只能是 10ms，20ms，100ms 等，而不能定时为 15ms。RT-Thread 的定时器也基于系统的节拍，提供了基于节拍整数倍的定时能力。</li></ul><h1 id="五、RT-Thread定时器介绍"><a href="#五、RT-Thread定时器介绍" class="headerlink" title="五、RT-Thread定时器介绍"></a>五、RT-Thread定时器介绍</h1><p>RT-Thread 的定时器提供两类定时器机制：</p><ul><li>第一类是单次触发定时器，这类定时器在启动后只会触发一次定时器事件，然后定时器自动停止。</li><li>第二类是周期触发定时器，这类定时器会周期性的触发定时器事件，直到用户手动的停止，否则将永远持续执行下去。</li></ul><p>超时函数执行时所处的上下文环境，RT-Thread 的定时器可以分为 HARD_TIMER 模式与 SOFT_TIMER 模式</p><p><img src="/2025/02/17/RTOS/RT-Thread/RT-Thread-2-%E6%97%B6%E9%92%9F%E7%AE%A1%E7%90%86/2.png" alt="定时器上下文环境"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、时钟节拍&quot;&gt;&lt;a href=&quot;#一、时钟节拍&quot; class=&quot;headerlink&quot; title=&quot;一、时钟节拍&quot;&gt;&lt;/a&gt;一、时钟节拍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;时钟节拍是特定的周期性中断，这个中断可以看做是系统心跳，中断之间的时间间隔取决于不同的应用</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-1-线程管理</title>
    <link href="https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2025-02-16T07:47:05.000Z</published>
    <updated>2025-02-16T07:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程栈"><a href="#一、线程栈" class="headerlink" title="一、线程栈"></a>一、线程栈</h1><ul><li>RT-Thread 线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复。</li><li>线程栈还用来存放函数中的局部变量：函数中的局部变量从线程栈空间中申请；函数中局部变量初始时从寄存器中分配（ARM 架构），当这个函数再调用另一个函数时，这些局部变量将放入栈中。</li></ul><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/1.png" alt="线程栈 (ARM)"></p><ul><li>线程栈大小可以这样设定，对于资源相对较大的 MCU，可以适当设计较大的线程栈；也可以在初始时设置较大的栈，例如指定大小为 1K 或 2K 字节，然后在 <strong>FinSH</strong> 中用 <strong>list_thread</strong> 命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的<strong>最大栈深度</strong>，而后加上适当的余量形成最终的线程栈大小，最后对栈空间大小加以修改。</li></ul><h1 id="二、线程状态"><a href="#二、线程状态" class="headerlink" title="二、线程状态"></a>二、线程状态</h1><table><thead><tr><th>状态</th><th align="center">描述</th></tr></thead><tbody><tr><td>初始状态</td><td align="center">当线程刚开始创建还没开始运行时就处于初始状态；在初始状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_INIT</td></tr><tr><td>就绪状态</td><td align="center">在就绪状态下，线程按照优先级排队，等待被执行；一旦当前线程运行完毕让出处理器，操作系统会马上寻找最高优先级的就绪态线程运行。此状态在 RT-Thread 中的宏定义为 RT_THREAD_READY</td></tr><tr><td>运行状态</td><td align="center">线程当前正在运行。在单核系统中，只有 rt_thread_self() 函数返回的线程处于运行状态；在多核系统中，可能就不止这一个线程处于运行状态。此状态在 RT-Thread 中的宏定义为 RT_THREAD_RUNNING</td></tr><tr><td>挂起状态</td><td align="center">也称阻塞态。它可能因为资源不可用而挂起等待，或线程主动延时一段时间而挂起。在挂起状态下，线程不参与调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_SUSPEND</td></tr><tr><td>关闭状态</td><td align="center">当线程运行结束时将处于关闭状态。关闭状态的线程不参与线程的调度。此状态在 RT-Thread 中的宏定义为 RT_THREAD_CLOSE</td></tr></tbody></table><h1 id="三、线程优先级"><a href="#三、线程优先级" class="headerlink" title="三、线程优先级"></a>三、线程优先级</h1><p>RT-Thread 最大支持 256 个线程优先级 (0~255)，<strong>数值越小的优先级越高</strong>，0 为最高优先级。在一些资源比较紧张的系统中，可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置；对于 <strong>ARM Cortex-M</strong> 系列，<strong>普遍采用 32 个优先级</strong>。最低优先级<strong>默认分配给空闲线程</strong>使用，用户一般不使用。在系统中，当有比当前线程优先级更高的线程就绪时，当前线程将<strong>立刻被换出</strong>，高优先级线程抢占处理器运行。(YDW：并不会等到线程此次允许结束)</p><h1 id="四、时间片"><a href="#四、时间片" class="headerlink" title="四、时间片"></a>四、时间片</h1><ul><li><p>每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效</p></li><li><p>时间片起到约束线程单次运行时长的作用，其单位是一个系统节拍（OS Tick）</p></li></ul><h1 id="五、线程的入口函数"><a href="#五、线程的入口函数" class="headerlink" title="五、线程的入口函数"></a>五、线程的入口函数</h1><p><strong>无限循环模式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* paramenter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 等待事件的发生 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对事件进行服务、进行处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-<strong>顺序执行或有限次循环模式：</strong></p><ul><li><strong>在执行完毕后，线程将被系统自动删除。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">thread_entry</span><span class="params">(<span class="type">void</span>* parameter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 处理事务 #1 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #2 */</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* 处理事务 #3 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、线程错误码"><a href="#六、线程错误码" class="headerlink" title="六、线程错误码"></a>六、线程错误码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EOK           0 <span class="comment">/* 无错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ERROR         1 <span class="comment">/* 普通错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ETIMEOUT      2 <span class="comment">/* 超时错误     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EFULL         3 <span class="comment">/* 资源已满     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EEMPTY        4 <span class="comment">/* 无资源     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOMEM        5 <span class="comment">/* 无内存     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_ENOSYS        6 <span class="comment">/* 系统不支持     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EBUSY         7 <span class="comment">/* 系统忙     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EIO           8 <span class="comment">/* IO 错误       */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINTR         9 <span class="comment">/* 中断系统调用   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_EINVAL       10 <span class="comment">/* 非法参数      */</span></span></span><br></pre></td></tr></table></figure><h1 id="七、线程状态切换"><a href="#七、线程状态切换" class="headerlink" title="七、线程状态切换"></a>七、线程状态切换</h1><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/2.png" alt="线程状态转换图"></p><ul><li>线程通过调用函数 rt_thread_create&#x2F;init() 进入到初始状态（RT_THREAD_INIT）；初始状态的线程通过调用函数 rt_thread_startup() 进入到就绪状态（RT_THREAD_READY）；</li><li>就绪状态的线程被调度器调度后进入运行状态（RT_THREAD_RUNNING）；</li><li>当处于运行状态的线程调用 rt_thread_delay()，rt_sem_take()，rt_mutex_take()，rt_mb_recv() 等函数或者获取不到资源时，将进入到挂起状态（RT_THREAD_SUSPEND）；</li><li>处于挂起状态的线程，如果等待超时依然未能获得资源或由于其他线程释放了资源，那么它将返回到就绪状态。挂起状态的线程，如果调用 rt_thread_delete&#x2F;detach() 函数，将更改为关闭状态（RT_THREAD_CLOSE）；</li><li>而运行状态的线程，如果运行结束，就会在线程的最后部分执行 rt_thread_exit() 函数，将状态更改为关闭状态。</li></ul><h1 id="八、系统线程"><a href="#八、系统线程" class="headerlink" title="八、系统线程"></a>八、系统线程</h1><p><strong>在 RT-Thread 内核中的系统线程有空闲线程和主线程。</strong></p><h1 id="九、空闲线程"><a href="#九、空闲线程" class="headerlink" title="九、空闲线程"></a>九、空闲线程</h1><ul><li>空闲线程状态永远为就绪态，当系统中无其他就绪线程存在时，调度器将调度到空闲线程，它通常是一个<strong>死循环</strong>，且<strong>永远不能被挂起</strong>。</li><li>若某线程运行完毕，系统将<strong>自动删除线程</strong>：自动执行 rt_thread_exit() 函数，先将该线程从系统<strong>就绪队列中删除</strong>，再将该线程的状态更改为<strong>关闭状态</strong>，不再参与系统调度，然后挂入 rt_thread_defunct <strong>僵尸队列</strong>（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。</li><li>空闲线程也提供了接口来运行用户设置的<strong>钩子函</strong>数，在空闲线程运行时会调用该钩子函数，适合处理<strong>功耗管理</strong>、看门狗喂狗等工作。空闲线程必须有得到执行的机会，即其他线程不允许一直while(1)死卡，必须调用具有阻塞性质的函数；<strong>否则例如线程删除、回收等操作将无法得到正确执行。</strong></li></ul><h1 id="十、主线程"><a href="#十、主线程" class="headerlink" title="十、主线程"></a>十、主线程</h1><p><img src="/2025/02/16/RTOS/RT-Thread/RT-Thread-1-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/3.png" alt="主线程调用过程"></p><h1 id="十一、创建和删除线程"><a href="#十一、创建和删除线程" class="headerlink" title="十一、创建和删除线程"></a>十一、创建和删除线程</h1><ul><li>动态创建</li></ul><p><strong>分配出来的栈空间是按照 rtconfig.h 中配置的 RT_ALIGN_SIZE 方式对齐</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                            <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter),</span></span><br><span class="line"><span class="params">                            <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint8_t</span> priority,</span></span><br><span class="line"><span class="params">                            <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中的宏 RT_NAME_MAX 指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0~255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>thread</td><td>线程创建成功，返回线程句柄</td></tr><tr><td>RT_NULL</td><td>线程创建失败</td></tr></tbody></table><ul><li>删除</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delete</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li>用 rt_thread_delete() 函数删除线程接口，仅仅是把相应的线程状态更改为 RT_THREAD_CLOSE 状态，然后放入到 rt_thread_defunct 队列中；而真正的删除动作（释放线程控制块和释放线程栈）需要到下一次执行空闲线程时，由空闲线程完成最后的线程删除动作</li></ul><p><strong>仅在使能了系统动态堆时才有效</strong></p><h1 id="十二、初始化和脱离线程"><a href="#十二、初始化和脱离线程" class="headerlink" title="十二、初始化和脱离线程"></a>十二、初始化和脱离线程</h1><ul><li>静态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_init</span><span class="params">(<span class="keyword">struct</span> rt_thread* thread,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter), <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>* stack_start, <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span> priority, <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄。线程句柄由用户提供出来，并指向对应的线程控制块内存地址</td></tr><tr><td>name</td><td>线程的名称；线程名称的最大长度由 rtconfig.h 中定义的 RT_NAME_MAX 宏指定，多余部分会被自动截掉</td></tr><tr><td>entry</td><td>线程入口函数</td></tr><tr><td>parameter</td><td>线程入口函数参数</td></tr><tr><td>stack_start</td><td>线程栈起始地址</td></tr><tr><td>stack_size</td><td>线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如 ARM 体系结构中需要向 4 字节地址对齐）</td></tr><tr><td>priority</td><td>线程的优先级。优先级范围根据系统配置情况（rtconfig.h 中的 RT_THREAD_PRIORITY_MAX 宏定义），如果支持的是 256 级优先级，那么范围是从 0 ～ 255，数值越小优先级越高，0 代表最高优先级</td></tr><tr><td>tick</td><td>线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>线程创建成功</td></tr><tr><td>-RT_ERROR</td><td>线程创建失败</td></tr></tbody></table><ul><li>脱离</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_detach</span> <span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><p><strong>线程本身不应调用这个接口脱离线程本身</strong></p><h1 id="十三、启动线程"><a href="#十三、启动线程" class="headerlink" title="十三、启动线程"></a>十三、启动线程</h1><p><strong>创建（初始化）的线程状态处于初始状态，并未进入就绪线程的调度队列，我们可以在线程初始化 &#x2F; 创建成功后调用下面的函数接口让该线程进入就绪态：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_startup</span><span class="params">(<span class="type">rt_thread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h1 id="十四、获得当前线程"><a href="#十四、获得当前线程" class="headerlink" title="十四、获得当前线程"></a>十四、获得当前线程</h1><p>在程序的运行过程中，相同的一段代码可能会被多个线程执行，在执行的时候可以通过下面的函数接口获得当前执行的线程句柄：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_thread_t</span> <span class="title function_">rt_thread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="十五、使线程让出CUP资源"><a href="#十五、使线程让出CUP资源" class="headerlink" title="十五、使线程让出CUP资源"></a>十五、使线程让出CUP资源</h1><p>当前线程的时间片用完或者该线程主动要求让出处理器资源时，它将不再占有处理器，调度器会选择相同优先级的下一个线程执行。线程调用这个接口后，这个线程仍然在就绪队列中。线程让出处理器使用下面的函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="十六、线程睡眠"><a href="#十六、线程睡眠" class="headerlink" title="十六、线程睡眠"></a>十六、线程睡眠</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_sleep</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_delay</span><span class="params">(<span class="type">rt_tick_t</span> tick)</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_mdelay</span><span class="params">(<span class="type">rt_int32_t</span> ms)</span>;</span><br></pre></td></tr></table></figure><h1 id="十七、挂起和恢复线程"><a href="#十七、挂起和恢复线程" class="headerlink" title="十七、挂起和恢复线程"></a>十七、挂起和恢复线程</h1><h1 id="十八、控制线程"><a href="#十八、控制线程" class="headerlink" title="十八、控制线程"></a>十八、控制线程</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_control</span><span class="params">(<span class="type">rt_thread_t</span> thread, <span class="type">rt_uint8_t</span> cmd, <span class="type">void</span>* arg)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>thread</td><td>线程句柄</td></tr><tr><td>cmd</td><td>指示控制命令</td></tr><tr><td>arg</td><td>控制参数</td></tr><tr><td><strong>返回</strong></td><td>——</td></tr><tr><td>RT_EOK</td><td>控制执行正确</td></tr><tr><td>-RT_ERROR</td><td>失败</td></tr></tbody></table><ul><li>RT_THREAD_CTRL_CHANGE_PRIORITY：动态更改线程的优先级；</li><li>RT_THREAD_CTRL_STARTUP：开始运行一个线程，等同于 rt_thread_startup() 函数调用；</li><li>RT_THREAD_CTRL_CLOSE：关闭一个线程，等同于 rt_thread_delete() 或 rt_thread_detach() 函数调用。</li></ul><h1 id="十九、设置和删除空闲钩子"><a href="#十九、设置和删除空闲钩子" class="headerlink" title="十九、设置和删除空闲钩子"></a>十九、设置和删除空闲钩子</h1><p>可以在系统执行空闲线程时，自动执行空闲钩子函数来做一些其他事情，比如系统指示灯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_idle_delhook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>注：空闲线程是一个线程状态永远为就绪态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，例如 rt_thread_delay()，rt_sem_take() 等可能会导致线程挂起的函数都不能使用。并且，由于 malloc、free 等内存相关的函数内部使用了信号量作为临界区保护，因此在钩子函数内部也不允许调用此类函数！</p><h1 id="二十、设置调度器钩子"><a href="#二十、设置调度器钩子" class="headerlink" title="二十、设置调度器钩子"></a>二十、设置调度器钩子</h1><p>有时用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。在系统线程切换时，这个钩子函数将被调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_scheduler_sethook</span><span class="params">(<span class="type">void</span> (*hook)(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to))</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hook</span><span class="params">(<span class="keyword">struct</span> rt_thread* from, <span class="keyword">struct</span> rt_thread* to)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>函数参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>from</td><td>表示系统所要切换出的线程控制块指针</td></tr><tr><td>to</td><td>表示系统所要切换到的线程控制块指针</td></tr></tbody></table><p>在这个钩子函数中，基本上不允许调用系统 API</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、线程栈&quot;&gt;&lt;a href=&quot;#一、线程栈&quot; class=&quot;headerlink&quot; title=&quot;一、线程栈&quot;&gt;&lt;/a&gt;一、线程栈&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;RT-Thread 线程具有独立的栈，当进行线程切换时，会将当前线程的上下文存在栈中，当线程要恢复运行时</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-1-ADC</title>
    <link href="https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/"/>
    <id>https://ydw-item.github.io.git/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/</id>
    <published>2025-02-15T16:20:05.000Z</published>
    <updated>2025-02-18T12:22:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-初始化设备stm32-adc-init"><a href="#一、-初始化设备stm32-adc-init" class="headerlink" title="一、 初始化设备stm32_adc_init()"></a>一、 初始化设备stm32_adc_init()</h1><p>​进行板级初始化</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/1.png" alt="image-20250213213546245"></p><h3 id="1-1定义adc-config数组"><a href="#1-1定义adc-config数组" class="headerlink" title="1.1定义adc_config数组"></a>1.1定义adc_config数组</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/2.png" alt="image-20250213215103492"></p><p>数组中有几个值通过board.h中的宏定义来确定，同时数组中的最后一个元素后面在某些标准下是被允许加逗号的</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/3.png" alt="image-20250213215514039"></p><p>如果打开ADC1和ADC2，那么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc_config[] =&#123;ADC1_CONFIG,ADC3_CONFIG&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-2-ADC1-CONFIG是什么"><a href="#1-2-ADC1-CONFIG是什么" class="headerlink" title="1.2 ADC1_CONFIG是什么"></a>1.2 ADC1_CONFIG是什么</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/4.png" alt="image-20250213215847418"></p><h3 id="1-3-ADC-HandleTypeDef是什么类型"><a href="#1-3-ADC-HandleTypeDef是什么类型" class="headerlink" title="1.3 ADC_HandleTypeDef是什么类型"></a>1.3 ADC_HandleTypeDef是什么类型</h3><p>是 <strong>STM32 HAL（硬件抽象层）库</strong> 中的一个结构体，用于表示 <strong>ADC（模拟到数字转换器）</strong> 外设的配置和状态</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/5.png" alt="image-20250213221307498"></p><p><strong><code>Instance</code></strong></p><ul><li>类型：<code>ADC_TypeDef *</code></li><li><strong>描述</strong>：指向 ADC 模块寄存器的指针。不同的 STM32 微控制器有多个 ADC 模块（如 <code>ADC1</code>, <code>ADC2</code>, <code>ADC3</code> 等），<code>Instance</code> 用于标识当前操作的是哪个 ADC 模块。</li></ul><p><strong><code>Init</code></strong></p><ul><li><p>类型：<code>ADC_InitTypeDef</code></p></li><li><p>描述</p><p>  ：包含 ADC 初始化配置的结构体。它包含了多个配置选项，如 ADC 时钟、分辨率、数据对齐方式等。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADC_InitTypeDef</span><br></pre></td></tr></table></figure><p>   是一个结构体，通常包括以下字段：</p><ul><li><code>ClockPrescaler</code>：ADC 时钟的预分频器。</li><li><code>Resolution</code>：ADC 分辨率（如 12 位、10 位、8 位）。</li><li><code>DataAlign</code>：数据对齐方式（如左对齐或右对齐）。</li><li><code>ScanConvMode</code>：是否启用扫描模式（多个通道转换）。</li><li><code>ContinuousConvMode</code>：是否启用连续转换模式。</li><li><code>ExternalTrigConv</code>：外部触发类型（如软件触发、定时器触发等）。</li></ul></li></ul><p><strong><code>DMA_Handle</code></strong></p><ul><li>类型：<code>DMA_HandleTypeDef *</code></li><li><strong>描述</strong>：指向 DMA（直接存储器访问）句柄的指针。如果使用 DMA 进行 ADC 数据传输，这个字段指向一个 <code>DMA_HandleTypeDef</code> 结构，用于管理 DMA 的配置。</li></ul><p><strong><code>State</code></strong></p><ul><li>类型：<code>__IO uint32_t *</code></li><li><strong>描述</strong>：指向 ADC 状态的指针。这个字段通常用于存储 ADC 的当前状态，如转换进行中、转换完成等状态信息。</li></ul><p><strong><code>ErrorCode</code></strong></p><ul><li>类型：<code>__IO uint32_t</code></li><li><strong>描述</strong>：存储 ADC 操作过程中发生的错误代码。这可以帮助调试和排查问题，比如发生了什么错误，是否由于配置问题导致操作失败等。</li></ul><h3 id="1-4-启用了几个ADC就定义几个stm32-adc-obj-元素"><a href="#1-4-启用了几个ADC就定义几个stm32-adc-obj-元素" class="headerlink" title="1.4 启用了几个ADC就定义几个stm32_adc_obj[]元素"></a>1.4 启用了几个ADC就定义几个stm32_adc_obj[]元素</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/8.png" alt="image-20250213223809186"></p><h3 id="1-5-ADC-Handler和adc-config是一个类型的变量"><a href="#1-5-ADC-Handler和adc-config是一个类型的变量" class="headerlink" title="1.5 ADC_Handler和adc_config是一个类型的变量"></a>1.5 ADC_Handler和adc_config是一个类型的变量</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/7.png" alt="image-20250213224057191"></p><h3 id="1-6-for循环"><a href="#1-6-for循环" class="headerlink" title="1.6 for循环"></a>1.6 for循环</h3><p>用sizeof判断使用了几个ADC，使用了几个ADC就循环几此</p><p>1.把adc_config赋值给ADC_Hander(因为第6小点)</p><p>2.通过stm32f407xx.h判断是否有这个外设</p><p>3.Instance中存放的名字是ADCx，是ADC几就把几赋值给name_buf[3]</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/6.png" alt="image-20250213222200867"></p><h3 id="1-7-HAL-ADC-Init"><a href="#1-7-HAL-ADC-Init" class="headerlink" title="1.7 HAL_ADC_Init()"></a>1.7 HAL_ADC_Init()</h3><p>1.传入ADC_HandleTypeDef类型的值，初始化ADC</p><p>2.如果返回错误，答应init failed</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/9.png" alt="99e47c9c-0550-49aa-992d-62ec87fad64a"></p><h3 id="1-8-rt-hw-adc-register"><a href="#1-8-rt-hw-adc-register" class="headerlink" title="1.8 rt_hw_adc_register()"></a>1.8 rt_hw_adc_register()</h3><p>用于注册硬件 ADC 的函数，它将 ADC 驱动和硬件抽象层（HAL）关联起来,使得 RT-Thread 可以识别和使用指定的 ADC 外设</p><ul><li><strong>初始化硬件 ADC 驱动</strong>：这个函数将硬件 ADC 外设与 RT-Thread 的设备模型进行注册，使得 RT-Thread 可以管理和访问硬件 ADC。</li><li><strong>设备注册</strong>：它会在 RT-Thread 的设备模型中创建一个 ADC 设备对象，从而让系统能够通过统一的接口（例如 <code>read()</code>、<code>write()</code> 等）来操作硬件。</li><li><strong>设备抽象层支持</strong>：通过设备抽象层，用户可以通过设备操作接口（如打开设备、关闭设备、读取数据等）与硬件 ADC 进行交互。</li></ul><h3 id="1-9rt-adc-device-是用于表示一个-ADC-设备-的结构体"><a href="#1-9rt-adc-device-是用于表示一个-ADC-设备-的结构体" class="headerlink" title="1.9rt_adc_device 是用于表示一个 ADC 设备 的结构体"></a>1.9<code>rt_adc_device</code> 是用于表示一个 <strong>ADC 设备</strong> 的结构体</h3><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/10.png" alt="image-20250213230813789"></p><h3 id="1-10-struct-rt-adc-ops"><a href="#1-10-struct-rt-adc-ops" class="headerlink" title="1.10 struct rt_adc_ops"></a>1.10 struct rt_adc_ops</h3><p> RT-Thread 中与 <strong>ADC（模拟到数字转换器）</strong> 设备交互的操作函数结构体，它包含了一组函数指针</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/13.png" alt="image-20250213231324141"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/11.png" alt="image-20250213231110666"></p><h1 id="二、查找ADC设备rt-device-find"><a href="#二、查找ADC设备rt-device-find" class="headerlink" title="二、查找ADC设备rt_device_find()"></a>二、查找ADC设备rt_device_find()</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_NAME        <span class="string">&quot;adc1&quot;</span>  <span class="comment">/* ADC 设备名称 */</span></span></span><br><span class="line"><span class="type">rt_adc_device_t</span> adc_dev;            <span class="comment">/* ADC 设备句柄 */</span></span><br><span class="line"><span class="comment">/* 查找设备 */</span></span><br><span class="line">adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br></pre></td></tr></table></figure><h1 id="三、使能ADC通道rt-adc-enable（）"><a href="#三、使能ADC通道rt-adc-enable（）" class="headerlink" title="三、使能ADC通道rt_adc_enable（）"></a>三、使能ADC通道rt_adc_enable（）</h1><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/18.png" alt="image-20250218192237456"></p><h3 id="3-1-stm32-adc-enabled"><a href="#3-1-stm32-adc-enabled" class="headerlink" title="3.1 stm32_adc_enabled"></a>3.1 stm32_adc_enabled</h3><p><strong>rt_adc_enable()<strong>中调用了硬件驱动层函数</strong>stm32_adc_enabled()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/19.png" alt="image-20250218192444206"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/12.png" alt="image-20250218143021553"></p><ul><li>传入<strong>device</strong>和<strong>enabled</strong>参数，此处的<strong>channel</strong>没用到</li></ul><h1 id="四、读取通道值rt-adc-read（）"><a href="#四、读取通道值rt-adc-read（）" class="headerlink" title="四、读取通道值rt_adc_read（）"></a>四、读取通道值rt_adc_read（）</h1><p>获取ADC通道的值，存入<strong>value</strong>变量中</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/23.png" alt="image-20250218193225562"></p><h3 id="4-1-stm32-get-adc-value"><a href="#4-1-stm32-get-adc-value" class="headerlink" title="4.1 stm32_get_adc_value()"></a>4.1 stm32_get_adc_value()</h3><p><strong>rt_adc_read()<strong>中调用了硬件驱动层函数</strong>1stm32_get_adc_value()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/20.png" alt="image-20250218193118064"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/16.png" alt="image-20250218193915303"></p><h3 id="4-2-stm32-adc-get-channel"><a href="#4-2-stm32-adc-get-channel" class="headerlink" title="4.2 stm32_adc_get_channel()"></a>4.2 stm32_adc_get_channel()</h3><p>将通道的数字转换成ADC通道的地址</p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/14.png" alt="image-20250218143654896"></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/15.png" alt="image-20250218143716406"></p><h1 id="五、-关闭ADC通道rt-adc-disable"><a href="#五、-关闭ADC通道rt-adc-disable" class="headerlink" title="五、 关闭ADC通道rt_adc_disable()"></a>五、 关闭ADC通道rt_adc_disable()</h1><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/21..png" alt="image-20250218194154075"></p><h3 id="5-1-stm32-adc-enabled"><a href="#5-1-stm32-adc-enabled" class="headerlink" title="5.1 stm32_adc_enabled()"></a>5.1 stm32_adc_enabled()</h3><p><strong>rt_adc_disable()<strong>中调用了硬件驱动层函数</strong>stm32_adc_enabled()</strong></p><p><img src="/2025/02/16/RTOS/RT-Thread/2.RT-Thread-ADC/22.png" alt="image-20250218200837908"></p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_NAME        <span class="string">&quot;adc1&quot;</span>  <span class="comment">/* ADC 设备名称 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_DEV_CHANNEL     5       <span class="comment">/* ADC 通道 */</span></span></span><br><span class="line"><span class="type">rt_adc_device_t</span> adc_dev;            <span class="comment">/* ADC 设备句柄 */</span></span><br><span class="line"><span class="type">rt_uint32_t</span> value；</span><br><span class="line"><span class="comment">/* 查找设备 */</span></span><br><span class="line">adc_dev = (<span class="type">rt_adc_device_t</span>)rt_device_find(ADC_DEV_NAME);</span><br><span class="line"><span class="comment">/* 使能设备 */</span></span><br><span class="line">rt_adc_enable(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"><span class="comment">/* 读取采样值 */</span></span><br><span class="line">value = rt_adc_read(adc_dev, ADC_DEV_CHANNEL);</span><br><span class="line"><span class="comment">/* 转换为对应电压值 */</span></span><br><span class="line">vol = value * REFER_VOLTAGE / CONVERT_BITS;</span><br><span class="line">rt_kprintf(<span class="string">&quot;the voltage is :%d.%02d \n&quot;</span>, vol / <span class="number">100</span>, vol % <span class="number">100</span>);</span><br><span class="line"><span class="comment">/* 关闭通道 */</span></span><br><span class="line">rt_adc_disable(adc_dev, ADC_DEV_CHANNEL);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、-初始化设备stm32-adc-init&quot;&gt;&lt;a href=&quot;#一、-初始化设备stm32-adc-init&quot; class=&quot;headerlink&quot; title=&quot;一、 初始化设备stm32_adc_init()&quot;&gt;&lt;/a&gt;一、 初始化设备stm32_adc_</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
  <entry>
    <title>RT-Thread-0-启动流程</title>
    <link href="https://ydw-item.github.io.git/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://ydw-item.github.io.git/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2025-02-15T15:57:05.000Z</published>
    <updated>2024-02-15T15:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、startup-stm32f407xx-S"><a href="#一、startup-stm32f407xx-S" class="headerlink" title="一、startup_stm32f407xx.S"></a>一、startup_stm32f407xx.S</h1><p>系统进入汇编文件</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image-20250215165008148"></p><p><strong>RT-Thread使用的是GCC</strong></p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/rtt_startup.png" alt="启动流程"></p><h1 id="二、不同编译器的启动函数"><a href="#二、不同编译器的启动函数" class="headerlink" title="二、不同编译器的启动函数"></a>二、不同编译器的启动函数</h1><p>调用stm32f407_demo3\rt-thread\src\components.c中的$Sub$$main()</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image-20250215223923007"></p><h1 id="三、调用rtthread-startup-void"><a href="#三、调用rtthread-startup-void" class="headerlink" title="三、调用rtthread_startup(void)"></a>三、调用rtthread_startup(void)</h1><p>在stm32f407_demo3\rt-thread\src\components.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rtthread_startup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 禁用了所有中断 */</span></span><br><span class="line">    rt_hw_interrupt_disable();</span><br><span class="line">    <span class="comment">/* 执行板级支持包（BSP）初始化 </span></span><br><span class="line"><span class="comment">       包括配置硬件、系统时钟、外设初始化等 */</span></span><br><span class="line">    rt_hw_board_init();</span><br><span class="line"> <span class="comment">/* 打印 RT-Thread 操作系统的版本信息 */</span></span><br><span class="line">    rt_show_version();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的定时器子系统 */</span></span><br><span class="line">    rt_system_timer_init();</span><br><span class="line">    <span class="comment">/* 初始化操作系统的调度器 */</span></span><br><span class="line">    rt_system_scheduler_init();</span><br><span class="line"><span class="comment">/* 如果启用了信号系统 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SIGNALS</span></span><br><span class="line">    <span class="comment">/* 初始化信号系统 */</span></span><br><span class="line">    rt_system_signal_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 创建应用任务、初始化外设 */</span></span><br><span class="line">    rt_application_init();</span><br><span class="line">    <span class="comment">/* 初始化定时器线程 */</span></span><br><span class="line">    rt_system_timer_thread_init();</span><br><span class="line">    <span class="comment">/* 初始化空闲线程 */</span></span><br><span class="line">    rt_thread_idle_init();</span><br><span class="line"><span class="comment">/* 如果启用了 SMP（对称多处理） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SMP</span></span><br><span class="line">    <span class="comment">/* 进行多核处理器的初始化和同步 */</span></span><br><span class="line">    rt_hw_spin_lock(&amp;_cpus_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*RT_USING_SMP*/</span></span></span><br><span class="line">    <span class="comment">/* 开始任务调度 */</span></span><br><span class="line">    rt_system_scheduler_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* never reach here */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1rt-hw-board-init和rt-application-init的-外设初始化的不同"><a href="#3-1rt-hw-board-init和rt-application-init的-外设初始化的不同" class="headerlink" title="3.1rt_hw_board_init和rt_application_init的 外设初始化的不同"></a>3.1rt_hw_board_init和rt_application_init的 外设初始化的不同</h2><ul><li><strong>rt_hw_board_init</strong></li></ul><p><strong>硬件初始化</strong>：<em><strong>初始化硬件资源</strong></em>，如 GPIO、串口、SPI、I2C、PWM、ADC、定时器等。</p><p><strong>系统时钟配置</strong>：配置系统时钟、外设时钟以及 PLL（锁相环）等，确保系统和外设运行在合适的频率下。</p><p><strong>内存初始化</strong>：配置堆栈、堆内存和静态内存区域，确保系统资源可用。</p><p><strong>中断配置</strong>：初始化中断控制器，并为特定外设启用中断。</p><p><strong>启动引导程序</strong>：执行系统初始化，如配置时钟源、初始化硬件外设等，通常会包括一个初始化阶段的启动代码。</p><p><strong>设备驱动注册</strong>：为基础硬件外设（如 UART、SPI、I2C 等）注册驱动，使操作系统能够访问这些外设。</p><ul><li><strong>rt_application_init</strong></li></ul><p><strong>创建应用任务</strong>：创建系统中的应用任务，例如数据采集任务、处理任务等。</p><p><strong>初始化外设</strong>：在 <strong>应用层</strong> 对外设进行更高层次的初始化。例如，在硬件初始化后，可能会初始化一些<em><strong>外设的具体参数</strong></em>，如设置 ADC 采样周期、配置传感器等。</p><p><strong>启动应用程序逻辑</strong>：进行传感器数据采集、通信协议的初始化、数据处理等应用相关的工作。</p><p><strong>任务调度和资源管理</strong>：创建并调度多个任务，管理应用程序层的资源。</p><h2 id="3-2rt-hw-board-init"><a href="#3-2rt-hw-board-init" class="headerlink" title="3.2rt_hw_board_init()"></a>3.2rt_hw_board_init()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RT_WEAK <span class="type">void</span> <span class="title function_">rt_hw_board_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Heap initialization */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_HEAP)</span></span><br><span class="line">    rt_system_heap_init((<span class="type">void</span> *) HEAP_BEGIN, (<span class="type">void</span> *) HEAP_END);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 时钟源初始化，配置 MCU 的时钟系统，设置系统时钟、外设时钟 */</span></span><br><span class="line">    hw_board_init(BSP_CLOCK_SOURCE, BSP_CLOCK_SOURCE_FREQ_MHZ, BSP_CLOCK_SYSTEM_FREQ_MHZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置控制台设备。通常，这意味着将输出通过串口或其他通信接口进行调试输出。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(RT_USING_DEVICE) &amp;&amp; defined(RT_USING_CONSOLE)</span></span><br><span class="line">    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 始化板级硬件组件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_COMPONENTS_INIT</span></span><br><span class="line">    rt_components_board_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1hw-board-init"><a href="#3-2-1hw-board-init" class="headerlink" title="3.2.1hw_board_init()"></a>3.2.1hw_board_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">oid <span class="title function_">hw_board_init</span><span class="params">(<span class="type">char</span> *clock_src, <span class="type">int32_t</span> clock_src_freq, <span class="type">int32_t</span> clock_target_freq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">rt_hw_systick_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">clk_init</span><span class="params">(<span class="type">char</span> *clk_source, <span class="type">int</span> source_freq, <span class="type">int</span> target_freq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableICache</span></span><br><span class="line">    <span class="comment">/* 开启指令缓存，用于加速程序的指令获取。*/</span></span><br><span class="line">    SCB_EnableICache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCB_EnableDCache</span></span><br><span class="line">    <span class="comment">/* 开启数据缓存，用于加速数据存取。*/</span></span><br><span class="line">    SCB_EnableDCache();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 HAL 库需要的硬件资源，例如时钟配置、外设初始化等 */</span></span><br><span class="line">    HAL_Init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器清零，开启全局中断 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* 初始化系统时钟 */</span></span><br><span class="line">    clk_init(clock_src, clock_src_freq, clock_target_freq);</span><br><span class="line">    <span class="comment">/* 将 PRIMASK 寄存器设置为 1，禁止全局中断。确保时钟配置的过程中不会受到中断的干扰 */</span></span><br><span class="line">    __set_PRIMASK(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 初始化 SysTick 定时器 */</span></span><br><span class="line">    rt_hw_systick_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化与硬件引脚相关的驱动（如 GPIO 控制）。 </span></span><br><span class="line"><span class="comment">       初始化所有的通用输入输出引脚，设置引脚模式、方向、输出类型等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_PIN</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_pin_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_pin_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 USART 驱动 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RT_USING_SERIAL</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">    rt_hw_usart_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image-20250215174007724"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rt_hw_usart_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 计算定义了几个串口，通过串口配置结构体的总大小/每个结构体的大小来计算*/</span></span><br><span class="line">    <span class="type">rt_size_t</span> obj_num = <span class="keyword">sizeof</span>(uart_obj) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> stm32_uart);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">serial_configure</span> <span class="title">config</span> =</span> RT_SERIAL_CONFIG_DEFAULT;</span><br><span class="line">    <span class="type">rt_err_t</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    stm32_uart_get_dma_config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj_num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_obj[i].config = &amp;uart_config[i];</span><br><span class="line">        uart_obj[i].serial.ops    = &amp;stm32_uart_ops;</span><br><span class="line">        uart_obj[i].serial.config = config;</span><br><span class="line">        <span class="comment">/* 用于注册串口设备，将串口设备与操作系统的设备管理系统连接起来，使得串口设备能够被操作系统识别和管理</span></span><br><span class="line"><span class="comment">        register ----  注册*/</span></span><br><span class="line">        result = rt_hw_serial_register(&amp;uart_obj[i].serial, uart_obj[i].config-&gt;name,</span><br><span class="line">                                       RT_DEVICE_FLAG_RDWR</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_RX</span><br><span class="line">                                       | RT_DEVICE_FLAG_INT_TX</span><br><span class="line">                                       | uart_obj[i].uart_dma_flag</span><br><span class="line">                                       , <span class="literal">NULL</span>);</span><br><span class="line">        RT_ASSERT(result == RT_EOK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image-20250215174346247"></p><h2 id="3-3-rt-show-version-void"><a href="#3-3-rt-show-version-void" class="headerlink" title="3.3 rt_show_version(void)"></a>3.3 rt_show_version(void)</h2><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image-20250215224815579"></p><h2 id="3-4-rt-application-init"><a href="#3-4-rt-application-init" class="headerlink" title="3.4 rt_application_init()"></a>3.4 rt_application_init()</h2><p>创建main()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image-20250215230134023"></p><h2 id="3-5-rt-system-timer-thread-init"><a href="#3-5-rt-system-timer-thread-init" class="headerlink" title="3.5 rt_system_timer_thread_init()"></a>3.5 rt_system_timer_thread_init()</h2><p>创建rt_thread_timer_entry()线程</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image-20250215230248093"></p><h3 id="3-5-1rt-thread-timer-entry"><a href="#3-5-1rt-thread-timer-entry" class="headerlink" title="3.5.1rt_thread_timer_entry()"></a>3.5.1rt_thread_timer_entry()</h3><p>专门用于处理软件定时器的线程函数,定期检查并触发到期的定时器回调。当没有定时器超时时，当前线程会被挂起，直到下一个定时器到期为止。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image-20250215231635484"></p><ul><li>它首先通过 <code>rt_timer_list_next_timeout</code> 获取下一个定时器的超时时间。</li><li>如果没有定时器超时，它会挂起当前线程，直到有定时器超时。</li><li>如果有定时器将要超时，函数会计算剩余时间，并使线程在该时间段内休眠，直到定时器超时。</li><li>每次循环结束时，<code>rt_soft_timer_check()</code> 会检查所有的软件定时器，触发到期的定时器回调。</li></ul><h2 id="3-6-rt-thread-idle-init"><a href="#3-6-rt-thread-idle-init" class="headerlink" title="3.6 rt_thread_idle_init()"></a>3.6 rt_thread_idle_init()</h2><p>初始化 <strong>空闲线程</strong>,是操作系统中的一个特殊线程，它在所有其他任务都没有运行时执行。通常，空闲线程用来降低系统功耗，或者执行一些后台清理任务。</p><p><img src="/2025/02/15/RTOS/RT-Thread/RT-Thread-0-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image-20250215232409967"></p><h1 id="四、宏定义函数执行顺序"><a href="#四、宏定义函数执行顺序" class="headerlink" title="四、宏定义函数执行顺序"></a>四、宏定义函数执行顺序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 负责硬件平台的初始化，如时钟配置、外设初始化等。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, <span class="string">&quot;1&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化一些软件模块，可能包括设置一些内核参数、初始化操作系统调度器等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_PREV_EXPORT(fn)            INIT_EXPORT(fn, <span class="string">&quot;2&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 初始化系统中的外设，如串口、GPIO、I2C、SPI 等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, <span class="string">&quot;3&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 包括文件系统（如 FatFS）、网络协议栈（如 lwIP）和其他应用组件的初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, <span class="string">&quot;4&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 涉及外部设备的挂载、环境配置、磁盘挂载等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_ENV_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;5&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 与应用程序级别的初始化相关，如图形界面（rtgui）、应用任务初始化等 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, <span class="string">&quot;6&quot;</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、startup-stm32f407xx-S&quot;&gt;&lt;a href=&quot;#一、startup-stm32f407xx-S&quot; class=&quot;headerlink&quot; title=&quot;一、startup_stm32f407xx.S&quot;&gt;&lt;/a&gt;一、startup_stm32f4</summary>
      
    
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/categories/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/categories/RTOS/RT-Thread/"/>
    
    
    <category term="RTOS" scheme="https://ydw-item.github.io.git/tags/RTOS/"/>
    
    <category term="RT-Thread" scheme="https://ydw-item.github.io.git/tags/RT-Thread/"/>
    
  </entry>
  
</feed>
